---
title: "Redis 源码阅读：12. AE 事件库 (Reactor 模式)"
date: 2026-01-11T10:00:00+08:00
description: "Redis 高并发的核心秘密：AE 事件库。深入解析 Redis 的 Reactor 模型与 IO 多路复用实现。"
tags: [Redis, Source Code, AE, Reactor, Event Loop]
weight: 12
---

Redis 是**单线程**的，但为什么它能每秒处理 10 万+ 的请求？
答案就是 **IO 多路复用 (IO Multiplexing)** 配合 **非阻塞 IO (Non-blocking IO)**。

Redis 将这套机制封装成了 **AE (Async Event)** 库，位于 `src/ae.c`。

## 1. 什么是 AE？
AE 是一个简单的事件驱动框架，它支持两类事件：
1.  **文件事件 (File Event)**：Socket 的读写（Readable/Writable）。
2.  **时间事件 (Time Event)**：定时任务（如 `serverCron`）。

## 2. IO 多路复用封装
Redis 支持多种 IO 多路复用机制，并在编译时自动选择性能最好的一种：
*   **evport** (Solaris 10)
*   **epoll** (Linux)
*   **kqueue** (macOS/FreeBSD)
*   **select** (Generic fallback)

它们都被封装在 `ae_epoll.c`, `ae_kqueue.c` 等文件中，对外提供统一的接口：`aeApiAddEvent`, `aeApiDelEvent`, `aeApiPoll`。

## 3. 事件循环 (Event Loop)
AE 的核心是一个死循环 `aeMain` -> `aeProcessEvents`。

在 `aeProcessEvents` 中：
1.  **计算阻塞时间**：查找最近的时间事件，计算还需要等待多久。
2.  **阻塞等待**：调用 `aeApiPoll` (即 `epoll_wait`) 等待文件事件发生，超时时间为上一步计算的值。
3.  **处理文件事件**：如果 Socket 可读，调用读处理器；如果可写，调用写处理器。
4.  **处理时间事件**：检查是否有定时任务到期，如果有则执行。

## 4. 总结
Redis 的“单线程”是指**命令处理**是单线程的。通过 AE 库，Redis 可以用一个线程高效地管理成千上万个连接，避免了多线程上下文切换的开销和锁竞争。
