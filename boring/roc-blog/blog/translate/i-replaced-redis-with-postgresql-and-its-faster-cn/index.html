<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>用 PostgreSQL 替换 Redis（竟然更快） | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/translate/> /translate </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-09</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">用 PostgreSQL 替换 Redis（竟然更快）</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=yong-postgresql-ti-huan-redis-jing-ran-geng-kuai>用 PostgreSQL 替换 Redis（竟然更快）</h1><blockquote><p>原文：I Replaced Redis with PostgreSQL (And It’s Faster)<br> 作者：Polliog<br> 首发：DEV Community（dev.to）<br> 链接：<a href=https://dev.to/polliog/i-replaced-redis-with-postgresql-and-its-faster-4942 rel=external>https://dev.to/polliog/i-replaced-redis-with-postgresql-and-its-faster-4942</a><br> 说明：由于抓取工具对页面内容有长度限制，本文译文目前覆盖到 PostgreSQL 的 LISTEN/NOTIFY 和 Live Tail 示例之前的部分，其余段落请参考原文。</blockquote><p>我原来的 Web 应用栈非常典型：<ul><li>PostgreSQL：负责持久化数据<li>Redis：负责缓存、Pub/Sub 和后台任务</ul><p>两套数据库，两套东西要维护，两处潜在故障点。<p>后来我意识到：<strong>PostgreSQL 其实可以干掉 Redis 做的所有事情。</strong><p>于是我直接把 Redis 整个撤掉，看看会发生什么。<hr><h2 id=wo-yuan-lai-shi-zen-me-yong-redis-de>我原来是怎么用 Redis 的</h2><p>在变更之前，Redis 主要干三件事：<h3 id=1-huan-cun-da-yue-zhan-70-shi-yong-liang>1. 缓存（大约占 70% 使用量）</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#616e88>// Cache API responses</span></span>
<span class=giallo-l><span style=color:#81a1c1>await</span><span> redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>set</span><span>(</span><span style=color:#eceff4>`</span><span style=color:#a3be8c>user:</span><span style=color:#81a1c1>${</span><span>id</span><span style=color:#81a1c1>}</span><span style=color:#eceff4>`,</span><span> JSON</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>stringify</span><span>(user)</span><span style=color:#eceff4>, '</span><span style=color:#a3be8c>EX</span><span style=color:#eceff4>',</span><span style=color:#b48ead> 3600</span><span>)</span><span style=color:#81a1c1>;</span></span></code></pre><h3 id=2-pub-sub-da-yue-zhan-20-shi-yong-liang>2. Pub/Sub（大约占 20% 使用量）</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#616e88>// Real-time notifications</span></span>
<span class=giallo-l><span>redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>publish</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>notifications</span><span style=color:#eceff4>',</span><span> JSON</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>stringify</span><span>(</span><span style=color:#eceff4>{</span><span> userId</span><span style=color:#eceff4>,</span><span> message</span><span style=color:#eceff4> }</span><span>))</span><span style=color:#81a1c1>;</span></span></code></pre><h3 id=3-hou-tai-ren-wu-dui-lie-da-yue-zhan-10-shi-yong-liang>3. 后台任务队列（大约占 10% 使用量）</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#616e88>// Using Bull/BullMQ</span></span>
<span class=giallo-l><span>queue</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>add</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>send-email</span><span style=color:#eceff4>', {</span><span> to</span><span style=color:#eceff4>,</span><span> subject</span><span style=color:#eceff4>,</span><span> body</span><span style=color:#eceff4> }</span><span>)</span><span style=color:#81a1c1>;</span></span></code></pre><p>这些用法本身没问题，Redis 完全胜任。但长期下来，我开始越来越不满意这种「一主一辅」的架构。<p><strong>痛点主要有：</strong><ul><li>两套数据库都要做备份<li>Redis 吃的是内存，规模一大成本很快上去<li>Redis 的持久化机制比较「门道多」<li>应用和 Redis 之间多了一跳网络</ul><hr><h2 id=wei-shen-me-kao-lu-yong-postgresql-ti-huan-redis>为什么考虑用 PostgreSQL 替换 Redis</h2><h3 id=li-you-yi-cheng-ben>理由一：成本</h3><p><strong>我的 Redis 配置：</strong><ul><li>AWS ElastiCache：2GB，约 $45/月<li>如果要扩到 5GB，要涨到约 $110/月</ul><p><strong>PostgreSQL：</strong><ul><li>已经在付 RDS 的钱：20GB 存储约 $50/月<li>多加 5GB 数据：大约 $0.50/月</ul><p><strong>潜在节省：一个月能省将近 $100。</strong><h3 id=li-you-er-yun-wei-fu-za-du>理由二：运维复杂度</h3><p>有 Redis 的时候，你的世界是这样的：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>Postgres backup ✅</span></span>
<span class=giallo-l><span>Redis backup ❓ (RDB? AOF? Both?)</span></span>
<span class=giallo-l><span>Postgres monitoring ✅</span></span>
<span class=giallo-l><span>Redis monitoring ❓</span></span>
<span class=giallo-l><span>Postgres failover ✅</span></span>
<span class=giallo-l><span>Redis Sentinel/Cluster ❓</span></span></code></pre><p>把 Redis 撤掉之后，世界变成：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>Postgres backup ✅</span></span>
<span class=giallo-l><span>Postgres monitoring ✅</span></span>
<span class=giallo-l><span>Postgres failover ✅</span></span></code></pre><p><strong>少了一个移动部件（moving part），整个系统就简单了很多。</strong><h3 id=li-you-san-shu-ju-yi-zhi-xing>理由三：数据一致性</h3><p>经典问题如下：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#616e88>// Update database</span></span>
<span class=giallo-l><span style=color:#81a1c1>await</span><span> db</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>UPDATE users SET name = $1 WHERE id = $2</span><span style=color:#eceff4>',</span><span> [name</span><span style=color:#eceff4>,</span><span> id])</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>// Invalidate cache</span></span>
<span class=giallo-l><span style=color:#81a1c1>await</span><span> redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>del</span><span>(</span><span style=color:#eceff4>`</span><span style=color:#a3be8c>user:</span><span style=color:#81a1c1>${</span><span>id</span><span style=color:#81a1c1>}</span><span style=color:#eceff4>`</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>// ⚠️ What if Redis is down?</span></span>
<span class=giallo-l><span style=color:#616e88>// ⚠️ What if this fails?</span></span>
<span class=giallo-l><span style=color:#616e88>// Now cache and DB are out of sync</span></span></code></pre><p>一旦更新数据库和操作缓存不是处在同一个事务里，你就必须考虑各种失败场景：Redis 掉线、网络抖动、重试策略……一大堆边界条件。<p>而如果所有东西都在 Postgres 里，<strong>事务本身就解决了一致性问题</strong>。<hr><h2 id=postgresql-te-xing-yi-yong-unlogged-biao-zuo-huan-cun>PostgreSQL 特性一：用 UNLOGGED 表做缓存</h2><p>先看 Redis 版本：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#81a1c1>await</span><span> redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>set</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>session:abc123</span><span style=color:#eceff4>',</span><span> JSON</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>stringify</span><span>(sessionData)</span><span style=color:#eceff4>, '</span><span style=color:#a3be8c>EX</span><span style=color:#eceff4>',</span><span style=color:#b48ead> 3600</span><span>)</span><span style=color:#81a1c1>;</span></span></code></pre><p>在 PostgreSQL 里，可以这样建一张缓存表：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#81a1c1>CREATE</span><span> UNLOGGED </span><span style=color:#81a1c1>TABLE</span><span> cache (</span></span>
<span class=giallo-l><span style=color:#81a1c1>  key TEXT PRIMARY KEY</span><span>,</span></span>
<span class=giallo-l><span style=color:#81a1c1>  value</span><span> JSONB </span><span style=color:#81a1c1>NOT NULL</span><span>,</span></span>
<span class=giallo-l><span>  expires_at </span><span style=color:#81a1c1>TIMESTAMPTZ NOT NULL</span></span>
<span class=giallo-l><span>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>CREATE INDEX</span><span style=color:#88c0d0> idx_cache_expires</span><span style=color:#81a1c1> ON</span><span> cache(expires_at);</span></span></code></pre><p>插入或更新缓存：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#81a1c1>INSERT INTO</span><span> cache (</span><span style=color:#81a1c1>key</span><span>, </span><span style=color:#81a1c1>value</span><span>, expires_at)</span></span>
<span class=giallo-l><span style=color:#81a1c1>VALUES</span><span> ($</span><span style=color:#b48ead>1</span><span>, $</span><span style=color:#b48ead>2</span><span>, </span><span style=color:#81a1c1>NOW</span><span style=color:#eceff4>()</span><span style=color:#81a1c1> +</span><span> INTERVAL </span><span style=color:#eceff4>'</span><span style=color:#a3be8c>1 hour</span><span style=color:#eceff4>'</span><span>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>ON</span><span> CONFLICT (</span><span style=color:#81a1c1>key</span><span>) DO </span><span style=color:#81a1c1>UPDATE</span></span>
<span class=giallo-l><span style=color:#81a1c1>  SET value =</span><span> EXCLUDED.value,</span></span>
<span class=giallo-l><span>      expires_at </span><span style=color:#81a1c1>=</span><span> EXCLUDED.expires_at;</span></span></code></pre><p>读取缓存：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#81a1c1>SELECT value FROM</span><span> cache</span></span>
<span class=giallo-l><span style=color:#81a1c1>WHERE key =</span><span> $</span><span style=color:#b48ead>1</span><span style=color:#81a1c1> AND</span><span> expires_at </span><span style=color:#81a1c1>> NOW</span><span style=color:#eceff4>()</span><span>;</span></span></code></pre><p>定期清理过期数据（可以用 cron 或调度任务跑）：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#81a1c1>DELETE FROM</span><span> cache </span><span style=color:#81a1c1>WHERE</span><span> expires_at </span><span style=color:#81a1c1>&lt; NOW</span><span style=color:#eceff4>()</span><span>;</span></span></code></pre><h3 id=shen-me-shi-unlogged-biao>什么是 UNLOGGED 表？</h3><p>UNLOGGED 表有几个关键特性：<ul><li>跳过 WAL（Write-Ahead Log，预写日志）<li>写入速度更快<li>崩溃后数据不会保留（而缓存本来就可以重建）</ul><p>一个实际测试结果：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>Redis SET: 0.05ms</span></span>
<span class=giallo-l><span>Postgres UNLOGGED INSERT: 0.08ms</span></span></code></pre><p>从纯延迟来看，Postgres 慢了几十微秒，但对于缓存这种场景来说，<strong>已经完全够用</strong>，而且还能少一条网络链路和一整套基础设施。<hr><h2 id=postgresql-te-xing-er-yong-listen-notify-zuo-pub-sub>PostgreSQL 特性二：用 LISTEN/NOTIFY 做 Pub/Sub</h2><p>有意思的地方来了：PostgreSQL 自带一个很多人都不知道的能力——<strong>原生 Pub/Sub</strong>。<h3 id=redis-pub-sub-xie-fa>Redis Pub/Sub 写法</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#616e88>// Publisher</span></span>
<span class=giallo-l><span>redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>publish</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>notifications</span><span style=color:#eceff4>',</span><span> JSON</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>stringify</span><span>(</span><span style=color:#eceff4>{</span><span style=color:#88c0d0> userId</span><span style=color:#eceff4>:</span><span style=color:#b48ead> 123</span><span style=color:#eceff4>,</span><span style=color:#88c0d0> msg</span><span style=color:#eceff4>: '</span><span style=color:#a3be8c>Hello</span><span style=color:#eceff4>' }</span><span>))</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>// Subscriber</span></span>
<span class=giallo-l><span>redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>subscribe</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>notifications</span><span style=color:#eceff4>'</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>on</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>message</span><span style=color:#eceff4>', (</span><span>channel</span><span style=color:#eceff4>,</span><span> message</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> =></span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>  console</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>log</span><span>(message)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span><span>)</span><span style=color:#81a1c1>;</span></span></code></pre><h3 id=postgresql-pub-sub-xie-fa>PostgreSQL Pub/Sub 写法</h3><p>发布端（SQL）：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#616e88>-- Publisher</span></span>
<span class=giallo-l><span>NOTIFY notifications, </span><span style=color:#eceff4>'</span><span style=color:#a3be8c>{"userId": 123, "msg": "Hello"}</span><span style=color:#eceff4>'</span><span>;</span></span></code></pre><p>订阅端（Node.js + pg）：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#616e88>// Subscriber (Node.js with pg)</span></span>
<span class=giallo-l><span style=color:#81a1c1>const</span><span> client</span><span style=color:#81a1c1> = new</span><span style=color:#88c0d0> Client</span><span>(</span><span style=color:#eceff4>{</span><span style=color:#88c0d0> connectionString</span><span style=color:#eceff4>:</span><span> process</span><span style=color:#eceff4>.</span><span>env</span><span style=color:#eceff4>.</span><span>DATABASE_URL</span><span style=color:#eceff4> }</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>await</span><span> client</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>connect</span><span>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>await</span><span> client</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>LISTEN notifications</span><span style=color:#eceff4>'</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>client</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>on</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>notification</span><span style=color:#eceff4>', (</span><span>msg</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> =></span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>  const</span><span> payload</span><span style=color:#81a1c1> =</span><span> JSON</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>parse</span><span>(msg</span><span style=color:#eceff4>.</span><span>payload)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>  console</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>log</span><span>(payload)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span><span>)</span><span style=color:#81a1c1>;</span></span></code></pre><h3 id=xing-neng-dui-bi>性能对比</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>Redis pub/sub latency: 1-2ms</span></span>
<span class=giallo-l><span>Postgres NOTIFY latency: 2-5ms</span></span></code></pre><p>Postgres 在这里确实稍微慢一点，但：<ul><li>不需要额外的基础设施<li>可以和事务结合使用<li>可以和查询、触发器等能力自然组合</ul><p>在很多系统里，这点延迟换来的架构简单性是非常划算的。<hr><h3 id=shi-zhan-shi-li-shi-shi-ri-zhi-live-tail>实战示例：实时日志 Live Tail</h3><p>在我的日志管理应用里，有一个需求是：<strong>实时推送日志（live tail）</strong>。<p><strong>用 Redis 时的做法：</strong><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#616e88>// When new log arrives</span></span>
<span class=giallo-l><span style=color:#81a1c1>await</span><span> db</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>INSERT INTO logs ...</span><span style=color:#eceff4>'</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>await</span><span> redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>publish</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>logs:new</span><span style=color:#eceff4>',</span><span> JSON</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>stringify</span><span>(log))</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>// Frontend listens</span></span>
<span class=giallo-l><span>redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>subscribe</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>logs:new</span><span style=color:#eceff4>'</span><span>)</span><span style=color:#81a1c1>;</span></span></code></pre><p>问题很明显：这是两个操作。如果 <code>publish</code> 失败了怎么办？如果 Redis 掉线了怎么办？插入成功但消息没发出去，前端就会错过这一条日志。<p><strong>换成 PostgreSQL 之后：</strong><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#81a1c1>CREATE FUNCTION</span><span style=color:#88c0d0> notify_new_log</span><span style=color:#eceff4>()</span><span style=color:#81a1c1> RETURNS</span><span> TRIGGER </span><span style=color:#81a1c1>AS</span><span> $$</span></span>
<span class=giallo-l><span style=color:#81a1c1>BEGIN</span></span>
<span class=giallo-l><span>  PERFORM pg_notify(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>logs_new</span><span style=color:#eceff4>'</span><span>, row_to_json(NEW)::</span><span style=color:#81a1c1>text</span><span>);</span></span>
<span class=giallo-l><span style=color:#81a1c1>  RETURN</span><span> NEW;</span></span>
<span class=giallo-l><span style=color:#81a1c1>END</span><span>;</span></span>
<span class=giallo-l><span>$$ </span><span style=color:#81a1c1>LANGUAGE</span><span> plpgsql;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>CREATE TRIGGER</span><span style=color:#88c0d0> log_inserted</span></span>
<span class=giallo-l><span style=color:#81a1c1>AFTER INSERT ON</span><span> logs</span></span>
<span class=giallo-l><span style=color:#81a1c1>FOR</span><span> EACH </span><span style=color:#81a1c1>ROW EXECUTE FUNCTION</span><span> notify_new_log</span><span style=color:#eceff4>()</span><span>;</span></span></code></pre><p>现在插入和通知<strong>要么一起成功，要么一起失败</strong>，是原子性的。<p>前端可以通过 SSE（Server-Sent Events）来订阅：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span>app</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>get</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>/logs/stream</span><span style=color:#eceff4>',</span><span style=color:#81a1c1> async</span><span style=color:#eceff4> (</span><span>req</span><span style=color:#eceff4>,</span><span> res</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> =></span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>  const</span><span> client</span><span style=color:#81a1c1> = await</span><span> pool</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>connect</span><span>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>  res</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>writeHead</span><span>(</span><span style=color:#b48ead>200</span><span style=color:#eceff4>, {</span></span>
<span class=giallo-l><span style=color:#eceff4>    '</span><span style=color:#a3be8c>Content-Type</span><span style=color:#eceff4>': '</span><span style=color:#a3be8c>text/event-stream</span><span style=color:#eceff4>',</span></span>
<span class=giallo-l><span style=color:#eceff4>    '</span><span style=color:#a3be8c>Cache-Control</span><span style=color:#eceff4>': '</span><span style=color:#a3be8c>no-cache</span><span style=color:#eceff4>',</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>  await</span><span> client</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>LISTEN logs_new</span><span style=color:#eceff4>'</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>  client</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>on</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>notification</span><span style=color:#eceff4>', (</span><span>msg</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> =></span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>    res</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>write</span><span>(</span><span style=color:#eceff4>`</span><span style=color:#a3be8c>data: </span><span style=color:#81a1c1>${</span><span>msg</span><span style=color:#eceff4>.</span><span>payload</span><span style=color:#81a1c1>}</span><span style=color:#ebcb8b>\n\n</span><span style=color:#eceff4>`</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span><span>)</span><span style=color:#81a1c1>;</span></span></code></pre><p><strong>结果：</strong> 完整的实时日志流，只依赖 PostgreSQL，不再需要 Redis。<hr><h2 id=postgresql-te-xing-san-yong-skip-locked-zuo-ren-wu-dui-lie>PostgreSQL 特性三：用 SKIP LOCKED 做任务队列</h2><p>先看 Redis（以 Bull/BullMQ 为例）：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span>queue</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>add</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>send-email</span><span style=color:#eceff4>', {</span><span> to</span><span style=color:#eceff4>,</span><span> subject</span><span style=color:#eceff4>,</span><span> body</span><span style=color:#eceff4> }</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>queue</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>process</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>send-email</span><span style=color:#eceff4>',</span><span style=color:#81a1c1> async</span><span style=color:#eceff4> (</span><span>job</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> =></span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>  await</span><span style=color:#88c0d0> sendEmail</span><span>(job</span><span style=color:#eceff4>.</span><span>data)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span><span>)</span><span style=color:#81a1c1>;</span></span></code></pre><p>在 PostgreSQL 里，我们可以这样建一张任务表：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#81a1c1>CREATE TABLE</span><span style=color:#88c0d0> jobs</span><span> (</span></span>
<span class=giallo-l><span>  id </span><span style=color:#81a1c1>BIGSERIAL PRIMARY KEY</span><span>,</span></span>
<span class=giallo-l><span style=color:#81a1c1>  queue TEXT NOT NULL</span><span>,</span></span>
<span class=giallo-l><span>  payload JSONB </span><span style=color:#81a1c1>NOT NULL</span><span>,</span></span>
<span class=giallo-l><span>  attempts </span><span style=color:#81a1c1>INT DEFAULT</span><span style=color:#b48ead> 0</span><span>,</span></span>
<span class=giallo-l><span>  max_attempts </span><span style=color:#81a1c1>INT DEFAULT</span><span style=color:#b48ead> 3</span><span>,</span></span>
<span class=giallo-l><span>  scheduled_at </span><span style=color:#81a1c1>TIMESTAMPTZ DEFAULT NOW</span><span style=color:#eceff4>()</span><span>,</span></span>
<span class=giallo-l><span>  created_at </span><span style=color:#81a1c1>TIMESTAMPTZ DEFAULT NOW</span><span style=color:#eceff4>()</span></span>
<span class=giallo-l><span>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>CREATE INDEX</span><span style=color:#88c0d0> idx_jobs_queue</span><span style=color:#81a1c1> ON</span><span> jobs(</span><span style=color:#81a1c1>queue</span><span>, scheduled_at)</span></span>
<span class=giallo-l><span style=color:#81a1c1>WHERE</span><span> attempts </span><span style=color:#81a1c1>&lt;</span><span> max_attempts;</span></span></code></pre><p>入队：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#81a1c1>INSERT INTO</span><span> jobs (</span><span style=color:#81a1c1>queue</span><span>, payload)</span></span>
<span class=giallo-l><span style=color:#81a1c1>VALUES</span><span> (</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>send-email</span><span style=color:#eceff4>'</span><span>, </span><span style=color:#eceff4>'</span><span style=color:#a3be8c>{\"to\": \"[email protected]\", \"subject\": \"Hi\"}</span><span style=color:#eceff4>'</span><span>);</span></span></code></pre><p>Worker 取任务（出队）：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#81a1c1>WITH</span><span> next_job </span><span style=color:#81a1c1>AS</span><span> (</span></span>
<span class=giallo-l><span style=color:#81a1c1>  SELECT</span><span> id </span><span style=color:#81a1c1>FROM</span><span> jobs</span></span>
<span class=giallo-l><span style=color:#81a1c1>  WHERE queue =</span><span> $</span><span style=color:#b48ead>1</span></span>
<span class=giallo-l><span style=color:#81a1c1>    AND</span><span> attempts </span><span style=color:#81a1c1>&lt;</span><span> max_attempts</span></span>
<span class=giallo-l><span style=color:#81a1c1>    AND</span><span> scheduled_at </span><span style=color:#81a1c1>&lt;= NOW</span><span style=color:#eceff4>()</span></span>
<span class=giallo-l><span style=color:#81a1c1>  ORDER BY</span><span> scheduled_at</span></span>
<span class=giallo-l><span style=color:#81a1c1>  LIMIT</span><span style=color:#b48ead> 1</span></span>
<span class=giallo-l><span style=color:#81a1c1>  FOR UPDATE SKIP</span><span> LOCKED</span></span>
<span class=giallo-l><span>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>UPDATE</span><span> jobs</span></span>
<span class=giallo-l><span style=color:#81a1c1>SET</span><span> attempts </span><span style=color:#81a1c1>=</span><span> attempts </span><span style=color:#81a1c1>+</span><span style=color:#b48ead> 1</span></span>
<span class=giallo-l><span style=color:#81a1c1>FROM</span><span> next_job</span></span>
<span class=giallo-l><span style=color:#81a1c1>WHERE</span><span> jobs.id</span><span style=color:#81a1c1> =</span><span> next_job.id</span></span>
<span class=giallo-l><span>RETURNING </span><span style=color:#81a1c1>*</span><span>;</span></span></code></pre><p>这里的关键在于：<code>FOR UPDATE SKIP LOCKED</code>。<p>它让 PostgreSQL 自然变成一个<strong>无锁队列（对使用方来说）</strong>：<ul><li>多个 worker 可以并发取任务<li>不会有同一个任务被处理两次<li>如果 worker 崩溃了，事务回滚，任务会再次变为可见</ul><p><strong>性能对比：</strong><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>Redis BRPOP: 0.1ms</span></span>
<span class=giallo-l><span>Postgres SKIP LOCKED: 0.3ms</span></span></code></pre><p>对于大多数队列型工作负载，这点差距几乎可以忽略。<hr><h2 id=postgresql-te-xing-si-xian-liu-rate-limiting>PostgreSQL 特性四：限流（Rate Limiting）</h2><p>先看经典的 Redis 实现：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#81a1c1>const</span><span> key</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> `</span><span style=color:#a3be8c>ratelimit:</span><span style=color:#81a1c1>${</span><span>userId</span><span style=color:#81a1c1>}</span><span style=color:#eceff4>`</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>const</span><span> count</span><span style=color:#81a1c1> = await</span><span> redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>incr</span><span>(key)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>if</span><span> (count</span><span style=color:#81a1c1> ===</span><span style=color:#b48ead> 1</span><span>)</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>  await</span><span> redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>expire</span><span>(key</span><span style=color:#eceff4>,</span><span style=color:#b48ead> 60</span><span>)</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 60 seconds</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>if</span><span> (count</span><span style=color:#81a1c1> ></span><span style=color:#b48ead> 100</span><span>)</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>  throw new</span><span style=color:#88c0d0> Error</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>Rate limit exceeded</span><span style=color:#eceff4>'</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>PostgreSQL 版本可以有好几种写法。<p>一种是专门建一张限流表：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#81a1c1>CREATE TABLE</span><span style=color:#88c0d0> rate_limits</span><span> (</span></span>
<span class=giallo-l><span>  user_id </span><span style=color:#81a1c1>INT PRIMARY KEY</span><span>,</span></span>
<span class=giallo-l><span>  request_count </span><span style=color:#81a1c1>INT DEFAULT</span><span style=color:#b48ead> 0</span><span>,</span></span>
<span class=giallo-l><span>  window_start </span><span style=color:#81a1c1>TIMESTAMPTZ DEFAULT NOW</span><span style=color:#eceff4>()</span></span>
<span class=giallo-l><span>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>-- Check and increment</span></span>
<span class=giallo-l><span style=color:#81a1c1>WITH</span><span> current </span><span style=color:#81a1c1>AS</span><span> (</span></span>
<span class=giallo-l><span style=color:#81a1c1>  SELECT</span></span>
<span class=giallo-l><span>    request_count,</span></span>
<span class=giallo-l><span style=color:#81a1c1>    CASE</span></span>
<span class=giallo-l><span style=color:#81a1c1>      WHEN</span><span> window_start </span><span style=color:#81a1c1>&lt; NOW</span><span style=color:#eceff4>()</span><span style=color:#81a1c1> -</span><span> INTERVAL </span><span style=color:#eceff4>'</span><span style=color:#a3be8c>1 minute</span><span style=color:#eceff4>'</span></span>
<span class=giallo-l><span style=color:#81a1c1>      THEN</span><span style=color:#b48ead> 1</span><span style=color:#616e88> -- Reset counter</span></span>
<span class=giallo-l><span style=color:#81a1c1>      ELSE</span><span> request_count </span><span style=color:#81a1c1>+</span><span style=color:#b48ead> 1</span></span>
<span class=giallo-l><span style=color:#81a1c1>    END AS</span><span> new_count</span></span>
<span class=giallo-l><span style=color:#81a1c1>  FROM</span><span> rate_limits</span></span>
<span class=giallo-l><span style=color:#81a1c1>  WHERE</span><span> user_id </span><span style=color:#81a1c1>=</span><span> $</span><span style=color:#b48ead>1</span></span>
<span class=giallo-l><span style=color:#81a1c1>  FOR UPDATE</span></span>
<span class=giallo-l><span>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>UPDATE</span><span> rate_limits</span></span>
<span class=giallo-l><span style=color:#81a1c1>SET</span></span>
<span class=giallo-l><span>  request_count </span><span style=color:#81a1c1>=</span><span> (</span><span style=color:#81a1c1>SELECT</span><span> new_count </span><span style=color:#81a1c1>FROM</span><span> current),</span></span>
<span class=giallo-l><span>  window_start </span><span style=color:#81a1c1>= CASE</span></span>
<span class=giallo-l><span style=color:#81a1c1>    WHEN</span><span> window_start </span><span style=color:#81a1c1>&lt; NOW</span><span style=color:#eceff4>()</span><span style=color:#81a1c1> -</span><span> INTERVAL </span><span style=color:#eceff4>'</span><span style=color:#a3be8c>1 minute</span><span style=color:#eceff4>'</span></span>
<span class=giallo-l><span style=color:#81a1c1>    THEN NOW</span><span style=color:#eceff4>()</span></span>
<span class=giallo-l><span style=color:#81a1c1>    ELSE</span><span> window_start</span></span>
<span class=giallo-l><span style=color:#81a1c1>  END</span></span>
<span class=giallo-l><span style=color:#81a1c1>WHERE</span><span> user_id </span><span style=color:#81a1c1>=</span><span> $</span><span style=color:#b48ead>1</span></span>
<span class=giallo-l><span>RETURNING request_count;</span></span></code></pre><p>另一种更直接的做法是记录请求明细，用窗口查询：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#81a1c1>CREATE TABLE</span><span style=color:#88c0d0> api_requests</span><span> (</span></span>
<span class=giallo-l><span>  user_id </span><span style=color:#81a1c1>INT NOT NULL</span><span>,</span></span>
<span class=giallo-l><span>  created_at </span><span style=color:#81a1c1>TIMESTAMPTZ DEFAULT NOW</span><span style=color:#eceff4>()</span></span>
<span class=giallo-l><span>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>-- Check rate limit</span></span>
<span class=giallo-l><span style=color:#81a1c1>SELECT</span><span style=color:#88c0d0> COUNT</span><span>(</span><span style=color:#81a1c1>*</span><span>) </span><span style=color:#81a1c1>FROM</span><span> api_requests</span></span>
<span class=giallo-l><span style=color:#81a1c1>WHERE</span><span> user_id </span><span style=color:#81a1c1>=</span><span> $</span><span style=color:#b48ead>1</span></span>
<span class=giallo-l><span style=color:#81a1c1>  AND</span><span> created_at </span><span style=color:#81a1c1>> NOW</span><span style=color:#eceff4>()</span><span style=color:#81a1c1> -</span><span> INTERVAL </span><span style=color:#eceff4>'</span><span style=color:#a3be8c>1 minute</span><span style=color:#eceff4>'</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>-- If under limit, insert</span></span>
<span class=giallo-l><span style=color:#81a1c1>INSERT INTO</span><span> api_requests (user_id) </span><span style=color:#81a1c1>VALUES</span><span> ($</span><span style=color:#b48ead>1</span><span>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>-- Cleanup old requests periodically</span></span>
<span class=giallo-l><span style=color:#81a1c1>DELETE FROM</span><span> api_requests </span><span style=color:#81a1c1>WHERE</span><span> created_at </span><span style=color:#81a1c1>&lt; NOW</span><span style=color:#eceff4>()</span><span style=color:#81a1c1> -</span><span> INTERVAL </span><span style=color:#eceff4>'</span><span style=color:#a3be8c>5 minutes</span><span style=color:#eceff4>'</span><span>;</span></span></code></pre><p><strong>什么时候 Postgres 的实现更有优势？</strong><ul><li>你的限流逻辑比较复杂，不只是简单计数（例如按用户+IP+路径组合）<li>希望限流检查和业务数据读写处在同一个事务里</ul><p><strong>什么时候仍然应该用 Redis？</strong><ul><li>你需要亚毫秒级的极端低延迟<li>吞吐非常大（百万级请求每秒）</ul><hr><h2 id=postgresql-te-xing-wu-yong-jsonb-cun-chu-hui-hua>PostgreSQL 特性五：用 JSONB 存储会话</h2><p>Redis 的写法通常像这样：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#81a1c1>await</span><span> redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>set</span><span>(</span><span style=color:#eceff4>`</span><span style=color:#a3be8c>session:</span><span style=color:#81a1c1>${</span><span>sessionId</span><span style=color:#81a1c1>}</span><span style=color:#eceff4>`,</span><span> JSON</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>stringify</span><span>(sessionData)</span><span style=color:#eceff4>, '</span><span style=color:#a3be8c>EX</span><span style=color:#eceff4>',</span><span style=color:#b48ead> 86400</span><span>)</span><span style=color:#81a1c1>;</span></span></code></pre><p>在 PostgreSQL 里，我们可以：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#81a1c1>CREATE TABLE</span><span style=color:#88c0d0> sessions</span><span> (</span></span>
<span class=giallo-l><span>  id </span><span style=color:#81a1c1>TEXT PRIMARY KEY</span><span>,</span></span>
<span class=giallo-l><span style=color:#81a1c1>  data</span><span> JSONB </span><span style=color:#81a1c1>NOT NULL</span><span>,</span></span>
<span class=giallo-l><span>  expires_at </span><span style=color:#81a1c1>TIMESTAMPTZ NOT NULL</span></span>
<span class=giallo-l><span>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>CREATE INDEX</span><span style=color:#88c0d0> idx_sessions_expires</span><span style=color:#81a1c1> ON sessions</span><span>(expires_at);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>-- Insert/Update</span></span>
<span class=giallo-l><span style=color:#81a1c1>INSERT INTO sessions</span><span> (id, </span><span style=color:#81a1c1>data</span><span>, expires_at)</span></span>
<span class=giallo-l><span style=color:#81a1c1>VALUES</span><span> ($</span><span style=color:#b48ead>1</span><span>, $</span><span style=color:#b48ead>2</span><span>, </span><span style=color:#81a1c1>NOW</span><span style=color:#eceff4>()</span><span style=color:#81a1c1> +</span><span> INTERVAL </span><span style=color:#eceff4>'</span><span style=color:#a3be8c>24 hours</span><span style=color:#eceff4>'</span><span>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>ON</span><span> CONFLICT (id) DO </span><span style=color:#81a1c1>UPDATE</span></span>
<span class=giallo-l><span style=color:#81a1c1>  SET data =</span><span> EXCLUDED.data,</span></span>
<span class=giallo-l><span>      expires_at </span><span style=color:#81a1c1>=</span><span> EXCLUDED.expires_at;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>-- Read</span></span>
<span class=giallo-l><span style=color:#81a1c1>SELECT data FROM sessions</span></span>
<span class=giallo-l><span style=color:#81a1c1>WHERE</span><span> id </span><span style=color:#81a1c1>=</span><span> $</span><span style=color:#b48ead>1</span><span style=color:#81a1c1> AND</span><span> expires_at </span><span style=color:#81a1c1>> NOW</span><span style=color:#eceff4>()</span><span>;</span></span></code></pre><p>因为是 JSONB，我们还可以直接在会话数据上做查询：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#616e88>-- Find all sessions for a specific user</span></span>
<span class=giallo-l><span style=color:#81a1c1>SELECT * FROM sessions</span></span>
<span class=giallo-l><span style=color:#81a1c1>WHERE data->></span><span style=color:#eceff4>'</span><span style=color:#a3be8c>userId</span><span style=color:#eceff4>'</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>123</span><span style=color:#eceff4>'</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>-- Find sessions with specific role</span></span>
<span class=giallo-l><span style=color:#81a1c1>SELECT * FROM sessions</span></span>
<span class=giallo-l><span style=color:#81a1c1>WHERE data-></span><span style=color:#eceff4>'</span><span style=color:#a3be8c>user</span><span style=color:#eceff4>'</span><span style=color:#81a1c1>->></span><span style=color:#eceff4>'</span><span style=color:#a3be8c>role</span><span style=color:#eceff4>'</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>admin</span><span style=color:#eceff4>'</span><span>;</span></span></code></pre><p>这些能力在 Redis 里是做不到的。<hr><h2 id=zhen-shi-ji-zhun-ce-shi>真实基准测试</h2><p>我在生产数据上跑了一轮基准测试，配置大致如下：<ul><li>硬件：AWS RDS db.t3.medium（2 vCPU，4GB 内存）<li>数据集：100 万条缓存记录，1 万条会话<li>工具：pgbench（自定义脚本）</ul><p>结果大概是这样：<table><thead><tr><th>操作<th>Redis<th>PostgreSQL<th>差异<tbody><tr><td>Cache SET<td>0.05ms<td>0.08ms<td>慢约 60%<tr><td>Cache GET<td>0.04ms<td>0.06ms<td>慢约 50%<tr><td>Pub/Sub<td>1.2ms<td>3.1ms<td>慢约 158%<tr><td>Queue push<td>0.08ms<td>0.15ms<td>慢约 87%<tr><td>Queue pop<td>0.12ms<td>0.31ms<td>慢约 158%</table><p>看起来 PostgreSQL 各项都更慢，但注意几个细节：<ul><li>所有操作仍然都在 1ms 以内<li>不再有到 Redis 的那一跳网络延迟<li>架构上少了一整块基础设施</ul><h3 id=zu-he-cao-zuo-cai-shi-guan-jian>组合操作才是关键</h3><p>真正有意思的是把操作组合起来看。<p><strong>场景：插入一篇帖子 + 失效缓存 + 通知订阅者</strong><p>用 Redis：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#81a1c1>await</span><span> db</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>INSERT INTO posts ...</span><span style=color:#eceff4>'</span><span>)</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 2ms</span></span>
<span class=giallo-l><span style=color:#81a1c1>await</span><span> redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>del</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>posts:latest</span><span style=color:#eceff4>'</span><span>)</span><span style=color:#81a1c1>;</span><span style=color:#616e88>        // 1ms (network hop)</span></span>
<span class=giallo-l><span style=color:#81a1c1>await</span><span> redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>publish</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>posts:new</span><span style=color:#eceff4>',</span><span> data)</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 1ms (network hop)</span></span>
<span class=giallo-l><span style=color:#616e88>// Total: ~4ms</span></span></code></pre><p>用 PostgreSQL：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#81a1c1>BEGIN</span><span>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>INSERT INTO</span><span> posts ...;                         </span><span style=color:#616e88>-- ~2ms</span></span>
<span class=giallo-l><span style=color:#81a1c1>DELETE FROM</span><span> cache </span><span style=color:#81a1c1>WHERE key =</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>posts:latest</span><span style=color:#eceff4>'</span><span>; </span><span style=color:#616e88>-- ~0.1ms（同一连接）</span></span>
<span class=giallo-l><span>NOTIFY posts_new, </span><span style=color:#eceff4>'</span><span style=color:#a3be8c>...</span><span style=color:#eceff4>'</span><span>;                      </span><span style=color:#616e88>-- ~0.1ms（同一连接）</span></span>
<span class=giallo-l><span style=color:#81a1c1>COMMIT</span><span>;</span></span>
<span class=giallo-l><span style=color:#616e88>-- Total: ~2.2ms</span></span></code></pre><p>当你把「写入 + 缓存操作 + 事件通知」这些动作<strong>放到同一个事务里</strong>时，PostgreSQL 反而整体更快，而且一致性也更好。<hr><h2 id=shen-me-shi-hou-ying-gai-bao-liu-redis>什么时候应该保留 Redis？</h2><p>虽然这篇文章在讲「用 PostgreSQL 替换 Redis」，但并不是说 Redis 一无是处，恰恰相反，<strong>Redis 在很多场景仍然是非常优秀的工具</strong>。<p>以下几种情况，我会选择继续用 Redis：<h3 id=1-ni-xu-yao-ji-zhi-xing-neng>1. 你需要极致性能</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>Redis: 100,000+ ops/sec（单实例）</span></span>
<span class=giallo-l><span>Postgres: 10,000–50,000 ops/sec</span></span></code></pre><p>如果你的业务真正在做每秒几十万甚至上百万次缓存读写，那 PostgreSQL 很难顶得住，Redis 依然是更合适的选择。<h3 id=2-ni-yi-lai-redis-te-you-de-shu-ju-jie-gou>2. 你依赖 Redis 特有的数据结构</h3><p>Redis 提供了很多很厉害的原语：<ul><li>有序集合（sorted set）做排行榜<li>HyperLogLog 做近似去重计数<li>地理空间索引<li>Streams 做更高级的流式消费 / Pub/Sub</ul><p>在 PostgreSQL 里当然也能做类似的事情，但通常会更笨重一些：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#616e88>-- Leaderboard in Postgres (slower)</span></span>
<span class=giallo-l><span style=color:#81a1c1>SELECT</span><span> user_id, score</span></span>
<span class=giallo-l><span style=color:#81a1c1>FROM</span><span> leaderboard</span></span>
<span class=giallo-l><span style=color:#81a1c1>ORDER BY</span><span> score </span><span style=color:#81a1c1>DESC</span></span>
<span class=giallo-l><span style=color:#81a1c1>LIMIT</span><span style=color:#b48ead> 10</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>-- vs Redis</span></span>
<span class=giallo-l><span>ZREVRANGE leaderboard </span><span style=color:#b48ead>0 9</span><span> WITHSCORES</span></span></code></pre><h3 id=3-jia-gou-ceng-mian-qiang-zhi-yao-qiu-du-li-huan-cun-ceng>3. 架构层面强制要求独立缓存层</h3><p>例如严格的微服务架构、或者多个语言/系统要共享同一层缓存，这时候一个独立的 Redis 集群反而更清晰。<hr><h2 id=qian-yi-ce-lue-bu-yao-yi-ye-zhi-jian-ba-redis-ba-diao>迁移策略：不要一夜之间把 Redis 拔掉</h2><p>我自己的迁移过程分成了几步。<h3 id=phase-1-shuang-xie-di-1-zhou>Phase 1：双写（第 1 周）</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#616e88>// 写入 Redis</span></span>
<span class=giallo-l><span style=color:#81a1c1>await</span><span> redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>set</span><span>(key</span><span style=color:#eceff4>,</span><span> value)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#616e88>// 同时写入 Postgres</span></span>
<span class=giallo-l><span style=color:#81a1c1>await</span><span> pg</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>INSERT INTO cache ...</span><span style=color:#eceff4>'</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>// 读请求仍然优先走 Redis</span></span>
<span class=giallo-l><span style=color:#81a1c1>let</span><span> data</span><span style=color:#81a1c1> = await</span><span> redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>get</span><span>(key)</span><span style=color:#81a1c1>;</span></span></code></pre><p>这一阶段主要是观察命中率、延迟等指标。<h3 id=phase-2-du-zou-postgres-redis-dou-di-di-2-zhou>Phase 2：读走 Postgres，Redis 兜底（第 2 周）</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#616e88>// 先查 Postgres</span></span>
<span class=giallo-l><span style=color:#81a1c1>let</span><span> data</span><span style=color:#81a1c1> = await</span><span> pg</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span></span>
<span class=giallo-l><span style=color:#eceff4>  '</span><span style=color:#a3be8c>SELECT value FROM cache WHERE key = $1</span><span style=color:#eceff4>',</span></span>
<span class=giallo-l><span>  [key]</span></span>
<span class=giallo-l><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>// 查不到再回退到 Redis</span></span>
<span class=giallo-l><span style=color:#81a1c1>if</span><span> (</span><span style=color:#81a1c1>!</span><span>data)</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>  data</span><span style=color:#81a1c1> = await</span><span> redis</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>get</span><span>(key)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>继续监控错误率和性能表现。<h3 id=phase-3-zhi-xie-postgresql-di-3-zhou>Phase 3：只写 PostgreSQL（第 3 周）</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#81a1c1>await</span><span> pg</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>INSERT INTO cache ...</span><span style=color:#eceff4>'</span><span>)</span><span style=color:#81a1c1>;</span></span></code></pre><p>此时 Redis 只作为保险存在，一旦确认没有问题，就可以进入下一步。<h3 id=phase-4-xia-xian-redis-di-4-zhou>Phase 4：下线 Redis（第 4 周）</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#616e88># 关闭 Redis 服务</span></span>
<span class=giallo-l><span style=color:#616e88># 观察日志和监控</span></span>
<span class=giallo-l><span style=color:#616e88># 如果没有错误冒出来，那基本就迁移完成了</span></span></code></pre><hr><h2 id=wan-zheng-dai-ma-shi-li>完整代码示例</h2><p>下面是文章中给出的几个完整模块示例，都是基于 PostgreSQL 的实现。<h3 id=huan-cun-mo-kuai>缓存模块</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#616e88>// cache.js</span></span>
<span class=giallo-l><span style=color:#81a1c1>class</span><span style=color:#8fbcbb> PostgresCache</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>  constructor</span><span style=color:#eceff4>(</span><span>pool</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    this</span><span style=color:#eceff4>.</span><span>pool</span><span style=color:#81a1c1> =</span><span> pool</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>  async</span><span style=color:#88c0d0> get</span><span style=color:#eceff4>(</span><span>key</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    const</span><span> result</span><span style=color:#81a1c1> = await this</span><span style=color:#eceff4>.</span><span>pool</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span></span>
<span class=giallo-l><span style=color:#eceff4>      '</span><span style=color:#a3be8c>SELECT value FROM cache WHERE key = $1 AND expires_at > NOW()</span><span style=color:#eceff4>',</span></span>
<span class=giallo-l><span>      [key]</span></span>
<span class=giallo-l><span>    )</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span> result</span><span style=color:#eceff4>.</span><span>rows[</span><span style=color:#b48ead>0</span><span>]</span><span style=color:#eceff4>?.</span><span>value</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>  async</span><span style=color:#88c0d0> set</span><span style=color:#eceff4>(</span><span>key</span><span style=color:#eceff4>,</span><span> value</span><span style=color:#eceff4>,</span><span> ttlSeconds</span><span style=color:#81a1c1> =</span><span style=color:#b48ead> 3600</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    await this</span><span style=color:#eceff4>.</span><span>pool</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span></span>
<span class=giallo-l><span style=color:#eceff4>      `</span><span style=color:#a3be8c>INSERT INTO cache (key, value, expires_at)</span></span>
<span class=giallo-l><span style=color:#a3be8c>       VALUES ($1, $2, NOW() + INTERVAL '</span><span style=color:#81a1c1>${</span><span>ttlSeconds</span><span style=color:#81a1c1>}</span><span style=color:#a3be8c> seconds')</span></span>
<span class=giallo-l><span style=color:#a3be8c>       ON CONFLICT (key) DO UPDATE</span></span>
<span class=giallo-l><span style=color:#a3be8c>         SET value = EXCLUDED.value,</span></span>
<span class=giallo-l><span style=color:#a3be8c>             expires_at = EXCLUDED.expires_at</span><span style=color:#eceff4>`,</span></span>
<span class=giallo-l><span>      [key</span><span style=color:#eceff4>,</span><span> value]</span></span>
<span class=giallo-l><span>    )</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>  async</span><span style=color:#88c0d0> delete</span><span style=color:#eceff4>(</span><span>key</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    await this</span><span style=color:#eceff4>.</span><span>pool</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>DELETE FROM cache WHERE key = $1</span><span style=color:#eceff4>',</span><span> [key])</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>  async</span><span style=color:#88c0d0> cleanup</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    await this</span><span style=color:#eceff4>.</span><span>pool</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>DELETE FROM cache WHERE expires_at &lt; NOW()</span><span style=color:#eceff4>'</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#8fbcbb>module</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>exports</span><span style=color:#81a1c1> =</span><span> PostgresCache</span><span style=color:#81a1c1>;</span></span></code></pre><h3 id=pub-sub-mo-kuai>Pub/Sub 模块</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#616e88>// pubsub.js</span></span>
<span class=giallo-l><span style=color:#81a1c1>class</span><span style=color:#8fbcbb> PostgresPubSub</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>  constructor</span><span style=color:#eceff4>(</span><span>pool</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    this</span><span style=color:#eceff4>.</span><span>pool</span><span style=color:#81a1c1> =</span><span> pool</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    this</span><span style=color:#eceff4>.</span><span>listeners</span><span style=color:#81a1c1> = new</span><span style=color:#88c0d0> Map</span><span>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>  async</span><span style=color:#88c0d0> publish</span><span style=color:#eceff4>(</span><span>channel</span><span style=color:#eceff4>,</span><span> message</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    const</span><span> payload</span><span style=color:#81a1c1> =</span><span> JSON</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>stringify</span><span>(message)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    await this</span><span style=color:#eceff4>.</span><span>pool</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>SELECT pg_notify($1, $2)</span><span style=color:#eceff4>',</span><span> [channel</span><span style=color:#eceff4>,</span><span> payload])</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>  async</span><span style=color:#88c0d0> subscribe</span><span style=color:#eceff4>(</span><span>channel</span><span style=color:#eceff4>,</span><span> callback</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    const</span><span> client</span><span style=color:#81a1c1> = await this</span><span style=color:#eceff4>.</span><span>pool</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>connect</span><span>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>    await</span><span> client</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span><span style=color:#eceff4>`</span><span style=color:#a3be8c>LISTEN </span><span style=color:#81a1c1>${</span><span>channel</span><span style=color:#81a1c1>}</span><span style=color:#eceff4>`</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    client</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>on</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>notification</span><span style=color:#eceff4>', (</span><span>msg</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> =></span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>      if</span><span> (msg</span><span style=color:#eceff4>.</span><span>channel</span><span style=color:#81a1c1> ===</span><span> channel)</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#88c0d0>        callback</span><span>(JSON</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>parse</span><span>(msg</span><span style=color:#eceff4>.</span><span>payload))</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>      }</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>    this</span><span style=color:#eceff4>.</span><span>listeners</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>set</span><span>(channel</span><span style=color:#eceff4>,</span><span> client)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>  async</span><span style=color:#88c0d0> unsubscribe</span><span style=color:#eceff4>(</span><span>channel</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    const</span><span> client</span><span style=color:#81a1c1> = this</span><span style=color:#eceff4>.</span><span>listeners</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>get</span><span>(channel)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span> (client)</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>      await</span><span> client</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span><span style=color:#eceff4>`</span><span style=color:#a3be8c>UNLISTEN </span><span style=color:#81a1c1>${</span><span>channel</span><span style=color:#81a1c1>}</span><span style=color:#eceff4>`</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>      client</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>release</span><span>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>      this</span><span style=color:#eceff4>.</span><span>listeners</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>delete</span><span>(channel)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#8fbcbb>module</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>exports</span><span style=color:#81a1c1> =</span><span> PostgresPubSub</span><span style=color:#81a1c1>;</span></span></code></pre><h3 id=ren-wu-dui-lie-mo-kuai>任务队列模块</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#616e88>// queue.js</span></span>
<span class=giallo-l><span style=color:#81a1c1>class</span><span style=color:#8fbcbb> PostgresQueue</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>  constructor</span><span style=color:#eceff4>(</span><span>pool</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    this</span><span style=color:#eceff4>.</span><span>pool</span><span style=color:#81a1c1> =</span><span> pool</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>  async</span><span style=color:#88c0d0> enqueue</span><span style=color:#eceff4>(</span><span>queue</span><span style=color:#eceff4>,</span><span> payload</span><span style=color:#eceff4>,</span><span> scheduledAt</span><span style=color:#81a1c1> = new</span><span style=color:#88c0d0> Date</span><span>()</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    await this</span><span style=color:#eceff4>.</span><span>pool</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span></span>
<span class=giallo-l><span style=color:#eceff4>      '</span><span style=color:#a3be8c>INSERT INTO jobs (queue, payload, scheduled_at) VALUES ($1, $2, $3)</span><span style=color:#eceff4>',</span></span>
<span class=giallo-l><span>      [queue</span><span style=color:#eceff4>,</span><span> payload</span><span style=color:#eceff4>,</span><span> scheduledAt]</span></span>
<span class=giallo-l><span>    )</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>  async</span><span style=color:#88c0d0> dequeue</span><span style=color:#eceff4>(</span><span>queue</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    const</span><span> result</span><span style=color:#81a1c1> = await this</span><span style=color:#eceff4>.</span><span>pool</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span></span>
<span class=giallo-l><span style=color:#eceff4>      `</span><span style=color:#a3be8c>WITH next_job AS (</span></span>
<span class=giallo-l><span style=color:#a3be8c>         SELECT id FROM jobs</span></span>
<span class=giallo-l><span style=color:#a3be8c>         WHERE queue = $1</span></span>
<span class=giallo-l><span style=color:#a3be8c>           AND attempts &lt; max_attempts</span></span>
<span class=giallo-l><span style=color:#a3be8c>           AND scheduled_at &lt;= NOW()</span></span>
<span class=giallo-l><span style=color:#a3be8c>         ORDER BY scheduled_at</span></span>
<span class=giallo-l><span style=color:#a3be8c>         LIMIT 1</span></span>
<span class=giallo-l><span style=color:#a3be8c>         FOR UPDATE SKIP LOCKED</span></span>
<span class=giallo-l><span style=color:#a3be8c>       )</span></span>
<span class=giallo-l><span style=color:#a3be8c>       UPDATE jobs</span></span>
<span class=giallo-l><span style=color:#a3be8c>       SET attempts = attempts + 1</span></span>
<span class=giallo-l><span style=color:#a3be8c>       FROM next_job</span></span>
<span class=giallo-l><span style=color:#a3be8c>       WHERE jobs.id = next_job.id</span></span>
<span class=giallo-l><span style=color:#a3be8c>       RETURNING jobs.*</span><span style=color:#eceff4>`,</span></span>
<span class=giallo-l><span>      [queue]</span></span>
<span class=giallo-l><span>    )</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span> result</span><span style=color:#eceff4>.</span><span>rows[</span><span style=color:#b48ead>0</span><span>]</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>  async</span><span style=color:#88c0d0> complete</span><span style=color:#eceff4>(</span><span>jobId</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    await this</span><span style=color:#eceff4>.</span><span>pool</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>DELETE FROM jobs WHERE id = $1</span><span style=color:#eceff4>',</span><span> [jobId])</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>  async</span><span style=color:#88c0d0> fail</span><span style=color:#eceff4>(</span><span>jobId</span><span style=color:#eceff4>,</span><span> error</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    await this</span><span style=color:#eceff4>.</span><span>pool</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>query</span><span>(</span></span>
<span class=giallo-l><span style=color:#eceff4>      `</span><span style=color:#a3be8c>UPDATE jobs</span></span>
<span class=giallo-l><span style=color:#a3be8c>       SET attempts = max_attempts,</span></span>
<span class=giallo-l><span style=color:#a3be8c>           payload = payload || jsonb_build_object('error', $2)</span></span>
<span class=giallo-l><span style=color:#a3be8c>       WHERE id = $1</span><span style=color:#eceff4>`,</span></span>
<span class=giallo-l><span>      [jobId</span><span style=color:#eceff4>,</span><span> error</span><span style=color:#eceff4>.</span><span>message]</span></span>
<span class=giallo-l><span>    )</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>  }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#8fbcbb>module</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>exports</span><span style=color:#81a1c1> =</span><span> PostgresQueue</span><span style=color:#81a1c1>;</span></span></code></pre><hr><h2 id=xing-neng-diao-you-xiao-tie-shi>性能调优小贴士</h2><p>如果你决定把 Redis 的一些职责搬到 PostgreSQL，上线前有几件事值得注意。<h3 id=1-yong-hao-lian-jie-chi>1. 用好连接池</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=javascript><span class=giallo-l><span style=color:#81a1c1>const</span><span style=color:#eceff4> {</span><span> Pool</span><span style=color:#eceff4> }</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> require</span><span>(</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>pg</span><span style=color:#eceff4>'</span><span>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>const</span><span> pool</span><span style=color:#81a1c1> = new</span><span style=color:#88c0d0> Pool</span><span>(</span><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span style=color:#88c0d0>  max</span><span style=color:#eceff4>:</span><span style=color:#b48ead> 20</span><span style=color:#eceff4>,</span><span style=color:#616e88>                 // 最大连接数</span></span>
<span class=giallo-l><span style=color:#88c0d0>  idleTimeoutMillis</span><span style=color:#eceff4>:</span><span style=color:#b48ead> 30000</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#88c0d0>  connectionTimeoutMillis</span><span style=color:#eceff4>:</span><span style=color:#b48ead> 2000</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span><span>)</span><span style=color:#81a1c1>;</span></span></code></pre><h3 id=2-jian-hao-suo-yin>2. 建好索引</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#81a1c1>CREATE INDEX</span><span style=color:#88c0d0> CONCURRENTLY</span><span> idx_cache_key </span><span style=color:#81a1c1>ON</span><span> cache(</span><span style=color:#81a1c1>key</span><span>) </span><span style=color:#81a1c1>WHERE</span><span> expires_at </span><span style=color:#81a1c1>> NOW</span><span style=color:#eceff4>()</span><span>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>CREATE INDEX</span><span style=color:#88c0d0> CONCURRENTLY</span><span> idx_jobs_pending </span><span style=color:#81a1c1>ON</span><span> jobs(</span><span style=color:#81a1c1>queue</span><span>, scheduled_at)</span></span>
<span class=giallo-l><span style=color:#81a1c1>  WHERE</span><span> attempts </span><span style=color:#81a1c1>&lt;</span><span> max_attempts;</span></span></code></pre><h3 id=3-diao-you-postgresql-pei-zhi>3. 调优 PostgreSQL 配置</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span># postgresql.conf</span></span>
<span class=giallo-l><span>shared_buffers = 2GB             # 约占内存的 25%</span></span>
<span class=giallo-l><span>effective_cache_size = 6GB       # 约占内存的 75%</span></span>
<span class=giallo-l><span>work_mem = 50MB                  # 复杂查询的工作内存</span></span>
<span class=giallo-l><span>maintenance_work_mem = 512MB     # VACUUM 等维护操作</span></span></code></pre><h3 id=4-zuo-hao-ri-chang-wei-hu>4. 做好日常维护</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=sql><span class=giallo-l><span style=color:#616e88>-- 每天跑一次</span></span>
<span class=giallo-l><span>VACUUM ANALYZE cache;</span></span>
<span class=giallo-l><span>VACUUM ANALYZE jobs;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>-- 或者细调 autovacuum（推荐）</span></span>
<span class=giallo-l><span style=color:#81a1c1>ALTER TABLE</span><span> cache </span><span style=color:#81a1c1>SET</span><span> (autovacuum_vacuum_scale_factor </span><span style=color:#81a1c1>=</span><span style=color:#b48ead> 0</span><span>.</span><span style=color:#b48ead>1</span><span>);</span></span></code></pre><hr><h2 id=san-ge-yue-zhi-hou-de-jie-guo>三个月之后的结果</h2><p>迁移完成并稳定运行了三个月之后，我大概盘点了一下收获和代价。<p><strong>得到的：</strong><ul><li>✅ 每月节省约 $100（不再使用 ElastiCache）<li>✅ 备份和恢复流程少了一整套<li>✅ 监控和告警体系变简单<li>✅ 部署链路上少了一个外部依赖</ul><p><strong>失去的：</strong><ul><li>❌ 缓存操作慢了大概 0.1–0.5ms<li>❌ Redis 那些「花哨」的数据结构（不过我本来就没用上）</ul><p>如果是我当前这个应用场景，我会不会再做一次同样的选择？<strong>会。</strong><p>但我会不会对所有团队都说「赶紧把 Redis 换掉」？<strong>不会。</strong><hr><h2 id=jue-ce-xiao-chao>决策小抄</h2><p>可以把这篇文章最后浓缩成一个小小的决策矩阵。<p><strong>适合考虑用 PostgreSQL 替换 Redis 的情况：</strong><ul><li>✅ 你只把 Redis 用在简单缓存 / 会话存储上<li>✅ 缓存命中率一般，没有到 99% 这种极端情况<li>✅ 你很看重数据的一致性，希望一切都在事务里完成<li>✅ 接受操作慢 0.1–1ms 但换来更简单的运维<li>✅ 团队规模不大，没有专职的 SRE / DBRE 团队</ul><p><strong>更应该保留 Redis 的情况：</strong><ul><li>❌ 你需要每秒 10 万级甚至更高的操作数<li>❌ 依赖 Redis 的有序集合、HyperLogLog 等高级数据结构<li>❌ 有专门的运维团队负责 Redis 集群<li>❌ 亚毫秒级延迟是业务刚性指标<li>❌ 做多地域部署，需要 Redis 的一些特性来配合</ul><hr><h2 id=can-kao-zi-liao>参考资料</h2><p>如果你想进一步深入，可以直接查看 PostgreSQL 官方文档和一些社区工具：<ul><li>LISTEN/NOTIFY 官方文档：<a href=https://www.postgresql.org/docs/current/sql-notify.html rel=external>https://www.postgresql.org/docs/current/sql-notify.html</a><li><code>SKIP LOCKED</code>：<a href=https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE rel=external>https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE</a><li>UNLOGGED 表：<a href=https://www.postgresql.org/docs/current/sql-createtable.html rel=external>https://www.postgresql.org/docs/current/sql-createtable.html</a></ul><p><strong>工具：</strong><ul><li>pgBouncer：连接池工具，适合高并发场景<li><code>pg_stat_statements</code>：分析慢查询和热点 SQL</ul><p><strong>基于 PostgreSQL 的替代方案：</strong><ul><li>Graphile Worker：基于 Postgres 的任务队列<li>pg-boss：另一个成熟的 Postgres 队列实现</ul><hr><h2 id=tl-dr>TL;DR</h2><p>这篇文章的核心其实可以用几句话概括：<ul><li>用 <strong>UNLOGGED 表</strong> 替代 Redis 缓存<li>用 <strong>LISTEN/NOTIFY</strong> 替代 Redis Pub/Sub<li>用 <strong><code>FOR UPDATE SKIP LOCKED</code></strong> 实现任务队列<li>用 <strong>JSONB 表</strong> 存储会话</ul><p><strong>结果：</strong><ul><li>基础设施更少、部署和运维更简单<li>所有东西都在 PostgreSQL 一处，事务一致性天然有保障<li>单次操作确实慢了一点点（0.1–1ms），但整体延迟往往更低</ul><p>如果你的系统已经在用 PostgreSQL，而 Redis 只承担缓存、Pub/Sub 或轻量队列这类职责，那么非常值得认真评估：<strong>是否真的需要再多养一套 Redis 基础设施？</strong> 在很多场景下，PostgreSQL 这套「一站式方案」已经足够好，并且会让你的系统在一致性、可观测性和可维护性上都更容易掌控。</div></div></section>