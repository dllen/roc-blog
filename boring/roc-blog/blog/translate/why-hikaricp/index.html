<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>HikariCP: Down the Rabbit Hole | ç å†œçš„è‡ªç•™åœ°</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/translate/> /translate </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2023-12-18</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">HikariCP: Down the Rabbit Hole</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p><a href=https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole rel=external>åŸæ–‡è¿æ¥</a><blockquote><p>Simplicity is prerequisite for reliability.<p>Perfection is Achieved Not When There Is Nothing More to Add, But When There Is Nothing Left to Take Away.</blockquote><blockquote><p>æœ¬æ–‡åªæ˜¯åšä¸€ä¸‹ç®€å•çš„ç¿»è¯‘å’Œè®²è§£ï¼›</blockquote><p>This is where we give away the recipe to the secret sauce. When you come in with benchmarks like ours there is a certain amount of skepticism that must be addressed. If you think of performance, and of connection pools, you might be tempted into thinking that theÂ <em>pool</em>Â is the most important part of the performance equation. Not so clearly so. The number ofÂ <code>getConnection()</code>Â operations in comparison to other JDBC operations is small. A large amount of performance gains come in the optimization of the â€œdelegatesâ€ that wrapÂ <code>Connection</code>,Â <code>Statement</code>, etc.<p>æœ¬æ–‡è®²è§£ä¸€ä¸‹è¯¥é¡¹ç›®çš„åº•å±‚å®ç°åŸç†ã€‚å½“ä½ çœ‹åˆ°è¯¥é¡¹ç›®çš„åŸºå‡†æµ‹è¯•ç»“æœï¼Œå¦‚æœä½ å¿ƒä¸­æœ‰ç–‘è™‘ï¼Œæˆ‘ä»¬å¿…é¡»ç»™ä½ è§£é‡Šæ¸…æ¥šã€‚å¦‚æœè€ƒè™‘åˆ°æ€§èƒ½å’Œè¿æ¥æ± ï¼Œä½ å¯èƒ½ä¼šè®¤ä¸ºè¿æ¥æ± æ˜¯æ€§èƒ½ä¸­æœ€é‡è¦çš„å½±å“å› ç´ ã€‚ä½†æ˜¯å¹¶ä¸æ˜¯å¦‚æ­¤ã€‚ä¸å…¶ä»–JDBCæ“ä½œç›¸æ¯”ï¼Œ<code>getConnection()</code>æ“ä½œçš„æ•°é‡éå¸¸å°‘ã€‚å¤§é‡çš„æ€§èƒ½ä¼˜åŒ–æ˜¯åœ¨å¯¹<p><code>Connection</code>ã€<code>Statement</code> ç­‰çš„åŒ…è£…å’Œå§”æ‰˜ã€‚<h3 id=brain-we-re-in-your-bytecodez>ğŸ§  Weâ€™re in your bytecodez</h3><p>In order to make HikariCP as fast as it is, we went down to bytecode-level engineering, and beyond. We pulled out every trick we know to help the JIT help you. We studied the bytecode output of the compiler, and even the assembly output of the JIT to limit key routines to less than the JIT inline-threshold. We flattened inheritance hierarchies, shadowed member variables, eliminated casts.<p>ä¸ºäº†ä½¿ HikariCP å°½å¯èƒ½å¿«ï¼Œæˆ‘ä»¬æ·±å…¥ç ”ç©¶äº†å­—èŠ‚ç çº§å·¥ç¨‹ï¼Œä»¥åŠæ›´å¤šå†…å®¹ã€‚æˆ‘ä»¬ä½¿å‡ºæµ‘èº«è§£æ•°æ¥å¸®åŠ© JIT å¸®åŠ©ä½ ã€‚æˆ‘ä»¬ç ”ç©¶äº†ç¼–è¯‘å™¨çš„å­—èŠ‚ç è¾“å‡ºï¼Œç”šè‡³JITçš„æ±‡ç¼–è¾“å‡ºï¼Œä»¥å°†å…³é”®ä¾‹ç¨‹é™åˆ¶åœ¨å°äºJITå†…è”é˜ˆå€¼çš„èŒƒå›´å†…ã€‚æˆ‘ä»¬å¹³åŒ–äº†ç»§æ‰¿å±‚æ¬¡ç»“æ„ï¼Œéšè—äº†æˆå‘˜å˜é‡ï¼Œæ¶ˆé™¤äº†å¼ºåˆ¶ç±»å‹è½¬æ¢ã€‚<h3 id=microscope-micro-optimizations>ğŸ”¬ Micro-optimizations</h3><p>HikariCP contains many micro-optimizations that individually are barely measurable, but together combine as a boost to overall performance. Some of these optimizations are measured in fractions of a millisecond amortized over millions of invocations.<p>HikariCP åŒ…å«è®¸å¤šå¾®è§‚ä¼˜åŒ–ï¼Œè¿™äº›ä¼˜åŒ–å•ç‹¬æ¥è¯´å‡ ä¹æ— æ³•è¡¡é‡ï¼Œä½†æ˜¯ç»“åˆåœ¨ä¸€èµ·å¯ä»¥æé«˜æ•´ä½“æ€§èƒ½ã€‚å…¶ä¸­ä¸€äº›ä¼˜åŒ–æ˜¯ä»¥æ¯«ç§’çº§çš„ï¼Œåªæœ‰åœ¨æ•°ç™¾ä¸‡æ¬¡è°ƒç”¨ä¸­æ‰èƒ½ä½“ç°ä¼˜åŒ–ç»“æœã€‚<h4 id=arraylist>ArrayList</h4><p>One non-trivial (performance-wise) optimization was eliminating the use of anÂ <code>ArrayList&lt;Statement></code>Â instance in theÂ <code>ConnectionProxy</code>Â used to track openÂ <code>Statement</code>Â instances. When aÂ <code>Statement</code>Â is closed, it must be removed from this collection, and when theÂ <code>Connection</code>Â is closed it must iterate the collection and close any openÂ <code>Statement</code>Â instances, and finally must clear the collection. The JavaÂ <code>ArrayList</code>, wisely for general purpose use, performs aÂ <em>range check</em>Â upon everyÂ <code>get(int index)</code>Â call. However, because we can provide guarantees about our ranges, this check is merely overhead.<p>ä¸€ä¸ªé‡è¦çš„(æ€§èƒ½æ–¹é¢çš„)ä¼˜åŒ–æ˜¯åœ¨ <code>ConnectionProxy</code> ä¸­å–æ¶ˆä½¿ç”¨ <code>ArrayList</code> å®ä¾‹æ¥è·Ÿè¸ª open <code>Statement</code> å®ä¾‹ã€‚<code>Statement</code>å…³é—­æ—¶ï¼Œå¿…é¡»ä»é›†åˆä¸­åˆ é™¤è¯¥<code>Statement</code>ï¼Œå…³é—­ <code>Connection</code> æ—¶ï¼Œå¿…é¡»è¿­ä»£è¯¥é›†åˆå¹¶å…³é—­ä»»ä½•æ‰“å¼€çš„ <code>Statement</code> å®ä¾‹ï¼Œæœ€åå¿…é¡»æ¸…ç†é›†åˆã€‚Java <code>ArrayList</code> ä¸ºäº†é€‚ç”¨äºå¤§å¤šæ•°åœºæ™¯ï¼Œå¯¹æ¯ä¸ª <code>get(int index)</code> è°ƒç”¨è¿›è¡Œç´¢å¼•æ£€æŸ¥ã€‚ä½†æ˜¯ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥æä¾›å¯¹ç´¢å¼•çš„èŒƒå›´çš„ä¿è¯ï¼Œæ‰€ä»¥è¿™ä¸ªæ£€æŸ¥åªæ˜¯å¼€é”€ã€‚<p>Additionally, theÂ <code>remove(Object)</code>Â implementation performs a scan from head to tail, however common patterns in JDBC programming are to closeÂ <em>Statements</em>Â immediately after use, or in reverse order of opening. For these cases, a scan that starts at the tail will perform better. Therefore,Â <code>ArrayList&lt;Statement></code>Â was replaced with a custom classÂ <code>FastList</code>Â which eliminates range checking and performs removal scans from tail to head.<p>æ­¤å¤–ï¼Œ<code>remove(Object)</code> ä¼šä»å¤´åˆ°å°¾çš„æ‰«æåˆ—è¡¨å…ƒç´ ï¼Œä½†æ˜¯ JDBC ç¼–ç¨‹ä¸­çš„å¸¸è§æ¨¡å¼æ˜¯åœ¨ä½¿ç”¨è¯­å¥åç«‹å³å…³é—­ <em>Statements</em>ï¼Œæˆ–è€…ä»¥ç›¸åçš„æ‰“å¼€é¡ºåºå…³é—­<em>Statements</em>ã€‚å¯¹äºè¿™äº›æƒ…å†µï¼Œä»å°¾éƒ¨å¼€å§‹çš„æ‰«æå°†æ‰§è¡Œå¾—æ›´å¥½ã€‚å› æ­¤ï¼Œ<code>ArrayList&lt;Statement></code> è¢«æ›¿æ¢ä¸ºä¸€ä¸ªè‡ªå®šä¹‰ç±» <code>FastList</code>ï¼Œå®ƒæ¶ˆé™¤äº†èŒƒå›´æ£€æŸ¥å¹¶æ‰§è¡Œä»å°¾éƒ¨åˆ°å¤´éƒ¨çš„åˆ é™¤æ‰«æã€‚<h4 id=concurrentbag>ConcurrentBag</h4><p>HikariCP contains a custom lock-free collection called aÂ <em>ConcurrentBag</em>. The idea was borrowed from the C# .NET ConcurrentBag class, but the internal implementation quite different. TheÂ <em>ConcurrentBag</em>Â providesâ€¦<p>HikariCP åŒ…å«ä¸€ä¸ªç§°ä¸º <code>ConcurrentBag</code> çš„è‡ªå®šä¹‰æ— é”é›†åˆã€‚è¿™ä¸ªæƒ³æ³•æ˜¯ä» C# ä¸­å€Ÿç”¨çš„ã€‚NET ConcurrentBag ç±»ï¼Œä½†å†…éƒ¨å®ç°æœ‰å¾ˆå¤§çš„ä¸åŒã€‚ConcurrentBag æ”¯æŒä»¥ä¸‹ç‰¹æ€§ï¼š<ul><li>A lock-free design <em>æ— é”è®¾è®¡</em><li>ThreadLocal caching <em>ThreadLocalç¼“å­˜</em><li>Queue-stealing <em>é˜Ÿåˆ—çªƒå–</em><li>Direct hand-off optimizations <em>ç›´æ¥åˆ‡æ¢ä¼˜åŒ–</em></ul><p>â€¦resulting in a high degree of concurrency, extremely low latency, and minimized occurrences ofÂ <a href=http://en.wikipedia.org/wiki/False_sharing rel=external>false-sharing</a><p>æ”¯æŒé«˜åº¦çš„å¹¶å‘æ€§ï¼Œæä½çš„å»¶è¿Ÿï¼Œæœ€å°åŒ–äº† <a href=https://en.wikipedia.org/wiki/False_sharing rel=external>False sharing</a> çš„å‘ç”Ÿã€‚<p><img alt src=https://scp-net-cn.oss-cn-beijing.aliyuncs.com/blog-images/v2-a9557dcd20f2d034d8f2a28c643e7974_b.jpg><blockquote><p>ä¸Šå›¾ä¸­<code>thread0</code>ä½äº<code>core0</code>ï¼Œè€Œ<code>thread1</code>ä½äº<code>core1</code>ï¼ŒäºŒè€…å‡æƒ³æ›´æ–°å½¼æ­¤ç‹¬ç«‹çš„ä¸¤ä¸ªå˜é‡ï¼Œä½†æ˜¯ç”±äºä¸¤ä¸ªå˜é‡ä½äºåŒä¸€ä¸ª<code>cache line</code>ä¸­ï¼Œæ­¤æ—¶å¯çŸ¥çš„æ˜¯ä¸¤ä¸ª<code>cache line</code>çš„çŠ¶æ€åº”è¯¥éƒ½æ˜¯<code>Shared</code>ï¼Œè€Œå¯¹äº<code>cache line</code>çš„æ“ä½œ<code>core</code>é—´å¿…é¡»äº‰å¤ºä¸»å¯¼æƒ<code>ï¼ˆownershipï¼‰</code>ï¼Œå¦‚æœ<code>core0</code>æŠ¢åˆ°äº†ï¼Œ<code>thread0</code>å› æ­¤å»æ›´æ–°<code>cache line</code>ï¼Œä¼šå¯¼è‡´<code>core1</code>ä¸­çš„<code>cache line</code>çŠ¶æ€å˜ä¸º<code>Invalid</code>ï¼Œéšå<code>thread1</code>å»æ›´æ–°æ—¶å¿…é¡»é€šçŸ¥<code>core0</code>å°†<code>cache line</code>åˆ·å›ä¸»å­˜ï¼Œç„¶åå®ƒå†ä»ä¸»ä»ä¸­<code>load</code>è¯¥<code>cache line</code>è¿›é«˜é€Ÿç¼“å­˜ä¹‹åå†è¿›è¡Œä¿®æ”¹ï¼Œä½†ä»¤äººæŠ“ç‹‚çš„æ˜¯ï¼Œè¯¥ä¿®æ”¹åˆä¼šä½¿å¾—<code>core0</code>çš„<code>cache line</code>å¤±æ•ˆï¼Œé‡å¤ä¸Šæ¼”å†å²ï¼Œä»è€Œé«˜é€Ÿç¼“å­˜å¹¶æœªèµ·åˆ°åº”æœ‰çš„ä½œç”¨ï¼Œåè€Œå½±å“äº†æ€§èƒ½ã€‚</blockquote><h4 id=invocation-invokevirtual-vs-invokestatic>Invocation:Â <code>invokevirtual</code>Â vsÂ <code>invokestatic</code></h4><p>In order to generate proxies forÂ <em>Connection</em>,Â <em>Statement</em>, andÂ <em>ResultSet</em>Â instances HikariCP was initially using a singleton factory, held in the case ofÂ <code>ConnectionProxy</code>Â in aÂ <em>static</em>Â field (<em>PROXY_FACTORY</em>).<p>ä¸ºäº†ç»™ <code>Connection</code>ï¼Œ<code>Statement</code> å’Œ <code>ResultSet</code> å®ä¾‹ç”Ÿæˆä»£ç†ï¼ŒHikariCP æœ€åˆä½¿ç”¨äº†ä¸€ä¸ªå•ä¾‹å·¥å‚ï¼Œä¾‹å¦‚ <code>ConnectionProxy</code> ï¼Œä¿å­˜åœ¨ä¸€ä¸ªé™æ€å­—æ®µ(<em>PROXY_FACTORY</em>)ä¸­ã€‚<p>There was a dozen or so methods resembling the following:<p>æœ‰åå‡ ç§ç±»ä¼¼çš„æ–¹æ³•:<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>public final</span><span style=color:#8fbcbb> PreparedStatement</span><span style=color:#88c0d0> prepareStatement</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>String</span><span> sql</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> String</span><span style=color:#eceff4>[]</span><span> columnNames</span><span style=color:#eceff4>)</span><span> throws </span><span style=color:#8fbcbb>SQLException</span></span>
<span class=giallo-l><span style=color:#eceff4>{</span><span>    </span></span>
<span class=giallo-l><span style=color:#81a1c1>Â Â Â Â return</span><span> PROXY_FACTORY</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>getProxyPreparedStatement</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>this</span><span style=color:#eceff4>,</span><span> delegate</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>prepareStatement</span><span style=color:#eceff4>(</span><span>sql</span><span style=color:#eceff4>,</span><span> columnNames</span><span style=color:#eceff4>))</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>Using the original singleton factory, the generated bytecode looked like this:<p>ä½¿ç”¨æœ€åˆçš„å•ä¾‹å·¥å‚ï¼Œç”Ÿæˆçš„å­—èŠ‚ç å¦‚ä¸‹æ‰€ç¤ºï¼š<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>    public final</span><span> java</span><span style=color:#eceff4>.</span><span>sql</span><span style=color:#eceff4>.</span><span>PreparedStatement</span><span style=color:#88c0d0> prepareStatement</span><span style=color:#eceff4>(</span><span>java</span><span style=color:#eceff4>.</span><span>lang</span><span style=color:#eceff4>.</span><span>String</span><span style=color:#eceff4>,</span><span> java</span><span style=color:#eceff4>.</span><span>lang</span><span style=color:#eceff4>.</span><span>String</span><span style=color:#eceff4>[])</span><span> throws java</span><span style=color:#eceff4>.</span><span>sql</span><span style=color:#eceff4>.</span><span>SQLException</span><span style=color:#81a1c1>;</span><span>    </span></span>
<span class=giallo-l><span>    flags</span><span style=color:#81a1c1>:</span><span> ACC_PRIVATE</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> ACC_FINAL</span></span>
<span class=giallo-l><span>    Code</span><span style=color:#81a1c1>:</span><span>      </span></span>
<span class=giallo-l><span>    stack</span><span style=color:#81a1c1>=</span><span style=color:#b48ead>5</span><span style=color:#eceff4>,</span><span> locals</span><span style=color:#81a1c1>=</span><span style=color:#b48ead>3</span><span style=color:#eceff4>,</span><span> args_size</span><span style=color:#81a1c1>=</span><span style=color:#b48ead>3</span></span>
<span class=giallo-l><span style=color:#b48ead>         0</span><span style=color:#81a1c1>:</span><span> getstatic     #</span><span style=color:#b48ead>59</span><span style=color:#616e88>                 // Field PROXY_FACTORY:Lcom/zaxxer/hikari/proxy/ProxyFactory;</span></span>
<span class=giallo-l><span style=color:#b48ead>         3</span><span style=color:#81a1c1>:</span><span> aload_0</span></span>
<span class=giallo-l><span style=color:#b48ead>         4</span><span style=color:#81a1c1>:</span><span> aload_0</span></span>
<span class=giallo-l><span style=color:#b48ead>         5</span><span style=color:#81a1c1>:</span><span> getfield      #</span><span style=color:#b48ead>3</span><span style=color:#616e88>                  // Field delegate:Ljava/sql/Connection;</span></span>
<span class=giallo-l><span style=color:#b48ead>         8</span><span style=color:#81a1c1>:</span><span> aload_1</span></span>
<span class=giallo-l><span style=color:#b48ead>         9</span><span style=color:#81a1c1>:</span><span> aload_2</span></span>
<span class=giallo-l><span style=color:#b48ead>        10</span><span style=color:#81a1c1>:</span><span> invokeinterface #</span><span style=color:#b48ead>74</span><span style=color:#eceff4>,</span><span style=color:#b48ead>  3</span><span style=color:#616e88>           // InterfaceMethod java/sql/Connection.prepareStatement:(Ljava/lang/String;[Ljava/lang/String;)Ljava/sql/PreparedStatement;</span></span>
<span class=giallo-l><span style=color:#b48ead>        15</span><span style=color:#81a1c1>:</span><span> invokevirtual #</span><span style=color:#b48ead>69</span><span style=color:#616e88>                 // Method com/zaxxer/hikari/proxy/ProxyFactory.getProxyPreparedStatement:(Lcom/zaxxer/hikari/proxy/ConnectionProxy;Ljava/sql/PreparedStatement;)Ljava/sql/PreparedStatement;</span></span>
<span class=giallo-l><span style=color:#b48ead>        18</span><span style=color:#81a1c1>: return</span></span></code></pre><p>You can see that first there is aÂ <code>getstatic</code>Â call to get the value of the static fieldÂ <code>PROXY_FACTORY</code>, as well as (lastly) theÂ <code>invokevirtual</code>Â call toÂ <code>getProxyPreparedStatement()</code>Â on theÂ <code>ProxyFactory</code>Â instance.<p>å¯ä»¥çœ‹åˆ°ï¼Œé¦–å…ˆæœ‰ä¸€ä¸ª <code>getstatic</code> çš„è°ƒç”¨è·å–é™æ€å­—æ®µ <code>PROXY_FACTORY</code> çš„å€¼ï¼Œä»¥åŠï¼ˆæœ€åï¼‰åœ¨ <code>ProxyFactory</code> å®ä¾‹ä¸Š <code>invokevirtual</code> è°ƒç”¨æŒ‡å‘ <code>getProxyPreparedStatement()</code>ã€‚<p>We eliminated the singleton factory (which was generated by Javassist) and replaced it with a final class havingÂ <code>static</code>Â methods (whoseÂ <em>bodies</em>Â are generated by Javassist). The Java code became:<p>æˆ‘ä»¬æ¶ˆé™¤äº†å•ä¾‹å·¥å‚(ç”± Javassist ç±»åº“ç”Ÿæˆ) ï¼Œæ›¿æ¢æœ€åä¸€ä¸ªæœ‰<code>static</code>æ–¹æ³•çš„<code>final</code>ç±» (æ–¹æ³•ä½“ç”±Javassistç”Ÿæˆ)ã€‚<p>Java ä»£ç å˜æˆ:<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>public final</span><span style=color:#8fbcbb> PreparedStatement</span><span style=color:#88c0d0> prepareStatement</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>String</span><span> sql</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> String</span><span style=color:#eceff4>[]</span><span> columnNames</span><span style=color:#eceff4>)</span><span> throws </span><span style=color:#8fbcbb>SQLException</span></span>
<span class=giallo-l><span style=color:#eceff4>{</span><span>       </span></span>
<span class=giallo-l><span style=color:#81a1c1>     return</span><span> ProxyFactory</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>getProxyPreparedStatement</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>this</span><span style=color:#eceff4>,</span><span> delegate</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>prepareStatement</span><span style=color:#eceff4>(</span><span>sql</span><span style=color:#eceff4>,</span><span> columnNames</span><span style=color:#eceff4>))</span><span style=color:#81a1c1>;</span><span>   </span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>WhereÂ <code>getProxyPreparedStatement()</code>Â is aÂ <code>static</code>Â method defined in theÂ <code>ProxyFactory</code>Â class. The resulting bytecode is:<p>å…¶ä¸­ <code>getProxyPreparedStatement()</code> æ˜¯åœ¨ <code>ProxyFactory</code> ç±»ä¸­å®šä¹‰çš„é™æ€æ–¹æ³•:<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>    private final</span><span> java</span><span style=color:#eceff4>.</span><span>sql</span><span style=color:#eceff4>.</span><span>PreparedStatement</span><span style=color:#88c0d0> prepareStatement</span><span style=color:#eceff4>(</span><span>java</span><span style=color:#eceff4>.</span><span>lang</span><span style=color:#eceff4>.</span><span>String</span><span style=color:#eceff4>,</span><span> java</span><span style=color:#eceff4>.</span><span>lang</span><span style=color:#eceff4>.</span><span>String</span><span style=color:#eceff4>[])</span><span> throws java</span><span style=color:#eceff4>.</span><span>sql</span><span style=color:#eceff4>.</span><span>SQLException</span><span style=color:#81a1c1>;</span><span>    </span></span>
<span class=giallo-l><span>    flags</span><span style=color:#81a1c1>:</span><span> ACC_PRIVATE</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> ACC_FINAL</span></span>
<span class=giallo-l><span>    Code</span><span style=color:#81a1c1>:</span><span>      </span></span>
<span class=giallo-l><span>    stack</span><span style=color:#81a1c1>=</span><span style=color:#b48ead>4</span><span style=color:#eceff4>,</span><span> locals</span><span style=color:#81a1c1>=</span><span style=color:#b48ead>3</span><span style=color:#eceff4>,</span><span> args_size</span><span style=color:#81a1c1>=</span><span style=color:#b48ead>3</span></span>
<span class=giallo-l><span style=color:#b48ead>         0</span><span style=color:#81a1c1>:</span><span> aload_0</span></span>
<span class=giallo-l><span style=color:#b48ead>         1</span><span style=color:#81a1c1>:</span><span> aload_0</span></span>
<span class=giallo-l><span style=color:#b48ead>         2</span><span style=color:#81a1c1>:</span><span> getfield      #</span><span style=color:#b48ead>3</span><span style=color:#616e88>                  // Field delegate:Ljava/sql/Connection;</span></span>
<span class=giallo-l><span style=color:#b48ead>         5</span><span style=color:#81a1c1>:</span><span> aload_1</span></span>
<span class=giallo-l><span style=color:#b48ead>         6</span><span style=color:#81a1c1>:</span><span> aload_2</span></span>
<span class=giallo-l><span style=color:#b48ead>         7</span><span style=color:#81a1c1>:</span><span> invokeinterface #</span><span style=color:#b48ead>72</span><span style=color:#eceff4>,</span><span style=color:#b48ead>  3</span><span style=color:#616e88>           // InterfaceMethod java/sql/Connection.prepareStatement:(Ljava/lang/String;[Ljava/lang/String;)Ljava/sql/PreparedStatement;</span></span>
<span class=giallo-l><span style=color:#b48ead>        12</span><span style=color:#81a1c1>:</span><span> invokestatic  #</span><span style=color:#b48ead>67</span><span style=color:#616e88>                 // Method com/zaxxer/hikari/proxy/ProxyFactory.getProxyPreparedStatement:(Lcom/zaxxer/hikari/proxy/ConnectionProxy;Ljava/sql/PreparedStatement;)Ljava/sql/PreparedStatement;</span></span>
<span class=giallo-l><span style=color:#b48ead>        15</span><span style=color:#81a1c1>:</span><span> areturn</span></span></code></pre><p>There are three things of note here:<p>è¿™é‡Œæœ‰ä¸‰ä»¶å€¼å¾—æ³¨æ„çš„äº‹æƒ…:<ul><li>TheÂ <code>getstatic</code>Â call is gone. * <ul><li>æ²¡æœ‰<code>getstatic</code> è°ƒç”¨äº†*</ul><li>TheÂ <code>invokevirtual</code>Â call is replaced with aÂ <code>invokestatic</code>Â call that is more easily optimized by the JVM. <ul><li><code>invokevirtual</code> è°ƒç”¨è¢«æ›¿æ¢ä¸º <code>invokestatic</code> è°ƒç”¨ï¼Œ<code>invokestatic</code> å®¹æ˜“è¢«JVMä¼˜åŒ–ã€‚</ul><li>Lastly, possibly not noticed at first glance is that the stack size is reduced from 5 elements to 4 elements. This is because in the case ofÂ <code>invokevirtual</code>Â there is an implicit passing of the instance of ProxyFactory on the stack (i.eÂ <code>this</code>), and there is an additional (unseen)Â <em>pop</em>Â of that value from the stack whenÂ <code>getProxyPreparedStatement()</code>Â was called. <ul><li>æœ€åï¼Œä¸€å¼€å§‹å¯èƒ½æ²¡æœ‰æ³¨æ„åˆ°çš„æ˜¯å †æ ˆå¤§å°ä»5ä¸ªå…ƒç´ å‡å°‘åˆ°4ä¸ªå…ƒç´ ã€‚è¿™æ˜¯å› ä¸ºåœ¨ <code>invokevirtal</code> çš„æƒ…å†µä¸‹ï¼Œåœ¨å †æ ˆä¸Šéšå¼ä¼ é€’äº† <code>ProxyFactory</code> çš„å®ä¾‹(å³ <code>This</code>) ï¼Œå¹¶ä¸”åœ¨è°ƒç”¨ <code>getProxyPreparedStatement()</code> æ—¶ï¼Œä»å †æ ˆä¸­æœ‰ä¸€ä¸ªé¢å¤–çš„(ä¸å¯è§çš„)å¼¹å‡ºå€¼ã€‚</ul></ul><p>In all, this change removed a static field access, a push and pop from the stack, and made the invocation easier for the JIT to optimize because theÂ <em>callsite</em>Â is guaranteed not to change.<p>æ€»ä¹‹ï¼Œè¿™ä¸ªæ›´æ”¹åˆ é™¤äº†é™æ€å­—æ®µè®¿é—®ã€æ ˆä¸­çš„æ¨é€å’Œå¼¹å‡ºæ“ä½œï¼Œå¹¶ä½¿ JIT æ›´å®¹æ˜“ä¼˜åŒ–è°ƒç”¨ï¼Œå› ä¸ºå‡å°‘äº†éšå¼è½¬æ¢ã€‚<blockquote><p>invokevirtal ä¸å®¹æ˜“å†…è”</blockquote><hr><h3 id=tu-yeah-but-still><code>Â¯\_(ãƒ„)_/Â¯</code>Â Yeah, but stillâ€¦</h3><p>In our benchmark, we are obviously running against a stub JDBC driver implementation, so the JIT is doing a lot of inlining. However, the same inlining at the stub-level is occurring for other pools in the benchmark. So, no inherent advantage to us.<p>æˆ‘ä»¬çš„åŸºå‡†æµ‹è¯•ï¼Œä½¿ç”¨ stub JDBC é©±åŠ¨ï¼ŒJIT ä¼šåšå¤§é‡çš„å†…è”ä¼˜åŒ–ã€‚åŒæ ·ï¼Œä½¿ç”¨å…¶ä»–è¿æ¥æ± åšåŸºå‡†æµ‹è¯•æ—¶ JIT äº§ç”ŸåŒæ ·çš„ä¼˜åŒ–ï¼Œæ‰€ä»¥ï¼Œå¯¹æˆ‘ä»¬æ¥è¯´æ²¡æœ‰å…ˆå¤©ä¼˜åŠ¿ã€‚<p>But inlining is certainly a big part of the equation even when real drivers are in use, which brings us to another topicâ€¦<p>ä½†æ˜¯ï¼Œå³ä½¿åœ¨ä½¿ç”¨çœŸæ­£çš„é©±åŠ¨ç¨‹åºæ—¶ï¼Œå†…è”ä¹Ÿè‚¯å®šæ˜¯å¾ˆå¤§ä¸€éƒ¨åˆ†å› ç´ ï¼Œè¿™å°±æŠŠæˆ‘ä»¬å¸¦åˆ°äº†å¦ä¸€ä¸ªè¯é¢˜â€¦<p>å‚è€ƒï¼š<a href=https://github.com/brettwooldridge/HikariCP/issues/1198 rel=external>whatâ€˜s the purpose to generate HikariProxyConnection by javaassist since you already write ProxyConnection ?</a><blockquote><p>The proxies delegate to the real driver classes. Some proxies, like the one for ResultSet, only intercept a few methods. Without the code generation, the proxy would have to implement all 50+ methods which simply delegate to the wrapped instance.<p>Code generation, based on reflection, also means that nothing needs to be done when a new JDK version introduces new JDBC methods to existing interfaces.<p>ä»£ç†å§”æ‰˜ç»™çœŸæ­£çš„é©±åŠ¨ç±»ã€‚æœ‰äº›ä»£ç†ï¼Œæ¯”å¦‚ResultSetçš„ä»£ç†ï¼Œåªæˆªå–å‡ ä¸ªæ–¹æ³•ã€‚å¦‚æœæ²¡æœ‰ä»£ç ç”Ÿæˆï¼Œä»£ç†å°†ä¸å¾—ä¸å®ç°æ‰€æœ‰50å¤šä¸ªæ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•åªæ˜¯å§”æ‰˜ç»™åŒ…è£…çš„å®ä¾‹ã€‚<p>åŸºäºåå°„çš„ä»£ç ç”Ÿæˆè¿˜æ„å‘³ç€ï¼Œå½“æ–°çš„JDKç‰ˆæœ¬å‘ç°æœ‰æ¥å£å¼•å…¥æ–°çš„JDBCæ–¹æ³•æ—¶ï¼Œä¸éœ€è¦åšä»»ä½•äº‹æƒ…ã€‚</blockquote><h4 id=stopwatch-scheduler-quanta>â± Scheduler quanta</h4><p>SomeÂ <a href=http://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/5_CPU_Scheduling.html rel=external>light reading</a>.<p><strong>TL;DR</strong>Â Obviously, when youâ€™re running 400 threads â€œat onceâ€, you arenâ€™t really running them â€œat onceâ€ unless you have 400 cores. The operating system, using N CPU cores, switches between your threads giving each a small â€œsliceâ€ of time to run called aÂ <em>quantum</em>.<p>With a lot of threads running, as in many applications, when your time-slice runs out (as a thread) it may be a â€œlong timeâ€ before the scheduler gives you a chance to run again. It is therefore crucial that a thread get as much as possible done during its time-slice, and avoid locks that force it to give up that time-slice, otherwise there is a performance penalty to be paid. And not a small one.<p>Which brings us toâ€¦<h4 id=snail-cpu-cache-line-invalidation>ğŸŒ CPU Cache-line Invalidation</h4><p>Another big hit incurred when you canâ€™t get your work done in a quanta is CPU cache-line invalidation. If your thread is preempted by the scheduler, when it does get a chance to run again all of the data itÂ <em>was</em>Â frequently accessing is likely no longer in the coreâ€™s L1 or core-pair L2 cache. Even more likely because you have no control over which core you will be scheduled on next.<p><img alt src=https://scp-net-cn.oss-cn-beijing.aliyuncs.com/blog-images/cache.architecture.png><blockquote><p>åœ¨å¤šæ ¸å¤„ç†å™¨ä¸Šï¼Œç¼“å­˜é‡åˆ°äº†ä¸€ä¸ªé—®é¢˜â€”â€”ä¸€è‡´æ€§ã€‚ä¸åŒçš„å¤„ç†å™¨æ‹¥æœ‰å®Œå…¨æˆ–éƒ¨åˆ†åˆ†ç¦»çš„ç¼“å­˜ã€‚L1ç¼“å­˜æ˜¯åˆ†ç¦»çš„ï¼ˆè¿™å¾ˆæ™®éï¼‰ï¼Œè€Œæˆ‘æœ‰å¤šä¸ªå¤„ç†å™¨ï¼Œæ¯ä¸€ä¸ªå¤„ç†å™¨å…±äº«ä¸€ä¸ªL2ç¼“å­˜ã€‚è¿™éšç€å…·ä½“æƒ…å†µè€Œä¸åŒï¼Œå¦‚æœä¸€ä¸ªç°ä»£å¤šæ ¸æœºå™¨ä¸Šæ‹¥æœ‰å¤šçº§ç¼“å­˜ï¼Œé‚£ä¹ˆå¿«é€Ÿå°å‹çš„ç¼“å­˜å°†è¢«å¤„ç†å™¨ç‹¬å ã€‚</blockquote><blockquote><p><strong>å½“ä¸€ä¸ªå¤„ç†å™¨æ”¹å˜äº†å±äºå®ƒè‡ªå·±ç¼“å­˜ä¸­çš„ä¸€ä¸ªå€¼ï¼Œå…¶å®ƒå¤„ç†å™¨å°±å†ä¹Ÿæ— æ³•ä½¿ç”¨å®ƒè‡ªå·±åŸæ¥çš„å€¼ï¼Œå› ä¸ºå…¶å¯¹åº”çš„å†…å­˜ä½ç½®å°†è¢«åˆ·æ–°(invalidate)åˆ°æ‰€æœ‰ç¼“å­˜ã€‚è€Œä¸”ç”±äºç¼“å­˜æ“ä½œæ˜¯ä»¥ç¼“å­˜è¡Œè€Œä¸æ˜¯å­—èŠ‚ä¸ºç²’åº¦ï¼Œæ‰€æœ‰ç¼“å­˜ä¸­æ•´ä¸ªç¼“å­˜è¡Œå°†è¢«åˆ·æ–°ï¼</strong></blockquote><blockquote><p>å…³äº CPUç¼“å­˜çŸ¥è¯† å¯ä»¥å‚è€ƒä»¥ä¸‹æ–‡æ¡£ï¼š<ul><li><p><a href=https://coolshell.cn/articles/20793.html rel=external>ä¸ç¨‹åºå‘˜ç›¸å…³çš„CPUç¼“å­˜çŸ¥è¯†</a></p><li><p><a href=https://coolshell.cn/articles/10249.html rel=external>7ä¸ªç¤ºä¾‹ç§‘æ™®CPU Cache</a></p><li><p><a href=https://coolshell.cn/articles/7886.html rel=external>ä»£ç æ‰§è¡Œçš„æ•ˆç‡</a></p><li><p><a href=https://coolshell.cn/articles/7490.html rel=external>æ€§èƒ½è°ƒä¼˜æ”»ç•¥</a></p></ul></blockquote><h3 id=can-kao-wen-dang>å‚è€ƒæ–‡æ¡£ï¼š</h3><ul><li><p>https://www.linqz.io/2019/03/why-to-use-hikari-connection-pool.html</p><li><p>How to choose database connection pool :Â https://techblog.topdesk.com/coding/choosing-a-database-connection-pool/</p><li><p>http://www.programmersought.com/article/319698001/</p><li><p>How to size the Pool :Â https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing</p><li><p>Database Down Behaviour :Â https://github.com/brettwooldridge/HikariCP/wiki/Bad-Behavior:-Handling-Database-Down</p><li><p>Performance Comparison 1 :Â https://www.wix.engineering/blog/how-does-hikaricp-compare-to-other-connection-pools</p><li><p>Performance Comparison 2 :Â https://nbsoftsolutions.com/blog/the-difficulty-of-performance-evaluation-of-hikaricp-in-dropwizard</p><li><p>https://blog.jooq.org/2017/02/21/jooq-tuesdays-brett-wooldridge-shows-what-it-takes-to-write-the-fastest-java-connection-pool/</p></ul></div></div></section>