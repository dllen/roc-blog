<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>拒绝 'Vibe Coding' 的虚幻快感：深度解析 Spec-Driven Development (SDD) 与 AI 编程的未来 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-02-01</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">拒绝 'Vibe Coding' 的虚幻快感：深度解析 Spec-Driven Development (SDD) 与 AI 编程的未来</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>在 2025 年的 AI 编程浪潮中，一个新的热词悄然兴起——<strong>Spec-Driven Development (SDD，规格驱动开发)</strong>。<p>随着 AI 编码工具（如 Cursor, Windsurf, GitHub Copilot）的普及，开发者们陷入了一种被称为 <strong>“Vibe Coding” (氛围编码)</strong> 的状态：你描述一个模糊的目标，AI 给你一段看起来不错的代码，你凭感觉（Vibe）运行它。如果跑通了，皆大欢喜；如果跑不通，就再试一次。<p>然而，ThoughtWorks 的技术专家 Liu Shangqi 指出：“Vibe Coding 虽然快，但往往导致不可维护、充满缺陷的一次性代码。”<p>为了解决这个问题，SDD 应运而生。它不是要回到繁琐的瀑布流，而是要让 AI 编程从“凭感觉”走向“有纪律”。本文将结合 <strong>Martin Fowler</strong> 的最新观察、<strong>ThoughtWorks</strong> 的深度思考，以及 <strong>GitHub Spec Kit</strong> 的实战案例，带你深入理解这一编程范式。<hr><h2 id=yi-shen-me-shi-sdd-ji-yu-martin-fowler-yu-thoughtworks-de-shi-jiao>一、 什么是 SDD？(基于 Martin Fowler 与 ThoughtWorks 的视角)</h2><p>SDD 的定义目前仍处于演变之中，但核心理念已逐渐清晰。<h3 id=1-martin-fowler-de-ding-yi-yu-fen-ji>1. Martin Fowler 的定义与分级</h3><p>软件开发教父 <strong>Martin Fowler</strong> 在其文章《Understanding Spec-Driven-Development》中，对 SDD 进行了非常精准的定义。为了保留原意，我们引用他的核心观点：<blockquote><p><strong>“Spec-driven development means writing a ‘spec’ before writing code with AI (‘documentation first’). The spec becomes the source of truth for the human and the AI.”</strong><p>（SDD 意味着在使用 AI 写代码之前先写“规格说明书”（文档优先）。这份规格说明书成为了人类和 AI 共同的“单一事实来源”。）</blockquote><p>Fowler 敏锐地指出，目前的 SDD 工具其实处于三个不同的<strong>实现层级 (Implementation Levels)</strong>：<ul><li><strong>Level 1: Spec-first (规格优先)</strong> <ul><li><em>原文</em>：“A well thought-out spec is written first, and then used in the AI-assisted development workflow for the task at hand.”<li><strong>解读</strong>：先写好 Spec，再让 AI 写代码。任务完成后，Spec 可能就被丢在一边了。目前的 Spec Kit 和 Kiro 大多处于这个阶段。</ul><li><strong>Level 2: Spec-anchored (规格锚定)</strong> <ul><li><em>原文</em>：“The spec is kept even after the task is complete, to continue using it for evolution and maintenance of the respective feature.”<li><strong>解读</strong>：Spec 不仅用于生成代码，还被保留下来。后续维护时，必须先更新 Spec，再更新代码，Spec 是代码的“锚”。</ul><li><strong>Level 3: Spec-as-source (规格即源码)</strong> <ul><li><em>原文</em>：“The spec is the main source file over time, and only the spec is edited by the human, the human never touches the code.”<li><strong>解读</strong>：这是最激进的愿景。人类只写 Spec，代码完全是编译产物（Byproduct）。人类不再触碰代码文件。</ul></ul><h3 id=2-thoughtworks-de-shi-jiao-shang-xia-wen-gong-cheng>2. ThoughtWorks 的视角：上下文工程</h3><p>ThoughtWorks 的 <strong>Liu Shangqi</strong> 则从<strong>上下文工程 (Context Engineering)</strong> 的角度解读了 SDD。他认为：<blockquote><p><strong>“Prompt engineering optimizes human-LLM interaction, while context engineering optimizes agent-LLM interaction.”</strong><p>（提示词工程优化的是“人与大模型”的交互，而上下文工程优化的是“Agent 与大模型”的交互。）</blockquote><p>在 SDD 中，Spec 本质上就是一种被精心设计的、压缩了的上下文（Context）。通过将需求分析与编码实现分离，SDD 实际上是在进行一种高级的“少样本提示 (Few-shot prompting)”，用结构化的 Spec 来约束 AI 的发散性。<hr><h2 id=er-shi-zhan-an-li-github-spec-kit-de-gong-zuo-liu>二、 实战案例：GitHub Spec Kit 的工作流</h2><p>Martin Fowler 提到的工具中，<strong>Spec Kit</strong> 是目前最容易上手且开源的 SDD 工具集。虽然 GitHub 官方文档较为冗长，但我们可以将其核心工作流提炼为四个关键步骤。<p><strong>Spec Kit 的核心哲学</strong>：不要让 AI 猜你想做什么，而是用结构化的文档“驾驶”它。<h3 id=shi-zhan-yan-shi-kai-fa-yi-ge-ge-ren-zhao-pian-zheng-li-qi>实战演示：开发一个“个人照片整理器”</h3><p>假设我们要开发一个本地照片整理应用。在 Spec Kit 的模式下，我们不会直接对 AI 说“帮我写个相册应用”，而是遵循以下流程：<h4 id=1-que-li-xian-fa-constitution>1. 确立宪法 (Constitution)</h4><p>首先，Spec Kit 引入了 <code>Constitution</code>（宪法）的概念。这是一份项目级的最高准则，AI 在生成任何内容时都必须遵守。<ul><li><em>内容示例</em>：“所有数据库操作必须使用 SQLite”、“前端必须使用 Tailwind CSS”、“代码必须包含详细注释”。<li><em>作用</em>：这就像是给 AI 戴上了“紧箍咒”，防止它在技术选型上放飞自我。</ul><h4 id=2-ding-yi-gui-ge-specify>2. 定义规格 (Specify)</h4><p>这是 SDD 的起点。我们需要运行 <code>/speckit.specify</code> 命令。<ul><li><strong>输入</strong>：自然语言描述（如“我想要一个按日期分组的照片墙，支持拖拽排序”）。<li><strong>AI 输出</strong>：生成一份详细的 <code>spec.md</code>。这份文档不会包含代码，而是包含： <ul><li><strong>用户旅程 (User Journey)</strong>：用户如何打开应用，如何点击。<li><strong>功能边界</strong>：明确什么要做，什么<strong>不做</strong>。<li><strong>成功标准</strong>：如何判断功能已完成。</ul><li><em>关键点</em>：在这个阶段，你只关注“做什么 (What)”，完全不关注“怎么做 (How)”。</ul><h4 id=3-ji-shu-ji-hua-plan>3. 技术计划 (Plan)</h4><p>有了 Spec 后，运行 <code>/speckit.plan</code>。<ul><li><strong>AI 输出</strong>：生成 <code>plan.md</code>。<li><strong>内容</strong>： <ul><li><strong>架构设计</strong>：选择 Vite + React。<li><strong>数据模型</strong>：定义 <code>Photo</code> 和 <code>Album</code> 的数据库表结构。<li><strong>文件结构</strong>：预估需要创建哪些文件。</ul><li><em>关键点</em>：这是将业务需求翻译成技术语言的过程。你可以在这里审查 AI 的技术选型是否合理。</ul><h4 id=4-ren-wu-chai-jie-yu-zhi-xing-tasks-implement>4. 任务拆解与执行 (Tasks & Implement)</h4><p>最后，运行 <code>/speckit.tasks</code> 和 <code>/speckit.implement</code>。<ul><li>AI 会将 <code>plan.md</code> 拆解为一系列微小的、可执行的 Checklist（任务清单）。<li><strong>执行</strong>：AI 逐个勾选任务，生成代码，并通过测试。</ul><p><strong>总结 Spec Kit 的模式</strong>：它将“写代码”这个巨大的黑盒，拆解成了 <strong>意图 -> 规格 -> 计划 -> 任务 -> 代码</strong> 的透明流水线。这正是“拒绝 Vibe Coding”的体现。<hr><h2 id=san-shen-du-dui-bi-kiro-yu-tessl>三、 深度对比：Kiro 与 Tessl</h2><p>除了 Spec Kit，Martin Fowler 还深入体验了另外两款工具，它们的理念各有千秋。<h3 id=1-kiro-qing-liang-ji-de-spec-first>1. Kiro：轻量级的 “Spec-first”</h3><p>Martin Fowler 认为 Kiro 是最简单的工具。<blockquote><p><em>原文</em>：“Kiro is the simplest (or most lightweight) one… Workflow: Requirements → Design → Tasks.”</blockquote><p>Kiro 的流程非常直观：<strong>需求 -> 设计 -> 任务</strong>。它通过 VS Code 插件引导用户完成这三步。但 Fowler 也指出了它的局限性：对于复杂的、跨多个任务的长期维护，Kiro 似乎缺乏“Spec-anchored（规格锚定）”的机制。<h3 id=2-tessl-ji-jin-de-spec-as-source>2. Tessl：激进的 “Spec-as-source”</h3><p>Tessl 是 Fowler 眼中最独特的工具，因为它试图实现 SDD 的终极形态——<strong>Spec 即源码</strong>。<blockquote><p><em>原文</em>：“Tessl is the only one… that explicitly aspires to a spec-anchored approach… The code even marked with a comment at the top saying <code>// GENERATED FROM SPEC - DO NOT EDIT</code>.”</blockquote><p>在 Tessl 的愿景中，开发者编辑的是 Spec 文件（可能是某种结构化的 Markdown 或 DSL），而 <code>.js</code> 或 <code>.py</code> 文件完全由 AI 自动生成，且不可手动编辑。这就像我们写 TypeScript 编译成 JavaScript 一样，未来我们将写 Spec 编译成 Code。<hr><h2 id=si-tiao-zhan-yu-fan-si>四、 挑战与反思</h2><p>SDD 是否是灵丹妙药？Martin Fowler 和 ThoughtWorks 都给出了冷静的思考。<h3 id=1-shi-pu-bu-liu-de-hui-gui-ma>1. 是“瀑布流”的回归吗？</h3><p>很多人看到 SDD 的“先文档后编码”流程，会质疑这是不是倒退回了瀑布开发模型。 ThoughtWorks 的 Liu Shangqi 反驳道：<blockquote><p><em>原文</em>：“It’s not creating huge feedback loops like waterfall — it’s providing a mechanism for shorter and effective ones than would otherwise be possible with pure vibe coding.”<p>（这并不是制造像瀑布流那样巨大的反馈环，而是提供了一种机制，相比纯粹的 Vibe Coding，它能带来更短、更有效的反馈。）</blockquote><p>Vibe Coding 看似快，但由于缺乏设计，往往在后期陷入无尽的 Debug 泥潭。SDD 实际上是在“慢”中求“快”。<h3 id=2-gui-ge-piao-yi-spec-drift-de-feng-xian>2. 规格漂移 (Spec Drift) 的风险</h3><p>Liu Shangqi 也提到了一个核心痛点：<blockquote><p><em>原文</em>：“Spec drift and hallucination are inherently difficult to avoid. We still need highly deterministic CI/CD practices…”</blockquote><p>如果代码被修改了，但 Spec 没有更新，Spec 就成了废纸。这是 SDD 面临的最大挑战。除非像 Tessl 那样强制“单向生成”，否则保持 Spec 与代码的同步需要极高的纪律性。<h3 id=3-one-workflow-to-fit-all-sizes-yi-tao-liu-cheng-tong-chi>3. “One workflow to fit all sizes?” (一套流程通吃？)</h3><p>Martin Fowler 提出了一个非常犀利的质疑：<blockquote><p><em>原文</em>：“When I asked Kiro to fix a small bug… it quickly became clear that the workflow was like using a sledgehammer to crack a nut.”<p>（当我让 Kiro 修一个小 Bug 时……这简直是杀鸡用牛刀。）</blockquote><p>目前的 SDD 工具（无论是 Spec Kit 还是 Kiro）往往流程繁琐，对于修复一个小 Bug 来说，写一套完整的 Spec 显得过于笨重。未来的 SDD 工具必须能够适应不同粒度的任务。<hr><h2 id=jie-yu>结语</h2><p>Spec-Driven Development 正在重新定义人与 AI 的协作模式。<ul><li>对于<strong>简单任务</strong>，“Vibe Coding” 或许依然有效。<li>但对于<strong>复杂系统</strong>，我们需要 Spec Kit 这样的工具来确立“宪法”与“计划”。<li>而在<strong>未来</strong>，我们或许会像 Tessl 预言的那样，只维护 Spec，让代码成为 AI 时代的汇编语言。</ul><p>在这个转型期，保持清醒，不盲目追求速度，回归对软件行为（Behavior）的深度定义，或许才是程序员在 AI 时代的核心竞争力。</div></div></section>