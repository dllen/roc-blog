<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Linux CGroups and Namespaces | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2024-01-11</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Linux CGroups and Namespaces</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>Namespaces 用来做进程间资源隔离，Namespaces 中进程使用的资源对其他进程不可见（包括 进程ID、Hostnames、用户ID、文件、网络 等内核资源）。<p>Cgroup 用来做资源限制，包括 CPU、内存、网络、磁盘 等系统资源；<p>Namespaces和 Cgroup 是Linux 容器技术的基石。<p>如果进程更改了特定Namespaces下的全局资源(如 PID) ，则只有同一Namespaces中的进程才能看到此更改。(不管初始化进程是什么，都可以用 PID 1启动进程)<p>以下是Linux内核中的几种Namespaces类型:<p><strong>User Namespace</strong><p>给予进程的独立用户和组ID。进程可以在其命名空间中升级到Root用户。<p>User Namespace是嵌套的。所有User Namespace都有一个父User Namespace (Root User Namespace除外) ，并且有零个或多个子 User Namespace。<p><strong>PID Namespace</strong><p>PID Namespace 用来隔离进程 ID。不同 PID Namespace 下的不同进程可以具有相同的进程 ID。PID Namespace 的第一个进程采用 PID 1，随后的进程ID 按顺序生成。<p><strong>Network Namespace</strong><p>Network Namespace 用于隔离网络。Network Namespace 中的进程可以独立于其他Network Namespace使用自定义/特定的路由表、 IP 地址、网络设备和其他网络资源。<p><em>备注：我们可以使用使用网络命名空间的 <code>ip netns</code> 命令来创建虚拟网络设备</em><p><strong>Mount Namespace</strong><p>不影响主机文件系统，为命名空间下的进程挂载文件系统。<p><strong>IPC Namespace</strong><p>IPC Namespace下的进程可以以独立的方式使用 IPC 资源。例如消息队列、共享内存和 SystemVIPC 对象。<p><strong>UNIX Time Sharing(UTS) Namespace</strong><p>UNIX Time Sharing(UTS) Namespace 下的进程似乎在不同的机器上运行 (隔离主机名，不同的主机名)。<p><strong>Control Group (cgroup)</strong><p>使用 cgroup，可以限制 Namespace 下进程的资源，如 CPU、内存、磁盘等。<p><strong>Time Namespace</strong><p>Time Namespace下的进程可以有不同的系统时间。<p><strong>Example with <code>unshare</code></strong><p>可以使用 unshare 命令在 namespace 中执行进程。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>Usage:</span></span>
<span class=giallo-l><span> unshare [options] [&lt;program> [&lt;argument>...]]</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>Run a program with some namespaces unshared from the parent.</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>Options:</span></span>
<span class=giallo-l><span> -m, --mount[=&lt;file>]      unshare mounts namespace</span></span>
<span class=giallo-l><span> -u, --uts[=&lt;file>]        unshare UTS namespace (hostname etc)</span></span>
<span class=giallo-l><span> -i, --ipc[=&lt;file>]        unshare System V IPC namespace</span></span>
<span class=giallo-l><span> -n, --net[=&lt;file>]        unshare network namespace</span></span>
<span class=giallo-l><span> -p, --pid[=&lt;file>]        unshare pid namespace</span></span>
<span class=giallo-l><span> -U, --user[=&lt;file>]       unshare user namespace</span></span>
<span class=giallo-l><span> -C, --cgroup[=&lt;file>]     unshare cgroup namespace</span></span>
<span class=giallo-l><span> -f, --fork                fork before launching &lt;program></span></span>
<span class=giallo-l><span>     --kill-child[=&lt;signame>]  when dying, kill the forked child (implies --fork); defaults to SIGKILL</span></span>
<span class=giallo-l><span>     --mount-proc[=&lt;dir>]  mount proc filesystem first (implies --mount)</span></span>
<span class=giallo-l><span> -r, --map-root-user       map current user to root (implies --user)</span></span>
<span class=giallo-l><span>     --propagation slave|shared|private|unchanged</span></span>
<span class=giallo-l><span>                           modify mount propagation in mount namespace</span></span>
<span class=giallo-l><span> -s, --setgroups allow|deny  control the setgroups syscall in user namespaces</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span> -h, --help                display this help</span></span>
<span class=giallo-l><span> -V, --version             display version</span></span></code></pre><p><code>unshare --user --pid --map-root-user --mount-proc --fork bash</code><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>--user: 创建user namespace</span></span>
<span class=giallo-l><span>--pid: 不从父进程继承pid命名空间，在子进程内执行ps，无法看到父进程原有的进程</span></span>
<span class=giallo-l><span>--map-root-user:  namespace 中支持 root 权限</span></span>
<span class=giallo-l><span>--mount-proc: 确保创建了 PID 和 Mount namespace 后，自动挂载 /proc 文件系统，无需我们手动执行 `mount -t proc proc /proc` 命令</span></span>
<span class=giallo-l><span>--fork: 执行unshare的进程fork一个新的子进程，在子进程里执行unshare传入的参数</span></span></code></pre><blockquote><p>使用 <code>--mount-proc</code>，可以隔离宿主机 <code>/proc</code> 文件系统，使用独立的进程ID； 可以通过 <code>lsns</code> 命令列出 namespaces；</blockquote><p><strong>Control Groups</strong><p>通过Control Groups，CPU、磁盘、网络、内存和其他系统资源都可以受到限制。我们可以使用 cgroup 创建资源限制配置。<ul><li>优先级: 我们可以使用 cgroup 对名称空间中的进程进行优先排序。<li>统计和监控: 可以在 cgroup 级别进行监控和统计资源。<li>管理：同一 cgroup 下的进程可以由单个命令管理。</ul><p>CGroup 工具：<p>Debian <code>sudo apt install cgroup-tools</code><p>Centos <code>sudo yum install libcgroup</code> <code>sudo yum install libcgroup-tools</code><p><strong>示例</strong><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#616e88># 创建 memory cgroup</span></span>
<span class=giallo-l><span style=color:#88c0d0>sudo</span><span style=color:#a3be8c> cgcreate -g memory:test-memory-limiter</span></span>
<span class=giallo-l><span style=color:#88c0d0>ls</span><span style=color:#a3be8c> -la /sys/fs/cgroup/memory/test-memory-limiter/</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88># 限制内存</span></span>
<span class=giallo-l><span style=color:#88c0d0>sudo</span><span style=color:#a3be8c> cgset -r memory.limit_in_bytes=50M my-memory-limiter</span></span>
<span class=giallo-l><span style=color:#88c0d0>cat</span><span style=color:#a3be8c> /sys/fs/cgroup/memory/test-memory-limiter/memory.limit_in_bytes</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88># 编译测试程序</span></span>
<span class=giallo-l><span style=color:#616e88># gcc high_mem.c -o high_mem.c</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88># 执行内存限制进程</span></span>
<span class=giallo-l><span style=color:#616e88># sudo cgexec -g memory:test-memory-limiter ./high_mem</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88># namespace 下执行内存限制进程</span></span>
<span class=giallo-l><span style=color:#88c0d0>sudo</span><span style=color:#a3be8c> cgexec -g memory:test-memory-limiter unshare -fp - mount-proc /bin/bash</span></span></code></pre><p><code>high_mem.c</code> 代码<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>int main()</span></span>
<span class=giallo-l><span>{</span></span>
<span class=giallo-l><span>        while(1)</span></span>
<span class=giallo-l><span>        {</span></span>
<span class=giallo-l><span>                void *m = malloc(1024*1024);</span></span>
<span class=giallo-l><span>                memset(m,0,1024*1024);</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>        return 0;</span></span>
<span class=giallo-l><span>}</span></span></code></pre><blockquote><p>可以通过 <code>systemd-cgtop</code> 查看 <code>cgroup</code> 资源使用情况；</blockquote><p><strong>参考文档</strong><ul><li><a href=https://www.nginx.com/blog/what-are-namespaces-cgroups-how-do-they-work/ rel=external>What Are Namespaces and cgroups, and How Do They Work?</a><li><a href=https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/resource_management_guide/index rel=external>Resource Management Guide</a><li><a href=https://theboreddev.com/understanding-linux-namespaces/ rel=external>Understanding Linux Namespaces</a><li><a href=https://en.wikipedia.org/wiki/Linux_namespaces rel=external>Wiki Linux namespaces</a><li><a href=https://man7.org/linux/man-pages/man7/namespaces.7.html rel=external>namespaces(7) — Linux manual page</a><li><a href=https://towardsdatascience.com/the-power-of-linux-cgroups-how-containers-take-control-of-their-resources-ba564fef13b0 rel=external>The Power of Linux Cgroups: How Containers Take Control of Their Resources</a></ul></div></div></section>