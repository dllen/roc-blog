<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Redis 源码阅读：08. redisObject (对象系统核心) | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/redis/> /redis </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-10</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Redis 源码阅读：08. redisObject (对象系统核心)</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>我们之前学习了 SDS, Dict, ZipList 等底层数据结构。但在 Redis 中，我们并不直接操作这些结构，而是操作 <strong>对象 (Object)</strong>。<p>每当我们创建一个键值对时，Redis 至少会创建两个对象：<ol><li><strong>键对象</strong>：总是 String 类型。<li><strong>值对象</strong>：可以是 String, List, Hash, Set, ZSet 等。</ol><p>这一切的基石就是 <code>redisObject</code> 结构体。<h2 id=1-jie-gou-ding-yi>1. 结构定义</h2><p>在 <code>server.h</code> 中：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=c><span class=giallo-l><span style=color:#81a1c1>typedef struct</span><span> redisObject </span><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span style=color:#81a1c1>    unsigned</span><span> type:</span><span style=color:#b48ead>4</span><span style=color:#81a1c1>;</span><span style=color:#616e88>       // 类型</span></span>
<span class=giallo-l><span style=color:#81a1c1>    unsigned</span><span> encoding:</span><span style=color:#b48ead>4</span><span style=color:#81a1c1>;</span><span style=color:#616e88>   // 编码</span></span>
<span class=giallo-l><span style=color:#81a1c1>    unsigned</span><span> lru:LRU_BITS</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // LRU/LFU 记录 (24 bits)</span></span>
<span class=giallo-l><span style=color:#81a1c1>    int</span><span> refcount</span><span style=color:#81a1c1>;</span><span style=color:#616e88>          // 引用计数</span></span>
<span class=giallo-l><span style=color:#81a1c1>    void *</span><span>ptr</span><span style=color:#81a1c1>;</span><span style=color:#616e88>             // 指向底层数据结构的指针</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span><span> robj</span><span style=color:#81a1c1>;</span></span></code></pre><h3 id=1-1-type-lei-xing>1.1 Type (类型)</h3><p>对应 Redis 的对外数据类型：<ul><li><code>OBJ_STRING</code><li><code>OBJ_LIST</code><li><code>OBJ_SET</code><li><code>OBJ_ZSET</code><li><code>OBJ_HASH</code><li>…</ul><h3 id=1-2-encoding-bian-ma>1.2 Encoding (编码)</h3><p>这是 Redis 对象系统的精髓。同一个 Type，底层可以使用不同的 Encoding。 例如 <code>OBJ_LIST</code> 类型，底层可以是 <code>OBJ_ENCODING_QUICKLIST</code>，也可以是 <code>OBJ_ENCODING_ZIPLIST</code> (旧版本)。<p>这种设计让 Redis 非常灵活：<strong>在数据量少时使用省内存的编码，数据量大时切换为高性能的编码</strong>。<h3 id=1-3-lru-lfu>1.3 LRU/LFU</h3><p>这 24 位用于实现内存淘汰策略。<ul><li>如果策略是 LRU，记录最后一次访问时间的秒级时间戳。<li>如果策略是 LFU，记录访问频率和最后访问时间。</ul><h3 id=1-4-refcount-yin-yong-ji-shu>1.4 Refcount (引用计数)</h3><p>C 语言没有 GC，Redis 使用引用计数来管理内存。<ul><li>创建对象时 <code>refcount = 1</code>。<li>对象被共享时 <code>incrRefCount</code>。<li>不再使用时 <code>decrRefCount</code>，减为 0 时释放内存。</ul><p>Redis 启动时会预先创建 0-9999 这 10000 个整数对象（共享整数），用于节省内存。</div></div></section>