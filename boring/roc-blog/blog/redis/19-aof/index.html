<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Redis 源码阅读：19. AOF (日志持久化) | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/redis/> /redis </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-11</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Redis 源码阅读：19. AOF (日志持久化)</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>AOF (Append Only File) 通过记录 Redis 执行的每一条<strong>写命令</strong>来实现持久化。 代码位于 <code>src/aof.c</code>。<h2 id=1-ming-ling-zhui-jia-append>1. 命令追加 (Append)</h2><p>当 Redis 执行完一个写命令后，会将该命令以 RESP 协议格式追加到 <code>server.aof_buf</code> 缓冲区。<h2 id=2-wen-jian-xie-ru-yu-tong-bu-write-fsync>2. 文件写入与同步 (Write & Fsync)</h2><p>Redis 主循环每次结束前，都会调用 <code>flushAppendOnlyFile</code> 函数，决定是否将缓冲区写入磁盘。 策略由 <code>appendfsync</code> 参数控制：<ul><li><strong>always</strong>：每次写命令都立即调用 <code>fsync</code>。最安全，但最慢。<li><strong>everysec</strong>：每秒调用一次 <code>fsync</code> (默认)。折中方案，最多丢失 1 秒数据。<li><strong>no</strong>：只调用 <code>write</code>，不调用 <code>fsync</code>，由操作系统决定何时回写磁盘。</ul><h2 id=3-aof-zhong-xie-rewrite>3. AOF 重写 (Rewrite)</h2><p>随着时间推移，AOF 文件会越来越大。比如我对一个 Key <code>INCR</code> 了 100 次，AOF 记录了 100 条命令，但实际上只需要一条 <code>SET key 100</code> 就能恢复。 AOF 重写就是为了解决这个问题。<p><strong>流程</strong>：<ol><li><strong>Fork 子进程</strong>。<li><strong>子进程</strong>遍历内存数据，生成新的 AOF 文件 (类似于 RDB 快照，但是是 RESP 格式)。<li><strong>父进程</strong>继续处理请求，并将这期间产生的新写命令积累到 <strong>AOF 重写缓冲区 (AOF Rewrite Buffer)</strong>。<li>子进程写完退出。<li>父进程将重写缓冲区的内容追加到新 AOF 文件末尾。<li>原子替换旧 AOF 文件。</ol><h2 id=4-redis-7-0-multi-part-aof>4. Redis 7.0 Multi-Part AOF</h2><p>Redis 7.0 对 AOF 进行了重大重构，引入了 <strong>Multi-Part AOF (MP-AOF)</strong>。 AOF 不再是一个单文件，而是由三部分组成：<ol><li><strong>Base AOF</strong> (RDB 格式或 AOF 格式)：重写后的基础数据。<li><strong>Incr AOF</strong>：增量数据。<li><strong>Manifest</strong>：清单文件，管理上述文件的版本。</ol><p>这使得 AOF 重写不再需要浪费 CPU 去合并历史数据，只需要将当前的 Incr AOF 变为 Base AOF 即可，极大优化了重写性能。</div></div></section>