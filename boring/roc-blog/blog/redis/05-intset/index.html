<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Redis 源码阅读：05. IntSet (整数集合) | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/redis/> /redis </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-10</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Redis 源码阅读：05. IntSet (整数集合)</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>当我们在 Redis 中创建一个 Set，并且只往里面塞整数（例如 <code>SADD myset 1 2 3</code>），Redis 底层并不会立刻创建一个庞大的 HashTable，而是使用一种名为 <strong>IntSet (整数集合)</strong> 的特殊结构。<h2 id=1-jie-gou-ding-yi>1. 结构定义</h2><p>IntSet 的定义非常简单 (<code>intset.h</code>)：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=c><span class=giallo-l><span style=color:#81a1c1>typedef struct</span><span> intset </span><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span style=color:#81a1c1>    uint32_t</span><span> encoding</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 编码方式: INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</span></span>
<span class=giallo-l><span style=color:#81a1c1>    uint32_t</span><span> length</span><span style=color:#81a1c1>;</span><span style=color:#616e88>   // 元素数量</span></span>
<span class=giallo-l><span style=color:#81a1c1>    int8_t</span><span> contents</span><span style=color:#81a1c1>[];</span><span style=color:#616e88> // 柔性数组，实际存储整数</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span><span> intset</span><span style=color:#81a1c1>;</span></span></code></pre><p>虽然 <code>contents</code> 声明为 <code>int8_t</code>，但实际上它并不保存 8 位整数。它保存的是 <code>int16_t</code>, <code>int32_t</code> 或 <code>int64_t</code> 类型的整数，具体取决于 <code>encoding</code> 字段的值。<h2 id=2-he-xin-te-xing-you-xu-yu-er-fen-cha-zhao>2. 核心特性：有序与二分查找</h2><p>IntSet 中的元素是 <strong>从小到大有序排列</strong> 的，且 <strong>不包含重复元素</strong>。<p>正因为有序，IntSet 在查找元素（<code>intsetFind</code>）时，使用的是 <strong>二分查找 (Binary Search)</strong>，时间复杂度为 O(log N)。这比 HashTable 的 O(1) 慢，但考虑到 IntSet 只在元素较少（默认 &lt; 512）时使用，log(512) 只有 9，性能完全足够，且极其节省内存。<h2 id=3-bian-ma-sheng-ji-upgrade>3. 编码升级 (Upgrade)</h2><p>这是 IntSet 最有趣的设计。<p>一开始，如果你的集合里只有小整数（如 1, 10, 100），<code>encoding</code> 可能是 <code>INTSET_ENC_INT16</code>（每个元素占 2 字节）。<p>当你突然插入一个大整数（如 65536，超出了 int16 范围），IntSet 必须进行 <strong>升级</strong>：<ol><li><strong>扩展内存</strong>：根据新元素的类型（如 int32），计算所有元素转换后所需的总空间，重新 <code>realloc</code>。<li><strong>数据迁移</strong>：从后往前，将旧元素搬运到新位置，并扩展为新类型（如从 2 字节扩展为 4 字节）。<li><strong>插入新元素</strong>。<li><strong>更新 encoding</strong>：将 <code>encoding</code> 修改为 <code>INTSET_ENC_INT32</code>。</ol><p><strong>注意：</strong> IntSet <strong>只支持升级，不支持降级</strong>。一旦升级到 int64，即使你删除了所有大整数，它依然保持 int64 编码。这是为了减少内存重分配的开销。<h2 id=4-zong-jie>4. 总结</h2><p>IntSet 是 Redis “时间换空间” 策略的典型体现。对于小规模整数集合，它用 O(log N) 的查找时间换取了极高的内存利用率。</div></div></section>