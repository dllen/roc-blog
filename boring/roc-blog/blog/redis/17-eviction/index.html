<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Redis 源码阅读：17. 内存淘汰机制 (LRU & LFU) | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/redis/> /redis </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-11</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Redis 源码阅读：17. 内存淘汰机制 (LRU & LFU)</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>当 Redis 内存使用达到 <code>maxmemory</code> 限制时，需要执行 <strong>内存淘汰 (Eviction)</strong>。 <code>evict.c</code> 中的 <code>performEvictions</code> 函数负责此逻辑。<h2 id=1-tao-tai-ce-lue>1. 淘汰策略</h2><p>Redis 支持多种淘汰策略（<code>maxmemory-policy</code>）：<ul><li><code>noeviction</code>: 拒绝写入，直接报错 (默认)。<li><code>allkeys-lru</code> / <code>volatile-lru</code>: 淘汰最近最少使用的 Key。<li><code>allkeys-random</code> / <code>volatile-random</code>: 随机淘汰。<li><code>allkeys-lfu</code> / <code>volatile-lfu</code>: 淘汰最不常使用的 Key (Redis 4.0+)。<li><code>volatile-ttl</code>: 淘汰 TTL 最短的 Key。</ul><h2 id=2-jin-si-lru-approximated-lru>2. 近似 LRU (Approximated LRU)</h2><p>标准的 LRU 需要维护一个双向链表，每次访问都要把节点移到链表头，开销太大。 Redis 采用 <strong>近似 LRU</strong> 算法：<ol><li><strong>随机采样</strong>：随机从数据库中选出 5 个 Key (可配置)。<li><strong>淘汰最旧</strong>：比较这 5 个 Key 的 <code>lru</code> 字段（最后访问时间），淘汰最旧的那个。</ol><p>为了提高准确性，Redis 3.0 引入了 <strong>Eviction Pool</strong>（淘汰池）。它是一个大小为 16 的数组，用于暂存那些“看起来很旧”的 Key。每次采样后，将新采样的 Key 与池中的 Key 融合，始终保留最旧的 Key，从而让近似算法的效果逼近真实 LRU。<h2 id=3-lfu-least-frequently-used>3. LFU (Least Frequently Used)</h2><p>LRU 的缺点是：如果一个 Key 很久没用，刚才偶尔被扫了一次，LRU 就会认为它是热数据。 LFU (最不常使用) 更能反映数据的冷热。<p>Redis 复用了 <code>redisObject</code> 的 <code>lru</code> 字段（24 bits）：<ul><li><strong>高 16 位</strong>：最后递减时间 (Last Decrement Time)。<li><strong>低 8 位</strong>：对数计数器 (Logarithmic Counter)。</ul><p><strong>计数器逻辑</strong>：<ul><li><strong>增长</strong>：访问时，并非每次都 +1，而是按概率增加。计数器越大，增加越难。这使得 8 bit (最大 255) 能表示很大的访问频率。<li><strong>衰减</strong>：读取 Key 时，如果发现距离上次衰减已经过去很久了，就将计数器减半或减一。</ul><p>LFU 算法完美解决了“缓存污染”问题。</div></div></section>