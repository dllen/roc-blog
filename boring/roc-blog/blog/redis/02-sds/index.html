<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Redis 源码阅读：02. SDS (Simple Dynamic String) | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/redis/> /redis </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-10</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Redis 源码阅读：02. SDS (Simple Dynamic String)</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>在 Redis 中，字符串是最基础的数据类型。但 Redis 并没有直接使用 C 语言传统的字符串（以 <code>\0</code> 结尾的字符数组），而是自己构建了一种名为 <strong>SDS (Simple Dynamic String，简单动态字符串)</strong> 的抽象类型。<p>为什么 Redis 要重新造轮子？SDS 到底长什么样？本文将带你深入 <code>sds.h</code> 和 <code>sds.c</code> 一探究竟。<h2 id=1-c-zi-fu-chuan-de-tong-dian>1. C 字符串的痛点</h2><p>要理解 SDS 的设计，首先得知道 C 语言字符串（C-String）有哪些缺陷：<ol><li><strong>获取长度 O(N)</strong>：C 字符串不记录长度，必须遍历整个数组找到 <code>\0</code> 才能计算出长度。这对于高频操作 <code>STRLEN</code> 来说是无法接受的。<li><strong>二进制不安全</strong>：C 字符串以 <code>\0</code> 作为结束符，这意味着字符串中间不能包含空字符。这限制了它只能存储文本，无法存储图片、音频、压缩包等二进制数据。<li><strong>缓冲区溢出风险</strong>：C 字符串拼接（<code>strcat</code>）时，如果程序员忘记分配足够的空间，就会导致缓冲区溢出，覆盖相邻内存的数据，造成程序崩溃或安全漏洞。<li><strong>内存管理效率低</strong>：每次修改字符串长度（增长或缩短），都需要重新进行内存分配（<code>realloc</code>），开销巨大。</ol><h2 id=2-sds-de-jie-gou-she-ji>2. SDS 的结构设计</h2><p>Redis 在 <code>sds.h</code> 中定义了 SDS 的头部结构。为了节省内存，Redis 设计了 5 种不同类型的 Header (<code>sdshdr5</code>, <code>sdshdr8</code>, <code>sdshdr16</code>, <code>sdshdr32</code>, <code>sdshdr64</code>)，根据字符串长度选择最小的头部。<p>以最常用的 <code>sdshdr8</code> 为例：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=c><span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#88c0d0> __attribute__</span><span style=color:#eceff4> ((</span><span>__packed__</span><span style=color:#eceff4>))</span><span> sdshdr8 </span><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span style=color:#81a1c1>    uint8_t</span><span> len</span><span style=color:#81a1c1>;</span><span style=color:#616e88>         /* 已使用长度 (buf 中实际保存的字符串长度) */</span></span>
<span class=giallo-l><span style=color:#81a1c1>    uint8_t</span><span> alloc</span><span style=color:#81a1c1>;</span><span style=color:#616e88>       /* 分配的总长度 (不包括 header 和 null 结束符) */</span></span>
<span class=giallo-l><span style=color:#81a1c1>    unsigned char</span><span> flags</span><span style=color:#81a1c1>;</span><span style=color:#616e88> /* 标志位 (低3位表示类型，高5位未使用) */</span></span>
<span class=giallo-l><span style=color:#81a1c1>    char</span><span> buf</span><span style=color:#81a1c1>[];</span><span style=color:#616e88>          /* 柔性数组，存放实际内容 */</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span><span style=color:#81a1c1>;</span></span></code></pre><h3 id=guan-jian-she-ji-dian>关键设计点：</h3><ol><li><strong>O(1) 获取长度</strong>：<code>len</code> 字段直接记录了字符串长度，<code>STRLEN</code> 命令瞬间完成。<li><strong>二进制安全</strong>：SDS 虽然也保留了末尾的 <code>\0</code>（为了兼容 C 标准库函数如 <code>printf</code>），但它不以 <code>\0</code> 判断结束，而是严格依赖 <code>len</code> 属性。因此，<code>buf</code> 中间可以安全地包含 <code>\0</code>。<li><strong>紧凑内存布局</strong>：<code>__attribute__ ((__packed__))</code> 告诉编译器取消字节对齐，强制结构体紧凑排列。这不仅节省内存，还让 SDS 指针（指向 <code>buf</code> 的指针）可以通过 <code>sds[-1]</code> 快速访问到 <code>flags</code>，进而确定 Header 类型。</ol><h2 id=3-nei-cun-guan-li-ce-lue>3. 内存管理策略</h2><p>SDS 通过 <strong>空间预分配</strong> 和 <strong>惰性空间释放</strong> 两种策略，解决了 C 字符串内存分配频繁的问题。<h3 id=3-1-kong-jian-yu-fen-pei-space-pre-allocation>3.1 空间预分配 (Space Pre-allocation)</h3><p>当 SDS 需要进行扩展（如 <code>sdscat</code>）时，Redis 不仅会分配所需的空间，还会多分配一部分作为缓冲（Free Space）。<p>逻辑在 <code>sds.c/sdsMakeRoomFor</code> 函数中：<ul><li><strong>如果修改后长度 &lt; 1MB</strong>：分配 <code>new_len * 2</code> 的空间。例如，增长后需要 100 字节，实际分配 200 字节。<li><strong>如果修改后长度 >= 1MB</strong>：分配 <code>new_len + 1MB</code> 的空间。避免分配过大的内存造成浪费。</ul><p>这种策略将连续 N 次字符串追加操作的内存重分配次数，从 N 次降低为 <strong>最多 N 次</strong>（通常远小于 N）。<h3 id=3-2-duo-xing-kong-jian-shi-fang-lazy-freeing>3.2 惰性空间释放 (Lazy Freeing)</h3><p>当 SDS 缩短（如 <code>sdstrim</code>）时，Redis <strong>不会立即回收</strong> 多余的内存，而是更新 <code>len</code>，保持 <code>alloc</code> 不变。<p>这就为将来可能的增长操作预留了空间。当然，如果你真的需要释放内存，可以使用 <code>sdsRemoveFreeSpace</code> 函数来真正释放未使用的空间。<h2 id=4-yuan-ma-jing-du-sdsmakeroomfor>4. 源码精读：sdsMakeRoomFor</h2><p>让我们看一眼 <code>sds.c</code> 中最核心的扩容逻辑（简化版）：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=c><span class=giallo-l><span>sds </span><span style=color:#88c0d0>sdsMakeRoomFor</span><span style=color:#eceff4>(</span><span>sds s</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> size_t</span><span> addlen</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    void *</span><span>sh</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> *</span><span>newsh</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    size_t</span><span> avail </span><span style=color:#81a1c1>=</span><span style=color:#88c0d0> sdsavail</span><span style=color:#eceff4>(</span><span>s</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 计算剩余空间: alloc - len</span></span>
<span class=giallo-l><span style=color:#81a1c1>    size_t</span><span> len</span><span style=color:#eceff4>,</span><span> newlen</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    char</span><span> type</span><span style=color:#eceff4>,</span><span> oldtype </span><span style=color:#81a1c1>=</span><span> s</span><span style=color:#eceff4>[</span><span style=color:#81a1c1>-</span><span style=color:#b48ead>1</span><span style=color:#eceff4>]</span><span style=color:#81a1c1> &</span><span> SDS_TYPE_MASK</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 获取当前 header 类型</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>    // 1. 如果剩余空间足够，直接返回</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span style=color:#eceff4> (</span><span>avail </span><span style=color:#81a1c1>>=</span><span> addlen</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> return</span><span> s</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    len </span><span style=color:#81a1c1>=</span><span style=color:#88c0d0> sdslen</span><span style=color:#eceff4>(</span><span>s</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>    sh </span><span style=color:#81a1c1>=</span><span style=color:#eceff4> (</span><span style=color:#81a1c1>char*</span><span style=color:#eceff4>)</span><span>s </span><span style=color:#81a1c1>-</span><span style=color:#88c0d0> sdsHdrSize</span><span style=color:#eceff4>(</span><span>oldtype</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>    newlen </span><span style=color:#81a1c1>=</span><span style=color:#eceff4> (</span><span>len</span><span style=color:#81a1c1>+</span><span>addlen</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>    // 2. 预分配策略</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span style=color:#eceff4> (</span><span>newlen </span><span style=color:#81a1c1>&lt;</span><span> SDS_MAX_PREALLOC</span><span style=color:#eceff4>)</span><span style=color:#616e88> // SDS_MAX_PREALLOC = 1MB</span></span>
<span class=giallo-l><span>        newlen </span><span style=color:#81a1c1>*=</span><span style=color:#b48ead> 2</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    else</span></span>
<span class=giallo-l><span>        newlen </span><span style=color:#81a1c1>+=</span><span> SDS_MAX_PREALLOC</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>    // 3. 重新计算 Header 类型 (因为长度变了，可能需要升级 Header，如 sdshdr8 -> sdshdr16)</span></span>
<span class=giallo-l><span>    type </span><span style=color:#81a1c1>=</span><span style=color:#88c0d0> sdsReqType</span><span style=color:#eceff4>(</span><span>newlen</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span style=color:#616e88>    // ... (省略 Header 类型处理逻辑)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>    // 4. 执行 realloc</span></span>
<span class=giallo-l><span>    newsh </span><span style=color:#81a1c1>=</span><span style=color:#88c0d0> s_realloc</span><span style=color:#eceff4>(</span><span>sh</span><span style=color:#eceff4>,</span><span> hdrlen</span><span style=color:#81a1c1>+</span><span>newlen</span><span style=color:#81a1c1>+</span><span style=color:#b48ead>1</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span style=color:#eceff4> (</span><span>newsh </span><span style=color:#81a1c1>== NULL</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> return NULL;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span style=color:#616e88>    // ... (更新 Header 字段)</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span style=color:#eceff4> (</span><span style=color:#81a1c1>char*</span><span style=color:#eceff4>)</span><span>newsh </span><span style=color:#81a1c1>+</span><span> hdrlen</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><h2 id=5-zong-jie>5. 总结</h2><p>SDS 是 Redis 源码中最简单但也最精妙的设计之一。它通过简单的结构体封装，完美解决了 C 字符串的诸多痛点，实现了：<ul><li><strong>高性能</strong>：O(1) 长度获取，减少内存分配。<li><strong>安全性</strong>：杜绝缓冲区溢出，支持二进制数据。<li><strong>兼容性</strong>：保留 <code>\0</code> 结尾，兼容部分 C 字符串函数。</ul><p>理解了 SDS，你就迈出了阅读 Redis 源码的坚实第一步。下一篇，我们将挑战 Redis 中最为核心的数据结构 —— <strong>Dict (字典)</strong>，看看 Redis 是如何实现高效的 Hash 表及渐进式 Rehash 的。</div></div></section>