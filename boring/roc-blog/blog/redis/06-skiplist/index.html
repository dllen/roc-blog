<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Redis 源码阅读：06. SkipList (跳表) | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/redis/> /redis </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-10</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Redis 源码阅读：06. SkipList (跳表)</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>ZSet (Sorted Set) 是 Redis 最强大的数据结构之一，支持范围查询、排名等操作。它的底层主要由两个结构组成：<strong>Dict (字典)</strong> 和 <strong>SkipList (跳表)</strong>。<ul><li>Dict 负责 O(1) 查分 (Score)。<li>SkipList 负责排序和范围查找 (Range Query)。</ul><h2 id=1-wei-shen-me-xuan-tiao-biao-bu-xuan-hong-hei-shu>1. 为什么选跳表，不选红黑树？</h2><p>这是一个经典面试题。Redis 作者 Antirez 曾亲自回答过：<ol><li><strong>实现简单</strong>：跳表的代码比红黑树简单太多了，容易调试和维护。<li><strong>范围查找高效</strong>：在红黑树上做范围查找（如 <code>ZRANGE</code>），需要复杂的中序遍历回溯。而在跳表上，找到起点后，直接顺着底层链表遍历即可，缓存局部性更好。<li><strong>内存占用</strong>：跳表平均每个节点只有 1.33 个指针（取决于概率参数），而红黑树每个节点固定 2 个指针（左右子树）+ 1 个颜色位。</ol><h2 id=2-jie-gou-she-ji>2. 结构设计</h2><p>Redis 的跳表结构定义在 <code>server.h</code> 中：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=c><span class=giallo-l><span style=color:#81a1c1>typedef struct</span><span> zskiplistNode </span><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span>    sds ele</span><span style=color:#81a1c1>;</span><span style=color:#616e88>             // 元素 (Member)</span></span>
<span class=giallo-l><span style=color:#81a1c1>    double</span><span> score</span><span style=color:#81a1c1>;</span><span style=color:#616e88>        // 分数</span></span>
<span class=giallo-l><span style=color:#81a1c1>    struct</span><span> zskiplistNode </span><span style=color:#81a1c1>*</span><span>backward</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 后退指针 (用于 ZREVRANGE)</span></span>
<span class=giallo-l><span style=color:#81a1c1>    struct</span><span> zskiplistLevel </span><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span style=color:#81a1c1>        struct</span><span> zskiplistNode </span><span style=color:#81a1c1>*</span><span>forward</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 前进指针</span></span>
<span class=giallo-l><span style=color:#81a1c1>        unsigned long</span><span> span</span><span style=color:#81a1c1>;</span><span style=color:#616e88>            // 跨度 (用于计算 Rank)</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span><span> level</span><span style=color:#81a1c1>[];</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span><span> zskiplistNode</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>typedef struct</span><span> zskiplist </span><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span style=color:#81a1c1>    struct</span><span> zskiplistNode </span><span style=color:#81a1c1>*</span><span>header</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> *</span><span>tail</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    unsigned long</span><span> length</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 节点总数</span></span>
<span class=giallo-l><span style=color:#81a1c1>    int</span><span> level</span><span style=color:#81a1c1>;</span><span style=color:#616e88>            // 当前最大层数</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span><span> zskiplist</span><span style=color:#81a1c1>;</span></span></code></pre><h3 id=guan-jian-dian>关键点：</h3><ol><li><strong>Level 数组</strong>：每个节点包含多层索引。<li><strong>Span (跨度)</strong>：这是 Redis 对标准跳表的改进。记录了当前指针跨过了多少个节点。通过累加 Span，Redis 可以在 O(log N) 时间内算出任意元素的 <strong>Rank (排名)</strong>。<li><strong>Backward 指针</strong>：标准跳表是单向的，Redis 增加了后退指针，支持从后向前遍历 (<code>ZREVRANGE</code>)。</ol><h2 id=3-gai-lu-ping-heng>3. 概率平衡</h2><p>跳表不强制平衡（像 AVL 树那样旋转），而是靠<strong>概率</strong>维持平衡。<p>插入新节点时，Redis 使用 <code>zslRandomLevel</code> 函数决定它的层数：<ul><li>1/4 的概率增加一层。<li>最大层数限制为 32。</ul><p>这意味着：<ul><li>100% 的节点有 Level 1。<li>25% 的节点有 Level 2。<li>6.25% 的节点有 Level 3。<li>…</ul><p>这种随机机制保证了跳表的层数大致呈金字塔形状，从而保证查询效率稳定在 O(log N)。</div></div></section>