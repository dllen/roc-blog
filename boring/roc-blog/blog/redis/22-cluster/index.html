<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Redis 源码阅读：22. Cluster (集群模式) | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/redis/> /redis </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-11</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Redis 源码阅读：22. Cluster (集群模式)</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>Redis Cluster 是 Redis 官方提供的分布式解决方案，支持数据自动分片和去中心化管理。 代码位于 <code>src/cluster.c</code>。<h2 id=1-shu-ju-fen-pian-sharding>1. 数据分片 (Sharding)</h2><p>Redis Cluster 没有使用一致性哈希，而是引入了 <strong>Hash Slot (哈希槽)</strong> 的概念。<ul><li>整个集群共有 <strong>16384</strong> 个槽。<li>Key 落入哪个槽：<code>CRC16(key) % 16384</code>。<li>集群中的每个节点负责维护一部分槽。</ul><h2 id=2-jie-dian-tong-xin-gossip>2. 节点通信 (Gossip)</h2><p>Redis Cluster 是去中心化的（无 Master 节点），节点之间通过 <strong>Gossip 协议</strong> 交换信息。 每个节点都维护一份集群的全局视图（Cluster State），包含所有节点的状态和槽位分布信息。 节点间每秒随机握手（PING/PONG），传播集群状态。<h2 id=3-qing-qiu-zhong-ding-xiang-moved-ask>3. 请求重定向 (MOVED & ASK)</h2><p>当客户端向某个节点发送命令时：<ol><li>节点计算 Key 属于哪个槽。<li><strong>如果槽归自己管</strong>：直接执行命令。<li><strong>如果槽归别的节点管</strong>：返回 <code>MOVED &lt;slot> &lt;target_ip:port></code> 错误。 <ul><li>客户端收到 MOVED 后，应更新本地的槽位映射表，并重发命令给目标节点。</ul><li><strong>ASK 重定向</strong>： <ul><li>发生在<strong>在线迁移 (Resharding)</strong> 过程中。<li>如果槽正在从 A 迁移到 B，且 Key 还没迁移过去（在 A），A 处理。<li>如果 Key 已经迁移到 B 了，A 返回 <code>ASK &lt;slot> &lt;target_ip:port></code>。<li>客户端收到 ASK，先向 B 发送 <code>ASKING</code> 命令，再发送原命令。注意：ASK 是临时的，客户端不应更新本地映射表。</ul></ol><h2 id=4-gu-zhang-zhuan-yi>4. 故障转移</h2><p>Cluster 的故障转移机制与 Sentinel 类似，也是基于投票。 当一个 Master 挂了，它的 Slave 们会发起选举，获得集群中大多数 Master 投票的 Slave 将升级为新 Master，接管旧 Master 的槽位。</div></div></section>