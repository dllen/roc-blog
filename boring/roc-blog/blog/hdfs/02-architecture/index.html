<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>HDFS 源码阅读：02. 核心架构设计 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/hdfs/> /hdfs </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-13</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">HDFS 源码阅读：02. 核心架构设计</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>在深入每一行代码之前，我们需要站在高处俯瞰 HDFS 的设计哲学。HDFS 是 Google File System (GFS) 的开源实现，其核心设计目标是：<strong>在廉价硬件上提供高吞吐量的数据访问，并具备高容错性。</strong><h2 id=1-master-slave-jia-gou>1. Master/Slave 架构</h2><p>HDFS 采用经典的 Master/Slave 架构：<ul><li><strong>NameNode (Master)</strong>: 中心管理者。 <ul><li><strong>职责</strong>: 管理文件系统命名空间 (Namespace)，维护文件到 Block 的映射，处理客户端请求。<li><strong>特点</strong>: 单点（HA 方案解决单点故障），内存受限（所有元数据在内存）。</ul><li><strong>DataNode (Slave)</strong>: 工作节点。 <ul><li><strong>职责</strong>: 存储实际的数据块 (Block)，执行数据块的读写操作，定期向 NameNode 汇报块信息。<li><strong>特点</strong>: 数量众多，易故障。</ul></ul><h3 id=wei-shen-me-shi-dan-master>为什么是单 Master？</h3><p>GFS 论文中提到：<blockquote><p>“Having a single master vastly simplifies our design and enables the master to make sophisticated chunk placement and replication decisions using global knowledge.”</blockquote><p>单 Master 极大简化了元数据一致性问题，避免了分布式锁和复杂的共识算法（在元数据层面）。当然，这也带来了扩展性瓶颈（内存限制），后来 HDFS Federation 解决了这个问题。<h2 id=2-block-de-she-ji-zhe-xue>2. Block 的设计哲学</h2><p>文件被切割成固定大小的 Block（默认 128MB）。<h3 id=wei-shen-me-block-zhe-me-da>为什么 Block 这么大？</h3><ul><li><strong>减少元数据开销</strong>: NameNode 内存有限，Block 越大，同样大小的文件产生的元数据越少。<li><strong>最小化寻址开销</strong>: 如果 Block 太小，读取大文件时需要频繁 seek 磁盘。128MB 使得传输时间远大于寻址时间，从而获得接近磁盘顺序读写的吞吐量。</ul><h2 id=3-he-xin-tong-xin-xie-yi-rpc>3. 核心通信协议 (RPC)</h2><p>HDFS 内部各组件通过 RPC (Remote Procedure Call) 交互。Hadoop 有一套自己的 RPC 框架（基于 Protobuf）。<p>主要的 Protocol 接口定义在 <code>hadoop-hdfs-client</code> 和 <code>hadoop-hdfs</code> 模块中：<ol><li><strong>ClientProtocol</strong>: Client &lt;-> NameNode。 <ul><li>方法: <code>create</code>, <code>open</code>, <code>mkdir</code>, <code>getBlockLocations</code>, <code>renewLease</code> 等。</ul><li><strong>ClientDatanodeProtocol</strong>: Client &lt;-> DataNode。 <ul><li>方法: <code>recoverBlock</code>, <code>getReplicaVisibleLength</code>。<li><em>注意</em>: 真正的数据读写不走 RPC，而是流式接口 (Data Transfer Protocol)。</ul><li><strong>DatanodeProtocol</strong>: DataNode &lt;-> NameNode。 <ul><li>方法: <code>registerDatanode</code>, <code>sendHeartbeat</code>, <code>blockReport</code>。</ul><li><strong>InterDatanodeProtocol</strong>: DataNode &lt;-> DataNode。 <ul><li>用于数据块恢复 (Block Recovery) 和更新副本。</ul></ol><h2 id=4-shu-ju-liu-vs-kong-zhi-liu>4. 数据流 vs 控制流</h2><ul><li><strong>控制流 (Control Flow)</strong>: 走 RPC。如 Client 问 NameNode “文件 A 的 Block 在哪？”。<li><strong>数据流 (Data Flow)</strong>: 走 TCP 流 (Netty)。如 Client 直接连接 DataNode 写入数据。</ul><p>这种分离设计保证了 NameNode 不会成为数据传输的瓶颈。<h2 id=5-xia-yi-bu>5. 下一步</h2><p>了解了架构图后，我们将从 NameNode 的启动流程开始，看看这个庞大的 Master 是如何被唤醒的。</div></div></section>