<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>HDFS 源码阅读：11. 数据传输协议 (DataTransferProtocol) | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/hdfs/> /hdfs </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-22</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">HDFS 源码阅读：11. 数据传输协议 (DataTransferProtocol)</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>RPC 用于传输元数据，而真正海量的数据传输走的是 <strong>Data Transfer Protocol</strong>。这是一个基于 TCP 的流式协议。<h2 id=1-xie-yi-gai-lan>1. 协议概览</h2><p>Client 或 DataNode 连接目标 DataNode 的 Data Port (9866)，发送一个 Header，包含：<ul><li><strong>Version</strong>: 协议版本。<li><strong>OpCode</strong>: 操作类型。 <ul><li><code>OP_WRITE_BLOCK</code> (80): 写入 Block。<li><code>OP_READ_BLOCK</code> (81): 读取 Block。<li><code>OP_READ_METADATA</code> (82): 读取 Checksum 文件。<li><code>OP_REPLACE_BLOCK</code> (83): 副本复制/均衡。<li><code>OP_COPY_BLOCK</code> (84): 同上。<li><code>OP_BLOCK_CHECKSUM</code> (85): 获取 Block 校验和。</ul></ul><h2 id=2-dataxceiverserver-dataxceiver>2. DataXceiverServer & DataXceiver</h2><p>DataNode 启动一个 <code>DataXceiverServer</code>（通常基于 <code>java.nio</code> 或 Netty），监听端口。<p>每当有一个连接进来，就创建一个 <code>DataXceiver</code> (Receiver + Transceiver) 线程（或 Task）来处理。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#616e88>// DataXceiver.java</span></span>
<span class=giallo-l><span style=color:#81a1c1>public void</span><span style=color:#88c0d0> run</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#616e88>    // 读取 OpCode</span></span>
<span class=giallo-l><span>    op </span><span style=color:#81a1c1>=</span><span style=color:#88c0d0> readOp</span><span style=color:#eceff4>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    switch</span><span style=color:#eceff4> (</span><span>op</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>        case</span><span> OP_READ_BLOCK</span><span style=color:#81a1c1>:</span></span>
<span class=giallo-l><span style=color:#88c0d0>            readBlock</span><span style=color:#eceff4>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>            break;</span></span>
<span class=giallo-l><span style=color:#81a1c1>        case</span><span> OP_WRITE_BLOCK</span><span style=color:#81a1c1>:</span></span>
<span class=giallo-l><span style=color:#88c0d0>            writeBlock</span><span style=color:#eceff4>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>            break;</span></span>
<span class=giallo-l><span style=color:#616e88>        // ...</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><h2 id=3-blockreceiver-xie-ru>3. BlockReceiver (写入)</h2><p>当处理 <code>OP_WRITE_BLOCK</code> 时，DataNode 会创建 <code>BlockReceiver</code>。<ul><li><strong>Pipeline</strong>: Client -> DN1 -> DN2 -> DN3。<li><strong>Packet</strong>: 数据被切分成 Packet (默认 64KB)。<li><strong>流程</strong>: <ol><li>DN1 收到 Packet，写入本地磁盘。<li>同时将 Packet 转发给 DN2。<li>DN2 转发给 DN3。<li>DN3 写完后，发送 Ack 给 DN2。<li>DN2 收到 Ack 后，发送 Ack 给 DN1。<li>DN1 发送 Ack 给 Client。</ol></ul><p>这种流水线机制使得延时是线性的，但吞吐量是并行的（受限于最慢的节点）。<h2 id=4-blocksender-du-qu>4. BlockSender (读取)</h2><p>当处理 <code>OP_READ_BLOCK</code> 时，DataNode 会创建 <code>BlockSender</code>。<ul><li>利用 <code>java.nio.channels.FileChannel.transferTo</code> (零拷贝) 将磁盘文件直接发送到 Socket，极大提高了读取性能。<li>同时发送数据和 Checksum，客户端边收边校验。</ul><h2 id=5-duan-lu-du-short-circuit-read>5. 短路读 (Short Circuit Read)</h2><p>如果 Client 和 DataNode 在同一台机器上，通过 TCP 读数据太慢了。 HDFS 支持 <strong>Short Circuit Read</strong>：Client 直接通过 UNIX Domain Socket 获取文件描述符 (File Descriptor)，绕过 DataNode 进程直接读取本地文件。<h2 id=6-zong-jie>6. 总结</h2><p>DataTransferProtocol 是 HDFS 吞吐量的关键。理解 Pipeline 和 Packet 机制对于排查写入慢的问题至关重要。</div></div></section>