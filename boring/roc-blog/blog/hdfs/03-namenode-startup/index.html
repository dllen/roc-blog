<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>HDFS 源码阅读：03. NameNode 启动流程 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/hdfs/> /hdfs </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-14</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">HDFS 源码阅读：03. NameNode 启动流程</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>NameNode 是 HDFS 的大脑，它的启动过程决定了整个集群何时可用。<h2 id=1-ru-kou-namenode-main>1. 入口：NameNode.main()</h2><p>一切始于 <code>org.apache.hadoop.hdfs.server.namenode.NameNode</code> 类的 <code>main</code> 方法。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>public static void</span><span style=color:#88c0d0> main</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>String</span><span> argv</span><span style=color:#eceff4>[])</span><span> throws Exception </span><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span style=color:#eceff4> (</span><span>DFSUtil</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>parseHelpArgument</span><span style=color:#eceff4>(</span><span>argv</span><span style=color:#eceff4>,</span><span> NameNode</span><span style=color:#eceff4>.</span><span>USAGE</span><span style=color:#eceff4>,</span><span> System</span><span style=color:#eceff4>.</span><span>out</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> true</span><span style=color:#eceff4>)) {</span></span>
<span class=giallo-l><span>        System</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>exit</span><span style=color:#eceff4>(</span><span style=color:#b48ead>0</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#81a1c1>    try</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>        StringUtils</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>startupShutdownMessage</span><span style=color:#eceff4>(</span><span>NameNode</span><span style=color:#eceff4>.</span><span>class</span><span style=color:#eceff4>,</span><span> argv</span><span style=color:#eceff4>,</span><span> LOG</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#8fbcbb>        NameNode</span><span> namenode</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> createNameNode</span><span style=color:#eceff4>(</span><span>argv</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> null</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 核心</span></span>
<span class=giallo-l><span style=color:#81a1c1>        if</span><span style=color:#eceff4> (</span><span>namenode </span><span style=color:#81a1c1>!= null</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span>            namenode</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>join</span><span style=color:#eceff4>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>        }</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span><span style=color:#81a1c1> catch</span><span style=color:#eceff4> (</span><span style=color:#8fbcbb>Throwable</span><span> e</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#616e88>        // ... Error handling</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p><code>createNameNode</code> 方法会解析命令行参数（如 <code>-format</code>, <code>-recover</code>, <code>-upgrade</code>），如果只是正常启动，最终会调用 <code>new NameNode(conf)</code>。<h2 id=2-chu-shi-hua-he-xin-zu-jian-initialize>2. 初始化核心组件 (initialize)</h2><p>在构造函数中，核心逻辑都在 <code>initialize(conf)</code> 方法里。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>protected void</span><span style=color:#88c0d0> initialize</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>Configuration</span><span> conf</span><span style=color:#eceff4>)</span><span> throws IOException </span><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span style=color:#616e88>    // 1. 设置登录用户 (Kerberos)</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span style=color:#eceff4> (</span><span>UserGroupInformation</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>isSecurityEnabled</span><span style=color:#eceff4>()) {</span></span>
<span class=giallo-l><span>        SecurityUtil</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>login</span><span style=color:#eceff4>(</span><span>conf</span><span style=color:#eceff4>,</span><span> DFS_NAMENODE_KEYTAB_FILE_KEY</span><span style=color:#eceff4>, ...)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span style=color:#616e88>    // 2. 启动 HTTP Server (Web UI: 9870)</span></span>
<span class=giallo-l><span style=color:#88c0d0>    startHttpServer</span><span style=color:#eceff4>(</span><span>conf</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span style=color:#616e88>    // 3. 加载元数据 (重点)</span></span>
<span class=giallo-l><span style=color:#88c0d0>    loadNamesystem</span><span style=color:#eceff4>(</span><span>conf</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span style=color:#616e88>    // 4. 创建 RPC Server (ClientRPC: 9820, ServiceRPC: 8020)</span></span>
<span class=giallo-l><span>    rpcServer </span><span style=color:#81a1c1>=</span><span style=color:#88c0d0> createRpcServer</span><span style=color:#eceff4>(</span><span>conf</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span style=color:#616e88>    // 5. 启动公共服务 (JvmPauseMonitor, MetricsSystem)</span></span>
<span class=giallo-l><span style=color:#88c0d0>    startCommonServices</span><span style=color:#eceff4>(</span><span>conf</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span style=color:#616e88>    // 6. 启动 NameNode 只有在 SafeMode 退出后才做的服务</span></span>
<span class=giallo-l><span style=color:#88c0d0>    startActiveServices</span><span style=color:#eceff4>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><h2 id=3-jia-zai-yuan-shu-ju-fsnamesystem-loadfromdisk>3. 加载元数据 (FSNamesystem.loadFromDisk)</h2><p><code>loadNamesystem</code> 会创建 <code>FSNamesystem</code> 对象，并调用其 <code>loadFromDisk</code> 方法。这是启动过程中最耗时的步骤。<ol><li><strong>加载 FSImage</strong>: 读取最新的 Checkpoint 文件，恢复内存中的 <code>INode</code> 树。<li><strong>回放 EditLog</strong>: 读取 FSImage 之后的 EditLog，将操作重做到内存树上。<li><strong>保存新 Image (可选)</strong>: 如果配置了 <code>dfs.namenode.checkpoint.check.user.provider</code> 等，可能会触发。</ol><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#616e88>// FSImage.java</span></span>
<span class=giallo-l><span style=color:#81a1c1>long</span><span style=color:#88c0d0> loadFSImage</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>File</span><span> curFile</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> StartupOption</span><span> startOpt</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> MetaRecoveryContext</span><span> recovery</span><span style=color:#eceff4>)</span><span> throws IOException </span><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span style=color:#616e88>    // Protocol Buffers 反序列化</span></span>
<span class=giallo-l><span style=color:#8fbcbb>    FSImageFormatProtobuf</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>Loader</span><span> loader</span><span style=color:#81a1c1> = new</span><span> FSImageFormatProtobuf</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>Loader</span><span style=color:#eceff4>(</span><span>conf</span><span style=color:#eceff4>,</span><span> namesystem</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>    loader</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>load</span><span style=color:#eceff4>(</span><span>curFile</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><h2 id=4-qi-dong-rpc-fu-wu>4. 启动 RPC 服务</h2><p>NameNode 通常启动两个 RPC Server：<ol><li><strong>ServiceRpcServer</strong>: 专门处理 DataNode 的心跳、块汇报等请求。避免 Client 流量把 DataNode 挤掉。<li><strong>ClientRpcServer</strong>: 处理 Client 的 <code>ls</code>, <code>mkdir</code> 等请求。</ol><h2 id=5-jin-ru-an-quan-mo-shi-safemode>5. 进入安全模式 (SafeMode)</h2><p>启动初期，NameNode 内存中虽然有了文件目录树，但<strong>没有 Block 的位置信息</strong>（BlockMap 是空的）。<p>Block 的位置信息不会持久化在磁盘，必须等 DataNode 启动并汇报。<p>因此，NameNode 启动后自动进入 <strong>SafeMode</strong>（只读模式）：<ol><li>等待 DataNode 汇报 Block。<li>统计已汇报的 Block 比例（默认阈值 99.9%）。<li>达到阈值后，再等待 30 秒（<code>dfs.namenode.safemode.extension</code>），然后退出 SafeMode。</ol><h2 id=6-zong-jie>6. 总结</h2><p>NameNode 启动不仅是加载磁盘数据，更依赖于全网 DataNode 的参与来重建完整的元数据视图。</div></div></section>