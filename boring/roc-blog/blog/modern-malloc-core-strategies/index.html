<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>现代 malloc 库核心内存管理策略 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2025-12-26</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">现代 malloc 库核心内存管理策略</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>内存分配器（Memory Allocator）是所有非托管语言（如 C/C++、Rust）程序的基石，也是许多托管语言（如 Java、Go）运行时的底层依赖。随着多核处理器的普及和云计算场景下对高并发、低延迟的极致追求，传统的 glibc <code>ptmalloc</code> 在某些场景下逐渐显露出扩展性不足和碎片化的问题。<p>本文将深入探讨现代主流 malloc 库（如 jemalloc、tcmalloc、mimalloc）背后的核心内存管理策略，看看它们是如何在速度、空间利用率和多线程扩展性之间找到平衡的。<h2 id=1-wei-shen-me-wo-men-xu-yao-xian-dai-fen-pei-qi>1. 为什么我们需要现代分配器？</h2><p>在单核时代，内存分配主要关注的是“如何找到一块大小合适的空闲内存”以及“如何减少碎片”。但在多核高并发时代，<strong>锁竞争（Lock Contention）</strong> 成为了性能杀手。<p><code>ptmalloc</code> 虽然引入了 per-thread arenas 来减少竞争，但在极高并发下，频繁的锁操作和缓存一致性流量（Cache Coherence Traffic）依然会导致显著的性能下降。此外，随着内存容量的增加，内存碎片（Fragmentation）带来的空间浪费成本也越来越高。<p>现代分配器（Modern Allocators）通常致力于解决以下三个核心问题：<ol><li><strong>多线程扩展性</strong>：在分配和释放的“快路径”上尽可能做到无锁（Lock-free）。<li><strong>缓存局部性（Cache Locality）</strong>：让连续分配的对象在物理内存上也尽可能连续，提高 CPU 缓存命中率。<li><strong>内存利用率</strong>：通过精细的 Size Class 划分和及时的内存归还策略，降低碎片率和 RSS（Resident Set Size）。</ol><h2 id=2-he-xin-she-ji-ce-lue>2. 核心设计策略</h2><p>尽管 jemalloc、tcmalloc 和 mimalloc 的具体实现细节不同，但它们在宏观架构上惊人地相似。我们可以将其归纳为以下几个通用策略：<h3 id=2-1-thread-local-cache-tlc-xiao-chu-suo-jing-zheng>2.1 Thread Local Cache (TLC) —— 消除锁竞争</h3><p>这是现代分配器最重要的优化手段。每个线程都维护一份私有的缓存（Thread Local Cache），用于满足绝大多数的小对象分配需求。<ul><li><strong>分配（Malloc）</strong>：线程直接从自己的 TLC 中获取内存块，无需加锁，仅需简单的指针操作。这是“快路径”。<li><strong>释放（Free）</strong>：如果对象属于当前线程管理，直接放回 TLC，同样无需加锁。</ul><p>只有当 TLC 耗尽（需要从全局获取）或 TLC 塞满（需要归还给全局）时，才会进入“慢路径”，涉及到全局锁或原子操作。<h3 id=2-2-size-classes-ge-chi-yu-dui-qi>2.2 Size Classes —— 隔离与对齐</h3><p>为了避免外碎片（External Fragmentation）并简化管理，分配器不会按用户请求的任意字节数分配，而是将大小向上取整到最近的 <strong>Size Class</strong>。<p>例如，请求 12 字节，可能会分配 16 字节（属于 16-byte class）；请求 40 字节，分配 48 字节。<ul><li><strong>Segregated Free Lists（隔离空闲链表）</strong>：每个 Size Class 都有自己独立的空闲链表。分配时只需从对应链表头部取下一个节点即可，复杂度为 O(1)。<li><strong>减少元数据开销</strong>：同属一个 Page/Block 的对象通常大小相同，因此不需要在每个对象头部存储大小信息（Header），通过地址偏移即可计算出所属的 Size Class。</ul><h3 id=2-3-duo-ji-huan-cun-jia-gou-hierarchical-caching>2.3 多级缓存架构 (Hierarchical Caching)</h3><p>为了在“独占”与“共享”之间取得平衡，现代分配器通常采用三级架构：<ol><li><strong>Thread Local Cache</strong>：第一级，完全无锁，速度最快。<li><strong>Central Cache / Arena</strong>：第二级，共享资源。当 TLC 不足时，从这里批量获取对象；当 TLC 过大时，将对象批量归还于此。通常需要加锁（或使用细粒度锁）。<li><strong>Page Heap</strong>：第三级，直接管理操作系统的大块内存（Pages/Spans）。当 Central Cache 不足时，向 Page Heap 申请新的页；当内存长期空闲时，将页归还给 OS。</ol><h3 id=2-4-page-guan-li-yu-span>2.4 Page 管理与 Span</h3><p>分配器通常以 <strong>Page</strong>（通常是 4KB 或更大）的倍数向 OS 申请内存。多个连续的 Page 组成一个 <strong>Span</strong>（或 Run）。<p>一个 Span 通常被切割成多个相同大小的小对象（属于同一个 Size Class）。这种设计使得分配器可以很容易地判断一个指针属于哪个 Span，进而知道它的大小和状态。<h2 id=3-zhu-liu-fen-pei-qi-an-li-fen-xi>3. 主流分配器案例分析</h2><h3 id=3-1-tcmalloc-google>3.1 tcmalloc (Google)</h3><p><strong>tcmalloc (Thread-Caching Malloc)</strong> 是现代分配器架构的奠基者之一。<ul><li><strong>架构</strong>：Thread Cache -> Central Cache -> Page Heap。<li><strong>特点</strong>： <ul><li><strong>小对象</strong>：通过 Thread Cache 分配，无锁。<li><strong>中对象</strong>：直接从 Page Heap 分配 Span。<li><strong>Span 管理</strong>：使用 Radix Tree 将地址映射到 Span 元数据，查找速度快。</ul><li><strong>优势</strong>：非常适合多线程环境，性能稳定，被广泛用于 C++ 服务端开发。</ul><h3 id=3-2-jemalloc-freebsd-facebook>3.2 jemalloc (FreeBSD, Facebook)</h3><p><strong>jemalloc</strong> 最初为 FreeBSD 开发，后被 Firefox、Facebook、Rust（曾用）等广泛采用。它在减少内存碎片方面表现优异。<ul><li><strong>核心概念</strong>： <ul><li><strong>Arena</strong>：为了减少锁竞争，jemalloc 将内存划分为多个 Arena，每个线程绑定一个 Arena。<li><strong>Chunk/Run/Region</strong>：内存分层管理。Chunk 是大块内存，Run 是 Chunk 中的一部分，Region 是分配给用户的小对象。<li><strong>Decay</strong>：jemalloc 有非常智能的脏页清理（Decay）机制，能够平滑地将不再使用的 dirty pages 归还给 OS，避免 RSS 暴涨。</ul><li><strong>优势</strong>：在长时间运行的服务中，内存碎片控制得非常好，且具备强大的 Profiling 功能（jeprof）。</ul><h3 id=3-3-mimalloc-microsoft>3.3 mimalloc (Microsoft)</h3><p><strong>mimalloc</strong> 是微软研究院推出的新一代分配器，以极致的性能和安全性著称。<ul><li><strong>创新点</strong>： <ul><li><strong>Free List Sharding</strong>：它不仅有 Thread Local allocation，还支持 <strong>Thread Local free</strong>。即使是其他线程释放了当前线程分配的内存，也不会产生复杂的锁竞争，而是放入一个特定的“分片”队列中。<li><strong>Mimalloc Pages</strong>：它将 Page 的元数据直接存储在 Page 的头部，利用对齐特性快速访问，减少了 cache miss。</ul><li><strong>优势</strong>：在许多 benchmark 中性能超越 jemalloc 和 tcmalloc，且代码库相对精简，易于集成。</ul><h2 id=4-kuai-su-shang-shou-demo>4. 快速上手 Demo</h2><p>大多数情况下，使用这些现代分配器<strong>不需要修改任何业务代码</strong>。你只需要在编译时链接相应的库，或者在运行时通过 <code>LD_PRELOAD</code> 环境变量进行替换即可。<p>以下是一个简单的 C++ 测试程序 <code>main.cpp</code>，我们将用它来演示如何切换不同的分配器：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=cpp><span class=giallo-l><span style=color:#5e81ac;font-weight:700>#</span><span style=color:#81a1c1>include</span><span style=color:#eceff4> &lt;</span><span style=color:#a3be8c>iostream</span><span style=color:#eceff4>></span></span>
<span class=giallo-l><span style=color:#5e81ac;font-weight:700>#</span><span style=color:#81a1c1>include</span><span style=color:#eceff4> &lt;</span><span style=color:#a3be8c>vector</span><span style=color:#eceff4>></span></span>
<span class=giallo-l><span style=color:#5e81ac;font-weight:700>#</span><span style=color:#81a1c1>include</span><span style=color:#eceff4> &lt;</span><span style=color:#a3be8c>thread</span><span style=color:#eceff4>></span></span>
<span class=giallo-l><span style=color:#5e81ac;font-weight:700>#</span><span style=color:#81a1c1>include</span><span style=color:#eceff4> &lt;</span><span style=color:#a3be8c>chrono</span><span style=color:#eceff4>></span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>void</span><span style=color:#88c0d0> stress_test</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    for</span><span style=color:#eceff4> (</span><span style=color:#81a1c1>int</span><span> i </span><span style=color:#81a1c1>=</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1>;</span><span> i </span><span style=color:#81a1c1>&lt;</span><span style=color:#b48ead> 100000</span><span style=color:#81a1c1>; ++</span><span>i</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span>        std</span><span style=color:#eceff4>::</span><span>vector</span><span style=color:#81a1c1>&lt;int></span><span style=color:#88c0d0> v</span><span style=color:#eceff4>(</span><span style=color:#b48ead>1000</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 频繁分配与释放</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>int</span><span style=color:#88c0d0> main</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    auto</span><span> start </span><span style=color:#81a1c1>=</span><span> std</span><span style=color:#eceff4>::</span><span>chrono</span><span style=color:#eceff4>::</span><span>high_resolution_clock</span><span style=color:#eceff4>::</span><span style=color:#88c0d0>now</span><span style=color:#eceff4>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span>    std</span><span style=color:#eceff4>::</span><span>vector</span><span style=color:#81a1c1>&lt;</span><span>std</span><span style=color:#eceff4>::</span><span>thread</span><span style=color:#81a1c1>></span><span> threads</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    for</span><span style=color:#eceff4> (</span><span style=color:#81a1c1>int</span><span> i </span><span style=color:#81a1c1>=</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1>;</span><span> i </span><span style=color:#81a1c1>&lt;</span><span style=color:#b48ead> 8</span><span style=color:#81a1c1>; ++</span><span>i</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span>        threads</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>emplace_back</span><span style=color:#eceff4>(</span><span>stress_test</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span style=color:#81a1c1>    for</span><span style=color:#eceff4> (</span><span style=color:#81a1c1>auto&</span><span> t </span><span style=color:#eceff4>:</span><span> threads</span><span style=color:#eceff4>)</span><span> t</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>join</span><span style=color:#eceff4>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span style=color:#81a1c1>    auto</span><span> end </span><span style=color:#81a1c1>=</span><span> std</span><span style=color:#eceff4>::</span><span>chrono</span><span style=color:#eceff4>::</span><span>high_resolution_clock</span><span style=color:#eceff4>::</span><span style=color:#88c0d0>now</span><span style=color:#eceff4>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>    std</span><span style=color:#eceff4>::</span><span>chrono</span><span style=color:#eceff4>::</span><span>duration</span><span style=color:#81a1c1>&lt;double></span><span> diff </span><span style=color:#81a1c1>=</span><span> end </span><span style=color:#81a1c1>-</span><span> start</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span>    std</span><span style=color:#eceff4>::</span><span>cout </span><span style=color:#81a1c1>&lt;&lt;</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>Time taken: </span><span style=color:#eceff4>"</span><span style=color:#81a1c1> &lt;&lt;</span><span> diff</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>count</span><span style=color:#eceff4>()</span><span style=color:#81a1c1> &lt;&lt;</span><span style=color:#eceff4> "</span><span style=color:#a3be8c> s</span><span style=color:#eceff4>"</span><span style=color:#81a1c1> &lt;&lt;</span><span> std</span><span style=color:#eceff4>::</span><span>endl</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><h3 id=4-1-shi-yong-tcmalloc-gperftools>4.1 使用 tcmalloc (gperftools)</h3><p><strong>安装</strong>：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#616e88># Ubuntu/Debian</span></span>
<span class=giallo-l><span style=color:#88c0d0>sudo</span><span style=color:#a3be8c> apt-get install google-perftools libgoogle-perftools-dev</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88># macOS</span></span>
<span class=giallo-l><span style=color:#88c0d0>brew</span><span style=color:#a3be8c> install gperftools</span></span></code></pre><p><strong>运行方式 1：LD_PRELOAD (无需重新编译)</strong><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#616e88># Linux 示例路径</span></span>
<span class=giallo-l><span>LD_PRELOAD</span><span style=color:#81a1c1>=</span><span style=color:#a3be8c>/usr/lib/x86_64-linux-gnu/libtcmalloc.so.4</span><span style=color:#88c0d0> ./main</span></span></code></pre><p><strong>运行方式 2：编译链接</strong><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>g++</span><span style=color:#a3be8c> main.cpp -o main -ltcmalloc</span></span>
<span class=giallo-l><span style=color:#88c0d0>./main</span></span></code></pre><h3 id=4-2-shi-yong-jemalloc>4.2 使用 jemalloc</h3><p><strong>安装</strong>：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#616e88># Ubuntu/Debian</span></span>
<span class=giallo-l><span style=color:#88c0d0>sudo</span><span style=color:#a3be8c> apt-get install libjemalloc-dev</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88># macOS</span></span>
<span class=giallo-l><span style=color:#88c0d0>brew</span><span style=color:#a3be8c> install jemalloc</span></span></code></pre><p><strong>运行方式 1：LD_PRELOAD</strong><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#616e88># Linux 示例路径</span></span>
<span class=giallo-l><span>LD_PRELOAD</span><span style=color:#81a1c1>=</span><span style=color:#a3be8c>/usr/lib/x86_64-linux-gnu/libjemalloc.so.2</span><span style=color:#88c0d0> ./main</span></span></code></pre><p><strong>运行方式 2：编译链接</strong><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>g++</span><span style=color:#a3be8c> main.cpp -o main -ljemalloc</span></span>
<span class=giallo-l><span style=color:#88c0d0>./main</span></span></code></pre><p><strong>进阶：打印内存统计信息</strong> jemalloc 提供了强大的自省功能。你可以在代码中调用 <code>malloc_stats_print</code>（需要包含 <code>&lt;jemalloc/jemalloc.h></code> 并链接库）：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=cpp><span class=giallo-l><span style=color:#616e88>// 在程序结束前调用，将统计信息输出到 stderr</span></span>
<span class=giallo-l><span style=color:#616e88>// malloc_stats_print(NULL, NULL, NULL); </span></span></code></pre><h3 id=4-3-shi-yong-mimalloc>4.3 使用 mimalloc</h3><p><strong>安装</strong>：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#616e88># 源码编译安装或使用包管理器 (archlinux 等)</span></span>
<span class=giallo-l><span style=color:#88c0d0>git</span><span style=color:#a3be8c> clone https://github.com/microsoft/mimalloc</span></span>
<span class=giallo-l><span style=color:#88c0d0>cd</span><span style=color:#a3be8c> mimalloc</span><span style=color:#eceff4> &&</span><span style=color:#88c0d0> mkdir</span><span style=color:#a3be8c> build</span><span style=color:#eceff4> &&</span><span style=color:#88c0d0> cd</span><span style=color:#a3be8c> build</span></span>
<span class=giallo-l><span style=color:#88c0d0>cmake</span><span style=color:#a3be8c> ..</span><span style=color:#eceff4> &&</span><span style=color:#88c0d0> make</span><span style=color:#eceff4> &&</span><span style=color:#88c0d0> sudo</span><span style=color:#a3be8c> make install</span></span></code></pre><p><strong>运行方式 1：LD_PRELOAD</strong><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#616e88># mimalloc 提供了方便的覆盖动态库</span></span>
<span class=giallo-l><span>LD_PRELOAD</span><span style=color:#81a1c1>=</span><span style=color:#a3be8c>/usr/local/lib/libmimalloc.so</span><span style=color:#88c0d0> ./main</span></span></code></pre><p><strong>运行方式 2：编译链接</strong><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>g++</span><span style=color:#a3be8c> main.cpp -o main -lmimalloc</span></span>
<span class=giallo-l><span style=color:#88c0d0>./main</span></span></code></pre><h2 id=5-zong-jie-yu-xuan-xing-jian-yi>5. 总结与选型建议</h2><table><thead><tr><th style=text-align:left>特性<th style=text-align:left>glibc (ptmalloc)<th style=text-align:left>tcmalloc<th style=text-align:left>jemalloc<th style=text-align:left>mimalloc<tbody><tr><td style=text-align:left><strong>设计目标</strong><td style=text-align:left>通用性、兼容性<td style=text-align:left>高并发吞吐<td style=text-align:left>低碎片、低延迟<td style=text-align:left>极致性能、安全<tr><td style=text-align:left><strong>核心机制</strong><td style=text-align:left>Per-thread arenas<td style=text-align:left>Thread Cache + Central Heap<td style=text-align:left>Arenas + Decay<td style=text-align:left>Free List Sharding<tr><td style=text-align:left><strong>碎片控制</strong><td style=text-align:left>一般<td style=text-align:left>较好<td style=text-align:left><strong>优秀</strong><td style=text-align:left>优秀<tr><td style=text-align:left><strong>适用场景</strong><td style=text-align:left>默认系统环境<td style=text-align:left>高频小对象分配<td style=text-align:left>内存敏感型服务 (如 Redis)<td style=text-align:left>新兴高性能项目</table><p>对于大多数应用程序，<strong>jemalloc</strong> 目前是一个非常均衡且成熟的选择，特别是当你关注长期运行服务的内存占用时（Redis 默认就使用 jemalloc）。如果你追求极致的吞吐量或者正在开发新的高性能组件，<strong>mimalloc</strong> 值得一试。而 <strong>tcmalloc</strong> 依然是许多 C++ 大型系统的稳健之选。<p>理解这些底层策略，不仅有助于我们选择合适的库，更能帮助我们在编写高性能代码时，更有意识地规划内存的使用模式。</div></div></section>