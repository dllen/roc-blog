<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>1brc CalculateAverage_thomaswue 代码解读 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2025-09-01</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">1brc CalculateAverage_thomaswue 代码解读</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>这是一个高性能的Java程序，用于解决“1 Billion Row Challenge“（十亿行挑战）问题。该程序专门用于快速处理大量温度测量数据。详细解读：<h2 id=cheng-xu-zheng-ti-jia-gou>程序整体架构</h2><h3 id=1-duo-jin-cheng-she-ji>1. 多进程设计</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>private static void</span><span style=color:#88c0d0> spawnWorker</span><span style=color:#eceff4>()</span><span> throws IOException </span><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span style=color:#616e88>    // 启动工作子进程，主进程负责启动和收集结果</span></span>
<span class=giallo-l><span style=color:#616e88>    // 子进程负责实际的数据处理工作</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><ul><li>使用子进程处理数据，主进程快速返回结果<li>避免内存映射清理延迟问题</ul><h3 id=2-bing-xing-chu-li-ce-lue>2. 并行处理策略</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>int</span><span> numberOfWorkers</span><span style=color:#81a1c1> =</span><span> Runtime</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>getRuntime</span><span style=color:#eceff4>().</span><span style=color:#88c0d0>availableProcessors</span><span style=color:#eceff4>()</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#616e88>// 每个CPU核心创建一个工作线程</span></span></code></pre><h2 id=he-xin-you-hua-ji-shu>核心优化技术</h2><h3 id=1-nei-cun-ying-she-unsafecao-zuo>1. 内存映射 + Unsafe操作</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>final long</span><span> fileStart</span><span style=color:#81a1c1> =</span><span> fileChannel</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>map</span><span style=color:#eceff4>(</span><span>FileChannel</span><span style=color:#eceff4>.</span><span>MapMode</span><span style=color:#eceff4>.</span><span>READ_ONLY</span><span style=color:#eceff4>,</span><span style=color:#b48ead> 0</span><span style=color:#eceff4>,</span><span> fileSize</span><span style=color:#eceff4>,</span><span> </span></span>
<span class=giallo-l><span>    java</span><span style=color:#eceff4>.</span><span>lang</span><span style=color:#eceff4>.</span><span>foreign</span><span style=color:#eceff4>.</span><span>Arena</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>global</span><span style=color:#eceff4>()).</span><span style=color:#88c0d0>address</span><span style=color:#eceff4>()</span><span style=color:#81a1c1>;</span></span></code></pre><ul><li>直接内存映射文件，避免传统IO开销<li>使用<code>sun.misc.Unsafe</code>进行底层内存操作</ul><h3 id=2-fen-duan-bing-xing-chu-li>2. 分段并行处理</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>private static final int</span><span> SEGMENT_SIZE</span><span style=color:#81a1c1> =</span><span style=color:#b48ead> 1</span><span style=color:#81a1c1> &lt;&lt;</span><span style=color:#b48ead> 21</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 2MB段</span></span></code></pre><ul><li>将文件分成2MB的段<li>使用工作窃取模式而非简单的平均分配</ul><h3 id=3-san-lu-bing-xing-sao-miao>3. 三路并行扫描</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>long</span><span> dist</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> (</span><span>segmentEnd </span><span style=color:#81a1c1>-</span><span> segmentStart</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> /</span><span style=color:#b48ead> 3</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#8fbcbb>Scanner</span><span> scanner1</span><span style=color:#81a1c1> = new</span><span style=color:#88c0d0> Scanner</span><span style=color:#eceff4>(</span><span>segmentStart</span><span style=color:#eceff4>,</span><span> midPoint1</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#8fbcbb>Scanner</span><span> scanner2</span><span style=color:#81a1c1> = new</span><span style=color:#88c0d0> Scanner</span><span style=color:#eceff4>(</span><span>midPoint1 </span><span style=color:#81a1c1>+</span><span style=color:#b48ead> 1</span><span style=color:#eceff4>,</span><span> midPoint2</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#8fbcbb>Scanner</span><span> scanner3</span><span style=color:#81a1c1> = new</span><span style=color:#88c0d0> Scanner</span><span style=color:#eceff4>(</span><span>midPoint2 </span><span style=color:#81a1c1>+</span><span style=color:#b48ead> 1</span><span style=color:#eceff4>,</span><span> segmentEnd</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span></code></pre><ul><li>每个段内部再分成3部分，同时处理<li>提高单线程内的并行度</ul><h3 id=4-wu-fen-zhi-shu-zi-jie-xi>4. 无分支数字解析</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>private static long</span><span style=color:#88c0d0> convertIntoNumber</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>int</span><span> decimalSepPos</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> long</span><span> numberWord</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#616e88>    // Quan Anh Mai的无分支数字解析算法</span></span>
<span class=giallo-l><span style=color:#616e88>    // 避免条件分支导致的CPU流水线停顿</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><h3 id=5-wei-cao-zuo-you-hua-de-fen-ge-fu-cha-zhao>5. 位操作优化的分隔符查找</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>private static long</span><span style=color:#88c0d0> findDelimiter</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>long</span><span> word</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    long</span><span> input</span><span style=color:#81a1c1> =</span><span> word </span><span style=color:#81a1c1>^</span><span style=color:#b48ead> 0x3B3B3B3B3B3B3B3BL</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 查找';'字符</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span style=color:#eceff4> (</span><span>input </span><span style=color:#81a1c1>-</span><span style=color:#b48ead> 0x0101010101010101L</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> & ~</span><span>input </span><span style=color:#81a1c1>&</span><span style=color:#b48ead> 0x8080808080808080L</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><ul><li>一次操作可以在8个字节中查找分隔符<li>避免逐字节比较</ul><h3 id=6-gao-xiao-ha-xi-biao>6. 高效哈希表</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>private static final int</span><span> HASH_TABLE_SIZE</span><span style=color:#81a1c1> =</span><span style=color:#b48ead> 1</span><span style=color:#81a1c1> &lt;&lt;</span><span style=color:#b48ead> 17</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 128K</span></span></code></pre><ul><li>使用开放寻址法处理哈希冲突<li>针对城市名称优化的哈希函数</ul><h3 id=7-zi-fu-chuan-bi-jiao-you-hua>7. 字符串比较优化</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#616e88>// 直接比较内存中的long值而非字符串</span></span>
<span class=giallo-l><span style=color:#81a1c1>if</span><span style=color:#eceff4> (</span><span>existingResult</span><span style=color:#eceff4>.</span><span>firstNameWord</span><span style=color:#81a1c1> ==</span><span> word </span><span style=color:#81a1c1>&&</span><span> existingResult</span><span style=color:#eceff4>.</span><span>secondNameWord</span><span style=color:#81a1c1> ==</span><span> word2</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span> existingResult</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><h2 id=xing-neng-te-dian>性能特点</h2><h3 id=chu-li-su-du>处理速度</h3><ul><li>在Intel i9-13900K上运行时间：0.31秒<li>相比参考实现的120.37秒，提升约388倍</ul><h3 id=guan-jian-you-hua-lai-yuan>关键优化来源</h3><ol><li><strong>内存映射</strong> - 消除文件IO开销<li><strong>SIMD式处理</strong> - 8字节批量操作<li><strong>无分支算法</strong> - 避免CPU分支预测失败<li><strong>多级并行</strong> - 进程+线程+段内并行<li><strong>缓存友好</strong> - 连续内存访问模式</ol><h2 id=shu-ju-jie-gou>数据结构</h2><h3 id=resultlei>Result类</h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=java><span class=giallo-l><span style=color:#81a1c1>private static final class</span><span style=color:#8fbcbb> Result</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    long</span><span> firstNameWord</span><span style=color:#eceff4>,</span><span> secondNameWord</span><span style=color:#81a1c1>;</span><span style=color:#616e88> // 城市名前16字节</span></span>
<span class=giallo-l><span style=color:#81a1c1>    short</span><span> min</span><span style=color:#eceff4>,</span><span> max</span><span style=color:#81a1c1>;</span><span style=color:#616e88>                     // 最小/最大温度</span></span>
<span class=giallo-l><span style=color:#81a1c1>    int</span><span> count</span><span style=color:#81a1c1>;</span><span style=color:#616e88>                          // 记录数量</span></span>
<span class=giallo-l><span style=color:#81a1c1>    long</span><span> sum</span><span style=color:#81a1c1>;</span><span style=color:#616e88>                           // 温度总和</span></span>
<span class=giallo-l><span style=color:#81a1c1>    long</span><span> nameAddress</span><span style=color:#81a1c1>;</span><span style=color:#616e88>                   // 名称在内存中的地址</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>这个程序展示了现代Java在极端性能优化方面的能力，通过底层内存操作、并行计算和算法优化，实现了接近C/C++级别的性能。</div></div></section>