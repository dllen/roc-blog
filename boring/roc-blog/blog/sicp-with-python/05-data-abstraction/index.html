<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>05. 数据抽象：构建系统的防火墙 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/sicp-with-python/> /sicp-with-python </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-02-07</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">05. 数据抽象：构建系统的防火墙</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=di-wu-zhang-shu-ju-chou-xiang-gou-jian-xi-tong-de-fang-huo-qiang>第五章：数据抽象——构建系统的防火墙</h1><blockquote><p>“There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies.”<br> — C.A.R. Hoare</blockquote><p>在第一章中，我们学习了如何通过函数来抽象<strong>过程</strong>。现在，我们将进入编程的另一个维度：<strong>数据</strong>。<p><strong>数据抽象 (Data Abstraction)</strong> 是一种方法论，它要求我们将“如何使用数据”与“如何表示数据”隔离开来。这就像在软件系统中建立了一道道“防火墙”——<strong>抽象屏障 (Abstraction Barriers)</strong>。<h2 id=2-2-shu-ju-chou-xiang-data-abstraction>2.2 数据抽象 (Data Abstraction)</h2><p>让我们通过一个经典的例子来理解：<strong>有理数 (Rational Numbers)</strong> 的运算。<p>有理数可以表示为分数 $\frac{n}{d}$，其中 $n$ 是分子，$d$ 是分母。 我们要实现有理数的加法、乘法等操作。<h3 id=2-2-1-gou-zao-han-shu-yu-xuan-ze-han-shu>2.2.1 构造函数与选择函数</h3><p>在开始写加法逻辑之前，我们先<strong>假设</strong>有理数已经存在了，并且有三个基本操作：<ol><li><code>rational(n, d)</code>: <strong>构造函数 (Constructor)</strong>，返回一个代表 $\frac{n}{d}$ 的有理数。<li><code>numer(x)</code>: <strong>选择函数 (Selector)</strong>，返回有理数 <code>x</code> 的分子。<li><code>denom(x)</code>: <strong>选择函数 (Selector)</strong>，返回有理数 <code>x</code> 的分母。</ol><h3 id=2-2-2-bing-bu-cun-zai-de-you-li-shu>2.2.2 并不存在的“有理数”</h3><p>有了这三个工具，我们就可以<strong>无视底层实现</strong>，直接编写高级运算逻辑：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> add_rationals</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>,</span><span> y</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#eceff4>    """</span><span style=color:#a3be8c>Add rational numbers x and y.</span><span style=color:#eceff4>"""</span></span>
<span class=giallo-l><span>    nx</span><span style=color:#eceff4>,</span><span> dx</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> numer</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>),</span><span style=color:#88c0d0> denom</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span>    ny</span><span style=color:#eceff4>,</span><span> dy</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> numer</span><span style=color:#eceff4>(</span><span>y</span><span style=color:#eceff4>),</span><span style=color:#88c0d0> denom</span><span style=color:#eceff4>(</span><span>y</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span style=color:#88c0d0> rational</span><span style=color:#eceff4>(</span><span>nx</span><span style=color:#81a1c1> *</span><span> dy</span><span style=color:#81a1c1> +</span><span> ny</span><span style=color:#81a1c1> *</span><span> dx</span><span style=color:#eceff4>,</span><span> dx</span><span style=color:#81a1c1> *</span><span> dy</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> mul_rationals</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>,</span><span> y</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#eceff4>    """</span><span style=color:#a3be8c>Multiply rational numbers x and y.</span><span style=color:#eceff4>"""</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span style=color:#88c0d0> rational</span><span style=color:#eceff4>(</span><span style=color:#88c0d0>numer</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> *</span><span style=color:#88c0d0> numer</span><span style=color:#eceff4>(</span><span>y</span><span style=color:#eceff4>),</span><span style=color:#88c0d0> denom</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> *</span><span style=color:#88c0d0> denom</span><span style=color:#eceff4>(</span><span>y</span><span style=color:#eceff4>))</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> print_rational</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#88c0d0>    print</span><span style=color:#eceff4>(</span><span style=color:#88c0d0>numer</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>), '</span><span style=color:#a3be8c>/</span><span style=color:#eceff4>',</span><span style=color:#88c0d0> denom</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>))</span></span></code></pre><p><strong>关键点</strong>：在写这段代码时，我们根本不知道（也不关心）<code>rational</code> 到底是怎么实现的。它可能是一个列表，一个元组，甚至是一个对象。这种<strong>忽略细节的能力</strong>就是抽象的力量。<h3 id=2-2-3-ju-ti-de-shi-xian-lie-biao-lists>2.2.3 具体的实现：列表 (Lists)</h3><p>现在，我们必须来实现这三个基础函数了。Python 的 <code>list</code> 是一个很好的载体。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> rational</span><span style=color:#eceff4>(</span><span>n</span><span style=color:#eceff4>,</span><span> d</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span style=color:#eceff4> [</span><span>n</span><span style=color:#eceff4>,</span><span> d</span><span style=color:#eceff4>]</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> numer</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span> x</span><span style=color:#eceff4>[</span><span style=color:#b48ead>0</span><span style=color:#eceff4>]</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> denom</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span> x</span><span style=color:#eceff4>[</span><span style=color:#b48ead>1</span><span style=color:#eceff4>]</span></span></code></pre><p>就这样，我们的有理数系统跑起来了！<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>>>></span><span> half</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> rational</span><span style=color:#eceff4>(</span><span style=color:#b48ead>1</span><span style=color:#eceff4>,</span><span style=color:#b48ead> 2</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>>>></span><span style=color:#88c0d0> print_rational</span><span style=color:#eceff4>(</span><span style=color:#88c0d0>mul_rationals</span><span style=color:#eceff4>(</span><span>half</span><span style=color:#eceff4>,</span><span> half</span><span style=color:#eceff4>))</span></span>
<span class=giallo-l><span style=color:#b48ead>1</span><span style=color:#81a1c1> /</span><span style=color:#b48ead> 4</span></span></code></pre><h3 id=2-2-4-chou-xiang-ping-zhang-abstraction-barriers>2.2.4 抽象屏障 (Abstraction Barriers)</h3><p>这是本章最重要的概念。我们可以将系统分为不同的层级：<table><thead><tr><th style=text-align:left>层级 (Layers)<th style=text-align:left>职责 (Responsibilities)<th style=text-align:left>例子 (Examples)<tbody><tr><td style=text-align:left><strong>使用层</strong><td style=text-align:left>使用数据做实际应用<td style=text-align:left><code>add_rationals</code>, <code>print_rational</code><tr><td style=text-align:left><strong>屏障 ––––––––</strong><td style=text-align:left><strong>隔离使用与实现</strong><td style=text-align:left><strong>rational, numer, denom</strong><tr><td style=text-align:left><strong>表示层</strong><td style=text-align:left>定义数据的具体结构<td style=text-align:left><code>list</code>, <code>getitem</code></table><p><strong>违规操作 (Abstraction Violation)</strong>： 如果在 <code>add_rationals</code> 中直接使用列表索引 <code>x[0]</code> 而不是 <code>numer(x)</code>，就破坏了屏障。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#616e88># 错误示范：穿透了屏障</span></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> add_rationals_bad</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>,</span><span> y</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#616e88>    # 直接依赖了 "有理数是用列表实现的" 这一细节</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span style=color:#eceff4> [</span><span>x</span><span style=color:#eceff4>[</span><span style=color:#b48ead>0</span><span style=color:#eceff4>]</span><span style=color:#81a1c1>*</span><span>y</span><span style=color:#eceff4>[</span><span style=color:#b48ead>1</span><span style=color:#eceff4>]</span><span style=color:#81a1c1> +</span><span> y</span><span style=color:#eceff4>[</span><span style=color:#b48ead>0</span><span style=color:#eceff4>]</span><span style=color:#81a1c1>*</span><span>x</span><span style=color:#eceff4>[</span><span style=color:#b48ead>1</span><span style=color:#eceff4>],</span><span> x</span><span style=color:#eceff4>[</span><span style=color:#b48ead>1</span><span style=color:#eceff4>]</span><span style=color:#81a1c1>*</span><span>y</span><span style=color:#eceff4>[</span><span style=color:#b48ead>1</span><span style=color:#eceff4>]]</span></span></code></pre><p><strong>为什么要遵守屏障？</strong> 假设有一天，我们决定用<strong>元组 (tuple)</strong> 或者 <strong>字典 (dict)</strong> 来实现有理数，甚至加上自动约分功能：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>from</span><span> math</span><span style=color:#81a1c1> import</span><span> gcd</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> rational</span><span style=color:#eceff4>(</span><span>n</span><span style=color:#eceff4>,</span><span> d</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span>    g</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> gcd</span><span style=color:#eceff4>(</span><span>n</span><span style=color:#eceff4>,</span><span> d</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span style=color:#eceff4> (</span><span>n</span><span style=color:#81a1c1>//</span><span>g</span><span style=color:#eceff4>,</span><span> d</span><span style=color:#81a1c1>//</span><span>g</span><span style=color:#eceff4>)</span><span style=color:#616e88>  # 改用元组，且自动约分</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> numer</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span> x</span><span style=color:#eceff4>[</span><span style=color:#b48ead>0</span><span style=color:#eceff4>]</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> denom</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span> x</span><span style=color:#eceff4>[</span><span style=color:#b48ead>1</span><span style=color:#eceff4>]</span></span></code></pre><p>如果我们遵守了屏障，<code>add_rationals</code> 等上层代码<strong>一行都不用改</strong>就能自动享受到性能提升（元组比列表快）和功能增强（约分）。这就是<strong>解耦</strong>带来的巨大价值。<h3 id=2-2-5-shu-ju-yi-wei-zhao-shen-me-what-is-data>2.2.5 数据意味着什么？ (What is Data?)</h3><p>SICP 提出了一个震撼的观点：<strong>数据不仅仅是存储在内存中的位，它是通过行为来定义的。</strong><p>如果我们可以用<strong>函数</strong>来实现有理数，那它还是数据吗？<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> rational</span><span style=color:#eceff4>(</span><span>n</span><span style=color:#eceff4>,</span><span> d</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>    def</span><span style=color:#88c0d0> dispatch</span><span style=color:#eceff4>(</span><span>m</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>        if</span><span> m</span><span style=color:#81a1c1> ==</span><span style=color:#b48ead> 0</span><span style=color:#eceff4>:</span><span style=color:#81a1c1> return</span><span> n</span></span>
<span class=giallo-l><span style=color:#81a1c1>        elif</span><span> m</span><span style=color:#81a1c1> ==</span><span style=color:#b48ead> 1</span><span style=color:#eceff4>:</span><span style=color:#81a1c1> return</span><span> d</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span> dispatch</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> numer</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span style=color:#88c0d0> x</span><span style=color:#eceff4>(</span><span style=color:#b48ead>0</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> denom</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span style=color:#88c0d0> x</span><span style=color:#eceff4>(</span><span style=color:#b48ead>1</span><span style=color:#eceff4>)</span></span></code></pre><p>在这个实现中，<code>rational</code> 返回的不是列表，而是一个<strong>函数</strong>（闭包）。但对于 <code>add_rationals</code> 来说，它完全感觉不到区别！<p>这再次证明了：<strong>只要满足了接口契约（行为），底层实现（状态）可以是任何东西。</strong> 这也是面向对象编程 (OOP) 的核心思想之一。<h2 id=zong-jie-yu-si-kao>总结与思考</h2><ul><li><strong>构造与选择</strong>：这是定义任何抽象数据类型 (ADT) 的基石。<li><strong>抽象屏障</strong>：它是软件架构中应对变化的保险丝。<li><strong>数据即行为</strong>：打破了数据与代码的界限，为后续的面向对象编程埋下了伏笔。</ul><p>在下一章，我们将探索更复杂的数据结构——<strong>序列 (Sequences)</strong> 和 <strong>树 (Trees)</strong>，并学习如何用递归来处理它们。</div></div></section>