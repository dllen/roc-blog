<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>10. 递归对象：链表与树的类实现 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/sicp-with-python/> /sicp-with-python </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-02-07</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">10. 递归对象：链表与树的类实现</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=di-shi-zhang-di-gui-dui-xiang-lian-biao-yu-shu-de-lei-shi-xian>第十章：递归对象——链表与树的类实现</h1><blockquote><p>“To understand recursion, you must first understand recursion.”</blockquote><p>在前面的章节中，我们使用函数和元组实现了链表和树。那时候，数据（元组）和行为（处理函数）是分离的。 现在，我们已经掌握了面向对象编程 (OOP)，是时候将这两者结合起来，构建<strong>递归对象 (Recursive Objects)</strong>。<p>当一个对象的属性值是该对象所属类的实例时，我们称其为递归对象。<h2 id=2-9-1-lian-biao-lei-linked-list-class>2.9.1 链表类 (Linked List Class)</h2><p>我们在 2.3 节中用嵌套元组 <code>(1, (2, (3, empty)))</code> 模拟了链表。现在，我们可以定义一个 <code>Link</code> 类来封装这种逻辑。<h3 id=ding-yi-link-lei>定义 <code>Link</code> 类</h3><p>核心思想依然不变：链表由 <strong>first</strong> (第一个元素) 和 <strong>rest</strong> (剩余部分) 组成。<code>rest</code> 必须也是一个 <code>Link</code> 实例，或者是空链表 (<code>Link.empty</code>)。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>class</span><span style=color:#8fbcbb> Link</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#eceff4>    """</span><span style=color:#a3be8c>A linked list with a first element and the rest.</span><span style=color:#eceff4>"""</span></span>
<span class=giallo-l><span>    empty</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> ()</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>    def</span><span style=color:#88c0d0> __init__</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>self</span><span style=color:#eceff4>,</span><span> first</span><span style=color:#eceff4>,</span><span> rest</span><span style=color:#81a1c1>=</span><span>empty</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>        assert</span><span> rest</span><span style=color:#81a1c1> is</span><span> Link</span><span style=color:#eceff4>.</span><span>empty</span><span style=color:#81a1c1> or</span><span style=color:#88c0d0> isinstance</span><span style=color:#eceff4>(</span><span>rest</span><span style=color:#eceff4>,</span><span> Link</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>        self</span><span style=color:#eceff4>.</span><span>first</span><span style=color:#81a1c1> =</span><span> first</span></span>
<span class=giallo-l><span style=color:#81a1c1>        self</span><span style=color:#eceff4>.</span><span>rest</span><span style=color:#81a1c1> =</span><span> rest</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>    def</span><span style=color:#88c0d0> __getitem__</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>self</span><span style=color:#eceff4>,</span><span> i</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>        if</span><span> i</span><span style=color:#81a1c1> ==</span><span style=color:#b48ead> 0</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>            return self</span><span style=color:#eceff4>.</span><span>first</span></span>
<span class=giallo-l><span style=color:#81a1c1>        else</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>            return self</span><span style=color:#eceff4>.</span><span>rest</span><span style=color:#eceff4>[</span><span>i</span><span style=color:#81a1c1>-</span><span style=color:#b48ead>1</span><span style=color:#eceff4>]</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>    def</span><span style=color:#88c0d0> __len__</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>self</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span style=color:#b48ead> 1</span><span style=color:#81a1c1> +</span><span style=color:#88c0d0> len</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>self</span><span style=color:#eceff4>.</span><span>rest</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>    def</span><span style=color:#88c0d0> __repr__</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>self</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>        if self</span><span style=color:#eceff4>.</span><span>rest</span><span style=color:#81a1c1> is</span><span> Link</span><span style=color:#eceff4>.</span><span>empty</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span>            rest</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> ''</span></span>
<span class=giallo-l><span style=color:#81a1c1>        else</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span>            rest</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>, </span><span style=color:#eceff4>'</span><span style=color:#81a1c1> +</span><span style=color:#88c0d0> repr</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>self</span><span style=color:#eceff4>.</span><span>rest</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>Link(</span><span style=color:#ebcb8b>{0}{1}</span><span style=color:#a3be8c>)</span><span style=color:#eceff4>'.</span><span style=color:#88c0d0>format</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>self</span><span style=color:#eceff4>.</span><span>first</span><span style=color:#eceff4>,</span><span> rest</span><span style=color:#eceff4>)</span></span></code></pre><p><strong>代码解析：</strong><ol><li><strong>递归定义</strong>：<code>__len__</code> 和 <code>__getitem__</code> 都调用了 <code>self.rest</code> 的对应方法。<li><strong>魔术方法</strong>：实现了 <code>__len__</code> 和 <code>__getitem__</code> 后，<code>Link</code> 对象就可以使用 <code>len()</code> 函数和索引 <code>[]</code> 访问，表现得像 Python 内置序列一样。<li><strong><code>__repr__</code></strong>：提供了友好的字符串表示，方便调试。</ol><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span>s</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> Link</span><span style=color:#eceff4>(</span><span style=color:#b48ead>3</span><span style=color:#eceff4>,</span><span style=color:#88c0d0> Link</span><span style=color:#eceff4>(</span><span style=color:#b48ead>4</span><span style=color:#eceff4>,</span><span style=color:#88c0d0> Link</span><span style=color:#eceff4>(</span><span style=color:#b48ead>5</span><span style=color:#eceff4>)))</span></span>
<span class=giallo-l><span style=color:#616e88># >>> len(s)</span></span>
<span class=giallo-l><span style=color:#616e88># 3</span></span>
<span class=giallo-l><span style=color:#616e88># >>> s[1]</span></span>
<span class=giallo-l><span style=color:#616e88># 4</span></span>
<span class=giallo-l><span style=color:#616e88># >>> s</span></span>
<span class=giallo-l><span style=color:#616e88># Link(3, Link(4, Link(5)))</span></span></code></pre><h3 id=lian-biao-de-di-gui-cao-zuo>链表的递归操作</h3><p>有了 <code>Link</code> 类，我们可以定义各种高阶函数来处理它。注意，这些操作通常也是递归的。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> extend_link</span><span style=color:#eceff4>(</span><span>s</span><span style=color:#eceff4>,</span><span> t</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#eceff4>    """</span><span style=color:#a3be8c>连接两个链表 s 和 t</span><span style=color:#eceff4>"""</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span> s</span><span style=color:#81a1c1> is</span><span> Link</span><span style=color:#eceff4>.</span><span>empty</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span> t</span></span>
<span class=giallo-l><span style=color:#81a1c1>    else</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span style=color:#88c0d0> Link</span><span style=color:#eceff4>(</span><span>s</span><span style=color:#eceff4>.</span><span>first</span><span style=color:#eceff4>,</span><span style=color:#88c0d0> extend_link</span><span style=color:#eceff4>(</span><span>s</span><span style=color:#eceff4>.</span><span>rest</span><span style=color:#eceff4>,</span><span> t</span><span style=color:#eceff4>))</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> map_link</span><span style=color:#eceff4>(</span><span>f</span><span style=color:#eceff4>,</span><span> s</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#eceff4>    """</span><span style=color:#a3be8c>对链表 s 的每个元素应用函数 f</span><span style=color:#eceff4>"""</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span> s</span><span style=color:#81a1c1> is</span><span> Link</span><span style=color:#eceff4>.</span><span>empty</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span> s</span></span>
<span class=giallo-l><span style=color:#81a1c1>    else</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span style=color:#88c0d0> Link</span><span style=color:#eceff4>(</span><span style=color:#88c0d0>f</span><span style=color:#eceff4>(</span><span>s</span><span style=color:#eceff4>.</span><span>first</span><span style=color:#eceff4>),</span><span style=color:#88c0d0> map_link</span><span style=color:#eceff4>(</span><span>f</span><span style=color:#eceff4>,</span><span> s</span><span style=color:#eceff4>.</span><span>rest</span><span style=color:#eceff4>))</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> filter_link</span><span style=color:#eceff4>(</span><span>f</span><span style=color:#eceff4>,</span><span> s</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#eceff4>    """</span><span style=color:#a3be8c>过滤链表 s，只保留满足 f 的元素</span><span style=color:#eceff4>"""</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span> s</span><span style=color:#81a1c1> is</span><span> Link</span><span style=color:#eceff4>.</span><span>empty</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span> s</span></span>
<span class=giallo-l><span style=color:#81a1c1>    else</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span>        filtered</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> filter_link</span><span style=color:#eceff4>(</span><span>f</span><span style=color:#eceff4>,</span><span> s</span><span style=color:#eceff4>.</span><span>rest</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>        if</span><span style=color:#88c0d0> f</span><span style=color:#eceff4>(</span><span>s</span><span style=color:#eceff4>.</span><span>first</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>            return</span><span style=color:#88c0d0> Link</span><span style=color:#eceff4>(</span><span>s</span><span style=color:#eceff4>.</span><span>first</span><span style=color:#eceff4>,</span><span> filtered</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>        else</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>            return</span><span> filtered</span></span></code></pre><p>这不仅演示了递归处理，也展示了 OOP 如何与函数式编程（Map/Filter）完美融合。<h2 id=2-9-2-shu-lei-tree-class>2.9.2 树类 (Tree Class)</h2><p>同样地，我们在 2.3 节用列表嵌套列表实现了树。现在，我们定义一个 <code>Tree</code> 类。 一棵树包含一个 <strong>label</strong> (根节点值) 和一组 <strong>branches</strong> (分支，每个分支也是一棵 <code>Tree</code>)。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>class</span><span style=color:#8fbcbb> Tree</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>    def</span><span style=color:#88c0d0> __init__</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>self</span><span style=color:#eceff4>,</span><span> label</span><span style=color:#eceff4>,</span><span> branches</span><span style=color:#81a1c1>=</span><span style=color:#eceff4>()):</span></span>
<span class=giallo-l><span style=color:#81a1c1>        self</span><span style=color:#eceff4>.</span><span>label</span><span style=color:#81a1c1> =</span><span> label</span></span>
<span class=giallo-l><span style=color:#81a1c1>        for</span><span> branch</span><span style=color:#81a1c1> in</span><span> branches</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>            assert</span><span style=color:#88c0d0> isinstance</span><span style=color:#eceff4>(</span><span>branch</span><span style=color:#eceff4>,</span><span> Tree</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>        self</span><span style=color:#eceff4>.</span><span>branches</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> list</span><span style=color:#eceff4>(</span><span>branches</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>    def</span><span style=color:#88c0d0> __repr__</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>self</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>        if self</span><span style=color:#eceff4>.</span><span>branches</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span>            branch_str</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>, </span><span style=color:#eceff4>'</span><span style=color:#81a1c1> +</span><span style=color:#88c0d0> repr</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>self</span><span style=color:#eceff4>.</span><span>branches</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>        else</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span>            branch_str</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> ''</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>Tree(</span><span style=color:#ebcb8b>{0}{1}</span><span style=color:#a3be8c>)</span><span style=color:#eceff4>'.</span><span style=color:#88c0d0>format</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>self</span><span style=color:#eceff4>.</span><span>label</span><span style=color:#eceff4>,</span><span> branch_str</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>    def</span><span style=color:#88c0d0> is_leaf</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>self</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return not self</span><span style=color:#eceff4>.</span><span>branches</span></span></code></pre><h3 id=ying-yong-fei-bo-na-qi-shu>应用：斐波那契树</h3><p>我们可以构建一棵树来可视化斐波那契数列的计算过程。这极好地展示了树递归的结构。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> fib_tree</span><span style=color:#eceff4>(</span><span>n</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span> n</span><span style=color:#81a1c1> ==</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1> or</span><span> n</span><span style=color:#81a1c1> ==</span><span style=color:#b48ead> 1</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span style=color:#88c0d0> Tree</span><span style=color:#eceff4>(</span><span>n</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>    else</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span>        left</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> fib_tree</span><span style=color:#eceff4>(</span><span>n</span><span style=color:#81a1c1>-</span><span style=color:#b48ead>2</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span>        right</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> fib_tree</span><span style=color:#eceff4>(</span><span>n</span><span style=color:#81a1c1>-</span><span style=color:#b48ead>1</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span>        fib_n</span><span style=color:#81a1c1> =</span><span> left</span><span style=color:#eceff4>.</span><span>label</span><span style=color:#81a1c1> +</span><span> right</span><span style=color:#eceff4>.</span><span>label</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span style=color:#88c0d0> Tree</span><span style=color:#eceff4>(</span><span>fib_n</span><span style=color:#eceff4>, [</span><span>left</span><span style=color:#eceff4>,</span><span> right</span><span style=color:#eceff4>])</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88># >>> fib_tree(5)</span></span>
<span class=giallo-l><span style=color:#616e88># Tree(5, [Tree(2, [Tree(1, [Tree(0), Tree(1)]), Tree(1)]), Tree(3, [Tree(1), Tree(2, [Tree(1, [Tree(0), Tree(1)]), Tree(1)])])])</span></span></code></pre><h3 id=ji-yi-hua-memoization-yu-xiao-lu>记忆化 (Memoization) 与效率</h3><p>递归对象的一个潜在问题是效率。例如 <code>fib_tree(35)</code> 会生成海量的节点。 通过结合 <strong>Memoization (记忆化)</strong> 技术，我们可以确保相同的子树只被创建一次。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> memo</span><span style=color:#eceff4>(</span><span>f</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span>    cache</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> {}</span></span>
<span class=giallo-l><span style=color:#81a1c1>    def</span><span style=color:#88c0d0> memoized</span><span style=color:#eceff4>(</span><span>n</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>        if</span><span> n</span><span style=color:#81a1c1> not in</span><span> cache</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span>            cache</span><span style=color:#eceff4>[</span><span>n</span><span style=color:#eceff4>]</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> f</span><span style=color:#eceff4>(</span><span>n</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span> cache</span><span style=color:#eceff4>[</span><span>n</span><span style=color:#eceff4>]</span></span>
<span class=giallo-l><span style=color:#81a1c1>    return</span><span> memoized</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>fib_tree</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> memo</span><span style=color:#eceff4>(</span><span>fib_tree</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span>big_fib_tree</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> fib_tree</span><span style=color:#eceff4>(</span><span style=color:#b48ead>35</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#616e88># 此时，计算瞬间完成，且内存占用极低，因为大量子树被共享引用了。</span></span></code></pre><p>这展示了对象模型的一个重要特性：<strong>对象标识 (Identity)</strong>。虽然逻辑上树很大，但物理上许多分支指向的是同一个内存对象。<h2 id=2-9-3-ji-he-sets-de-shi-xian>2.9.3 集合 (Sets) 的实现</h2><p>最后，我们来看看如何利用递归对象来实现<strong>集合 (Set)</strong>。 集合的特性是：元素不重复、无序。<p>如果我们用 <code>Link</code> 来实现集合（作为无序序列）：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> set_contains</span><span style=color:#eceff4>(</span><span>s</span><span style=color:#eceff4>,</span><span> v</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#eceff4>    """</span><span style=color:#a3be8c>判断集合 s 是否包含 v</span><span style=color:#eceff4>"""</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span> s</span><span style=color:#81a1c1> is</span><span> Link</span><span style=color:#eceff4>.</span><span>empty</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return False</span></span>
<span class=giallo-l><span style=color:#81a1c1>    elif</span><span> s</span><span style=color:#eceff4>.</span><span>first</span><span style=color:#81a1c1> ==</span><span> v</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return True</span></span>
<span class=giallo-l><span style=color:#81a1c1>    else</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span style=color:#88c0d0> set_contains</span><span style=color:#eceff4>(</span><span>s</span><span style=color:#eceff4>.</span><span>rest</span><span style=color:#eceff4>,</span><span> v</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> adjoin_set</span><span style=color:#eceff4>(</span><span>s</span><span style=color:#eceff4>,</span><span> v</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#eceff4>    """</span><span style=color:#a3be8c>向集合 s 添加元素 v</span><span style=color:#eceff4>"""</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span style=color:#88c0d0> set_contains</span><span style=color:#eceff4>(</span><span>s</span><span style=color:#eceff4>,</span><span> v</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span> s</span></span>
<span class=giallo-l><span style=color:#81a1c1>    else</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span style=color:#88c0d0> Link</span><span style=color:#eceff4>(</span><span>v</span><span style=color:#eceff4>,</span><span> s</span><span style=color:#eceff4>)</span></span></code></pre><p><strong>效率分析</strong>：<ul><li><code>set_contains</code> 需要遍历整个链表，时间复杂度为 $O(n)$。<li><code>adjoin_set</code> 也需要调用 <code>set_contains</code>，所以也是 $O(n)$。<li>两个集合的交集或并集操作，则可能达到 $O(n^2)$。</ul><p>这为我们后续讨论<strong>效率 (Efficiency)</strong> 埋下了伏笔：如果我们使用<strong>排序链表</strong>或<strong>二叉搜索树</strong>来实现集合，能否将复杂度降低到 $O(\log n)$？<h2 id=zong-jie>总结</h2><p>递归对象是数据结构课程的核心。通过 <code>Link</code> 和 <code>Tree</code> 类，我们：<ol><li>将<strong>递归结构</strong>封装在类定义中。<li>利用<strong>特殊方法</strong>让自定义对象融入 Python 生态。<li>结合<strong>记忆化</strong>优化了递归结构的性能。</ol><p>至此，SICP Python 版的第二部分“数据抽象”的主要内容已经完成。我们从简单的数字，到函数，再到序列、树，最后到通用的对象系统。<p>下一章，我们将稍作停顿，专门探讨<strong>效率 (Efficiency)</strong>，用大 O 表示法来量化我们的代码性能。<hr><p><em>参考链接：</em><ul><li><a href=https://www.composingprograms.com/pages/29-recursive-objects.html rel=external>Composing Programs 2.9 Recursive Objects</a></ul></div></div></section>