<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>18. Unification 算法：逻辑编程的引擎 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/sicp-with-python/> /sicp-with-python </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-02-07</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">18. Unification 算法：逻辑编程的引擎</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=di-shi-ba-zhang-unification-suan-fa-luo-ji-bian-cheng-de-yin-qing>第十八章：Unification 算法——逻辑编程的引擎</h1><blockquote><p>“Unification is a general method of matching a query to a fact, each of which may contain variables.”</blockquote><p>在上一章中，我们体验了逻辑编程的魔法：只需定义事实和规则，计算机就能自动回答问题。今天，我们将揭开魔术的幕布，看看<strong>逻辑解释器 (Query Interpreter)</strong> 是如何工作的。<p>核心机制有两个：<ol><li><strong>Unification (统一化)</strong>：判断两个表达式是否可以“相等”，并确定变量的值。<li><strong>Search (搜索)</strong>：在所有事实中查找满足条件的组合。</ol><h2 id=4-5-1-mo-shi-pi-pei-pattern-matching>4.5.1 模式匹配 (Pattern Matching)</h2><p>最简单的情况是<strong>模式匹配</strong>：一个包含变量的查询去匹配一个不含变量的事实。<ul><li><strong>事实</strong>：<code>(parent abraham barack)</code><li><strong>查询</strong>：<code>(parent abraham ?child)</code></ul><p>如果让 <code>?child = barack</code>，那么这两个列表就完全一样了。这就是一次成功的匹配。<p>在 Python 中，我们可以用递归函数来实现。<h2 id=4-5-2-unification-suan-fa>4.5.2 Unification 算法</h2><p>Unification 是模式匹配的推广：<strong>两个表达式都可以包含变量</strong>。<p>例如：<ul><li>表达式 A: <code>(?x ?x)</code><li>表达式 B: <code>((a ?y c) (a b ?z))</code></ul><p>为了让 A 和 B 相等，我们需要：<ol><li><code>?x</code> 必须等于 <code>(a ?y c)</code><li><code>?x</code> 也必须等于 <code>(a b ?z)</code></ol><p>这就意味着 <code>(a ?y c)</code> 必须等于 <code>(a b ?z)</code>。 进而推导出：<ul><li><code>?y = b</code><li><code>?z = c</code><li><code>?x = (a b c)</code></ul><h3 id=suan-fa-shi-xian-python-wei-dai-ma>算法实现 (Python 伪代码)</h3><p><code>unify</code> 函数接收两个表达式 <code>e</code> 和 <code>f</code>，以及一个环境 <code>env</code>。它的目标是修改 <code>env</code>，使得 <code>e</code> 和 <code>f</code> 在该环境下相等。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> unify</span><span style=color:#eceff4>(</span><span>e</span><span style=color:#eceff4>,</span><span> f</span><span style=color:#eceff4>,</span><span> env</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#eceff4>    """</span></span>
<span class=giallo-l><span style=color:#a3be8c>    尝试统一 e 和 f。如果成功返回 True 并更新 env，否则返回 False。</span></span>
<span class=giallo-l><span style=color:#eceff4>    """</span></span>
<span class=giallo-l><span style=color:#616e88>    # 1. 如果是变量，先查找它的当前值</span></span>
<span class=giallo-l><span>    e</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> lookup</span><span style=color:#eceff4>(</span><span>e</span><span style=color:#eceff4>,</span><span> env</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span>    f</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> lookup</span><span style=color:#eceff4>(</span><span>f</span><span style=color:#eceff4>,</span><span> env</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span style=color:#616e88>    # 2. 如果两者相等，统一成功</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span> e</span><span style=color:#81a1c1> ==</span><span> f</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return True</span></span>
<span class=giallo-l><span>        </span></span>
<span class=giallo-l><span style=color:#616e88>    # 3. 如果 e 是变量，将 e 绑定到 f</span></span>
<span class=giallo-l><span style=color:#81a1c1>    elif</span><span style=color:#88c0d0> isvar</span><span style=color:#eceff4>(</span><span>e</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span>        env</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>define</span><span style=color:#eceff4>(</span><span>e</span><span style=color:#eceff4>,</span><span> f</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return True</span></span>
<span class=giallo-l><span>        </span></span>
<span class=giallo-l><span style=color:#616e88>    # 4. 如果 f 是变量，将 f 绑定到 e</span></span>
<span class=giallo-l><span style=color:#81a1c1>    elif</span><span style=color:#88c0d0> isvar</span><span style=color:#eceff4>(</span><span>f</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span>        env</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>define</span><span style=color:#eceff4>(</span><span>f</span><span style=color:#eceff4>,</span><span> e</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return True</span></span>
<span class=giallo-l><span>        </span></span>
<span class=giallo-l><span style=color:#616e88>    # 5. 如果其中一个是原子值（且不相等），统一失败</span></span>
<span class=giallo-l><span style=color:#81a1c1>    elif</span><span style=color:#88c0d0> is_atom</span><span style=color:#eceff4>(</span><span>e</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> or</span><span style=color:#88c0d0> is_atom</span><span style=color:#eceff4>(</span><span>f</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return False</span></span>
<span class=giallo-l><span>        </span></span>
<span class=giallo-l><span style=color:#616e88>    # 6. 如果都是列表（Pair），递归统一头部和尾部</span></span>
<span class=giallo-l><span style=color:#81a1c1>    else</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span style=color:#88c0d0> unify</span><span style=color:#eceff4>(</span><span>e</span><span style=color:#eceff4>.</span><span>first</span><span style=color:#eceff4>,</span><span> f</span><span style=color:#eceff4>.</span><span>first</span><span style=color:#eceff4>,</span><span> env</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> and</span><span style=color:#eceff4> \</span></span>
<span class=giallo-l><span style=color:#88c0d0>               unify</span><span style=color:#eceff4>(</span><span>e</span><span style=color:#eceff4>.</span><span>second</span><span style=color:#eceff4>,</span><span> f</span><span style=color:#eceff4>.</span><span>second</span><span style=color:#eceff4>,</span><span> env</span><span style=color:#eceff4>)</span></span></code></pre><h2 id=4-5-3-sou-suo-guo-cheng-the-search-procedure>4.5.3 搜索过程 (The Search Procedure)</h2><p>有了 <code>unify</code>，我们还需要一个搜索过程来遍历数据库。<p>当我们发起一个查询 <code>(query &lt;clause1> &lt;clause2> ...)</code> 时，解释器会：<ol><li>尝试在数据库中找到一个事实（或规则结论），能与 <code>&lt;clause1></code> <strong>Unify</strong> 成功。<li>如果这是一个规则，我们需要递归地证明规则的<strong>假设</strong>也成立。<li>如果 <code>&lt;clause1></code> 成立了，我们带着新的变量绑定，继续去证明 <code>&lt;clause2></code>。<li>如果所有子句都证明成功，返回当前的变量绑定作为结果。</ol><h3 id=bian-liang-zhong-ming-ming>变量重命名</h3><p>为了避免不同规则中的同名变量冲突（比如两个规则都用了 <code>?x</code>），每次使用规则前，我们需要将规则中的变量重命名为唯一标识符（例如 <code>?x_1</code>, <code>?x_2</code>）。<h2 id=zong-jie>总结</h2><p>逻辑编程解释器的核心就是一个<strong>递归的深度优先搜索</strong>，配合<strong>Unification</strong> 来进行状态检查和传递。<ul><li><strong>Unification</strong> 负责处理“局部”的匹配逻辑。<li><strong>Search</strong> 负责处理“全局”的逻辑推导路径。</ul><p>这展示了计算机科学中一个深刻的思想：<strong>计算即推导 (Computation is Deduction)</strong>。<hr><p><em>参考链接：</em><ul><li><a href=https://www.composingprograms.com/pages/45-unification.html rel=external>Composing Programs 4.5 Unification</a></ul></div></div></section>