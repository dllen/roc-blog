<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>15. 隐式序列与生成器：惰性计算的力量 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/sicp-with-python/> /sicp-with-python </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-02-07</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">15. 隐式序列与生成器：惰性计算的力量</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=di-shi-wu-zhang-yin-shi-xu-lie-yu-sheng-cheng-qi-duo-xing-ji-suan-de-li-liang>第十五章：隐式序列与生成器——惰性计算的力量</h1><blockquote><p>“Computer science is the study of how to describe and process information.”</blockquote><p>在前面的章节中，我们处理的数据结构（如列表、元组）都是<strong>显式</strong>的：所有的元素都完整地存储在内存中。如果我们要处理一个包含 10 亿个数字的序列，或者一个无限的质数序列，显式存储显然是不可能的。<p>今天，我们将探索<strong>隐式序列 (Implicit Sequences)</strong>，也就是 Python 中最强大的特性之一：<strong>迭代器 (Iterators)</strong> 和 <strong>生成器 (Generators)</strong>。它们允许我们按需计算数据，从而处理无限或巨大的数据集。<h2 id=4-2-1-duo-xing-ji-suan-lazy-computation>4.2.1 惰性计算 (Lazy Computation)</h2><p>考虑 <code>range(10000, 1000000000)</code>。Python 并没有在内存中真的创建 10 亿个整数。相反，它创建了一个 <code>range</code> 对象，这个对象只记住了起点、终点和步长。<p>只有当你请求第 n 个元素时，它才通过公式 <code>start + n * step</code> 计算出来。这就是<strong>惰性计算</strong>：将计算推迟到真正需要结果的那一刻。<h2 id=4-2-2-die-dai-qi-xie-yi-the-iterator-protocol>4.2.2 迭代器协议 (The Iterator Protocol)</h2><p>Python 通过两个魔术方法定义了迭代器协议：<ol><li><strong><code>__iter__</code></strong>: 返回迭代器对象本身。<li><strong><code>__next__</code></strong>: 返回序列的下一个元素；如果没有元素了，抛出 <code>StopIteration</code> 异常。</ol><p>让我们手动模拟一个 <code>for</code> 循环的过程：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span>primes</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> [</span><span style=color:#b48ead>2</span><span style=color:#eceff4>,</span><span style=color:#b48ead> 3</span><span style=color:#eceff4>,</span><span style=color:#b48ead> 5</span><span style=color:#eceff4>]</span></span>
<span class=giallo-l><span>iterator</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> iter</span><span style=color:#eceff4>(</span><span>primes</span><span style=color:#eceff4>)</span><span style=color:#616e88> # 调用 primes.__iter__()</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>try</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>    while True</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span>        elem</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> next</span><span style=color:#eceff4>(</span><span>iterator</span><span style=color:#eceff4>)</span><span style=color:#616e88> # 调用 iterator.__next__()</span></span>
<span class=giallo-l><span style=color:#88c0d0>        print</span><span style=color:#eceff4>(</span><span>elem</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>except</span><span style=color:#8fbcbb> StopIteration</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>    pass</span><span style=color:#616e88> # 循环结束</span></span></code></pre><p>这就是 Python <code>for</code> 循环背后的真相：它只是 <code>while</code> 循环 + 异常处理的语法糖。<h2 id=4-2-3-sheng-cheng-qi-generators>4.2.3 生成器 (Generators)</h2><p>虽然我们可以通过编写类并实现 <code>__iter__</code> 和 <code>__next__</code> 来创建迭代器，但这很繁琐。Python 提供了<strong>生成器函数</strong>，让这一切变得极其简单。<p>只要函数中包含 <code>yield</code> 关键字，它就变成了一个生成器函数。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> letters_generator</span><span style=color:#eceff4>():</span></span>
<span class=giallo-l><span>    current</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>a</span><span style=color:#eceff4>'</span></span>
<span class=giallo-l><span style=color:#81a1c1>    while</span><span> current</span><span style=color:#81a1c1> &lt;=</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>d</span><span style=color:#eceff4>':</span></span>
<span class=giallo-l><span style=color:#81a1c1>        yield</span><span> current</span></span>
<span class=giallo-l><span>        current</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> chr</span><span style=color:#eceff4>(</span><span style=color:#88c0d0>ord</span><span style=color:#eceff4>(</span><span>current</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> +</span><span style=color:#b48ead> 1</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>for</span><span> letter</span><span style=color:#81a1c1> in</span><span style=color:#88c0d0> letters_generator</span><span style=color:#eceff4>():</span></span>
<span class=giallo-l><span style=color:#88c0d0>    print</span><span style=color:#eceff4>(</span><span>letter</span><span style=color:#eceff4>)</span></span></code></pre><h3 id=sheng-cheng-qi-de-mo-fa>生成器的魔法</h3><p>当生成器函数被调用时，它<strong>不执行任何代码</strong>，而是立即返回一个生成器对象。<p>只有当你调用 <code>next()</code> 时，代码才开始执行，直到遇到 <code>yield</code>。此时：<ol><li>函数<strong>暂停</strong>执行。<li><code>yield</code> 后面的值被返回。<li>函数的<strong>状态（局部变量）被保存</strong>。</ol><p>下一次调用 <code>next()</code> 时，函数从上次暂停的地方<strong>恢复</strong>执行。<h2 id=4-2-4-shi-li-zi-ran-shu-xu-lie>4.2.4 实例：自然数序列</h2><p>生成器最强大的用途之一是表示<strong>无限序列</strong>。在传统的列表思维中，你无法创建一个包含所有自然数的列表。但在生成器思维中，这轻而易举：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> naturals</span><span style=color:#eceff4>():</span></span>
<span class=giallo-l><span>    x</span><span style=color:#81a1c1> =</span><span style=color:#b48ead> 1</span></span>
<span class=giallo-l><span style=color:#81a1c1>    while True</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        yield</span><span> x</span></span>
<span class=giallo-l><span>        x</span><span style=color:#81a1c1> +=</span><span style=color:#b48ead> 1</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88># 使用它</span></span>
<span class=giallo-l><span>ns</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> naturals</span><span style=color:#eceff4>()</span></span>
<span class=giallo-l><span style=color:#88c0d0>print</span><span style=color:#eceff4>(</span><span style=color:#88c0d0>next</span><span style=color:#eceff4>(</span><span>ns</span><span style=color:#eceff4>))</span><span style=color:#616e88> # 1</span></span>
<span class=giallo-l><span style=color:#88c0d0>print</span><span style=color:#eceff4>(</span><span style=color:#88c0d0>next</span><span style=color:#eceff4>(</span><span>ns</span><span style=color:#eceff4>))</span><span style=color:#616e88> # 2</span></span>
<span class=giallo-l><span style=color:#616e88># ... 可以永远继续下去</span></span></code></pre><p>我们可以编写通用的流处理函数来操作这些无限序列，例如 <code>map</code> 和 <code>filter</code> 的惰性版本：<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=python><span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> lazy_map</span><span style=color:#eceff4>(</span><span>func</span><span style=color:#eceff4>,</span><span> iterable</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>    for</span><span> x</span><span style=color:#81a1c1> in</span><span> iterable</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        yield</span><span style=color:#88c0d0> func</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>def</span><span style=color:#88c0d0> lazy_filter</span><span style=color:#eceff4>(</span><span>pred</span><span style=color:#eceff4>,</span><span> iterable</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>    for</span><span> x</span><span style=color:#81a1c1> in</span><span> iterable</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#81a1c1>        if</span><span style=color:#88c0d0> pred</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>):</span></span>
<span class=giallo-l><span style=color:#81a1c1>            yield</span><span> x</span></span></code></pre><h2 id=zong-jie>总结</h2><ul><li><strong>Iterable (可迭代对象)</strong>: 有 <code>__iter__</code> 方法，代表一个数据集（如 list, range）。可以被循环多次。<li><strong>Iterator (迭代器)</strong>: 有 <code>__next__</code> 方法，代表一个数据流的<strong>游标</strong>。只能消耗一次。<li><strong>Generator (生成器)</strong>: 编写迭代器的简便方式，利用 <code>yield</code> 实现状态保存和恢复。</ul><p>掌握生成器，意味着你从“静态数据处理”进化到了“流式数据处理”。这是构建高效、低内存消耗 Python 程序的基石，也是处理大数据流的核心思想。<hr><p><em>参考链接：</em><ul><li><a href=https://www.composingprograms.com/pages/42-implicit-sequences.html rel=external>Composing Programs 4.2 Implicit Sequences</a></ul></div></div></section>