<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Redis 源码阅读：04. ZipList & ListPack (内存紧凑之道) | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/redis/> /redis </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-10</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Redis 源码阅读：04. ZipList & ListPack (内存紧凑之道)</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>Redis 是一个<strong>内存</strong>数据库，内存就是成本。为了在存储小量数据时节省内存，Redis 设计了 ZipList（压缩列表）。但 ZipList 存在设计缺陷，因此 Redis 5.0 引入了 ListPack（紧凑列表）作为替代品，并将在 Redis 7.0+ 中逐步全面接管 ZipList 的职责。<h2 id=1-ziplist-ji-zhi-de-ya-suo-zhi-ming-de-que-xian>1. ZipList：极致的压缩，致命的缺陷</h2><p>ZipList 不是双向链表，而是一块<strong>连续的内存块</strong>。<h3 id=1-1-jie-gou-she-ji>1.1 结构设计</h3><p>一个 ZipList 的内存布局如下：<pre><code>&LTzlbytes> &LTzltail> &LTzllen> &LTentry> &LTentry> ... &LTentry> &LTzlend>
</code></pre><ul><li><code>zlbytes</code> (4字节): 总字节数。<li><code>zltail</code> (4字节): 尾节点偏移量（方便快速定位尾部，实现从尾向头遍历）。<li><code>zllen</code> (2字节): 节点数量。<li><code>zlend</code> (1字节): 结束标记 (0xFF)。</ul><p><strong>Entry (节点) 的结构：</strong><pre><code>&LTprevlen> &LTencoding> &LTentry-data>
</code></pre><ul><li><code>prevlen</code>: <strong>前一个节点的长度</strong>。这是实现从后向前遍历的关键。<li><code>encoding</code>: 编码类型（是整数还是字符串，长度是多少）。<li><code>entry-data</code>: 实际数据。</ul><h3 id=1-2-lian-suo-geng-xin-cascading-update-ziplist-de-a-ke-liu-si-zhi-zhong>1.2 连锁更新 (Cascading Update) —— ZipList 的阿喀琉斯之踵</h3><p>问题出在 <code>prevlen</code> 字段上。<ul><li>如果前一个节点长度 < 254 字节，<code>prevlen</code> 占用 <strong>1 字节</strong>。<li>如果前一个节点长度 >= 254 字节，<code>prevlen</code> 占用 <strong>5 字节</strong>。</ul><p><strong>场景模拟：</strong> 假设有一个 ZipList，包含多个长度为 253 字节的节点（E1, E2, E3…）。此时它们的 <code>prevlen</code> 都是 1 字节。 现在，我们将 E1 的数据更新为 254 字节。<ol><li>E2 的 <code>prevlen</code> 需要记录 E1 的长度，发现 E1 变大了，<code>prevlen</code> 必须从 1 字节扩展到 5 字节。<li>E2 整体长度增加了 4 字节，变成了 253 + 4 = 257 字节。<li>E3 的 <code>prevlen</code> 需要记录 E2 的长度，发现 E2 也变大了…<li>多米诺骨牌效应触发，后面所有的节点都需要重新分配内存并移动数据。</ol><p>这就是<strong>连锁更新</strong>，最坏情况下时间复杂度为 O(N^2)。这也是为什么 Redis 限制 ZipList 只能存少量数据的原因。<h2 id=2-listpack-wan-mei-de-ji-ren-zhe>2. ListPack：完美的继任者</h2><p>ListPack (紧凑列表) 的设计目标就是：保持 ZipList 紧凑内存布局的同时，彻底解决连锁更新问题。<h3 id=2-1-jie-gou-she-ji>2.1 结构设计</h3><p>ListPack 的整体结构与 ZipList 类似，但更简单：<pre><code>&LTtotbytes> &LTnum-elements> &LTelement> &LTelement> ... &LTend-byte>
</code></pre><p><strong>Element (节点) 的结构变了：</strong><pre><code>&LTencoding-type> &LTelement-data> &LTelement-tot-len>
</code></pre><ul><li><code>encoding-type</code>: 编码类型。<li><code>element-data</code>: 数据。<li><code>element-tot-len</code>: <strong>当前节点的总长度</strong> (包含 encoding 和 data)。</ul><h3 id=2-2-wei-shen-me-listpack-mei-you-lian-suo-geng-xin>2.2 为什么 ListPack 没有连锁更新？</h3><p>关键在于：ListPack 的节点<strong>不再保存前一个节点的长度</strong>，只保存<strong>当前节点的长度</strong>。<ul><li><strong>正向遍历</strong>：根据 <code>encoding</code> 解析出数据长度，跳到下一个节点。<li><strong>反向遍历</strong>：读取当前节点末尾的 <code>element-tot-len</code>，回退相应的字节数，找到前一个节点的末尾。</ul><p>因为每个节点的长度只与自己有关，修改一个节点永远不会影响下一个节点的长度字段。<strong>彻底根除了连锁更新</strong>。<h2 id=3-zong-jie>3. 总结</h2><ul><li><strong>ZipList</strong>: 为了省内存而生，但 <code>prevlen</code> 的变长设计导致了潜在的性能风险。<li><strong>ListPack</strong>: 站在巨人的肩膀上，保留了紧凑布局的优点，通过改变长度记录方式（存自身长度而非前驱长度），完美解决了连锁更新问题。</ul><p>在 Redis 7.0 中，ListPack 已经替代 ZipList 用于实现 Hash (当元素少时) 和 ZSet (当元素少时)。ZipList 正在逐渐退出历史舞台。</div></div></section>