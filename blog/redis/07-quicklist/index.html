<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Redis 源码阅读：07. QuickList (快速列表) | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/redis/> /redis </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-10</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Redis 源码阅读：07. QuickList (快速列表)</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>在 Redis 3.2 之前，List 对象的底层实现是：当数据少时用 ZipList，数据多时用 LinkedList (标准双向链表)。<p>但标准双向链表有两个问题：<ol><li><strong>内存开销大</strong>：每个节点除了存数据，还需要存 prev/next 指针 (16 字节)。<li><strong>内存碎片</strong>：每个节点都是独立分配的，容易产生碎片，缓存命中率低。</ol><p>为了解决这个问题，Redis 3.2 引入了 <strong>QuickList (快速列表)</strong>，统一了 List 的底层实现。<h2 id=1-jie-gou-she-ji>1. 结构设计</h2><p>QuickList 是 <strong>LinkedList + ZipList</strong> 的混合体。<p>宏观上看，它是一个双向链表。 微观上看，链表中的<strong>每个节点 (Node) 都是一个 ZipList</strong>。<pre class=language-c data-lang=c><code class=language-c data-lang=c>typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;        // 所有元素总数
    unsigned long len;          // 链表节点 (ZipList) 数量
    int fill : QL_FILL_BITS;    // 单个节点的填充因子
    unsigned int compress : QL_COMP_BITS; // 压缩深度
    // ...
} quicklist;

typedef struct quicklistNode {
    struct quicklistNode *prev;
    struct quicklistNode *next;
    unsigned char *zl;           // 指向 ZipList 的指针
    unsigned int sz;             // ZipList 的字节大小
    unsigned int count : 16;     // ZipList 中的元素数量
    unsigned int encoding : 2;   // 编码方式 (RAW 或 LZF 压缩)
    // ...
} quicklistNode;
</code></pre><h2 id=2-quan-heng-de-yi-shu>2. 权衡的艺术</h2><p>QuickList 的设计核心在于平衡 <strong>内存</strong> 与 <strong>CPU</strong>。<ul><li><strong>如果一个节点存太多元素</strong>：它就退化成了一个大 ZipList，虽然极省内存，但更新性能差（连锁更新）。<li><strong>如果一个节点存太少元素</strong>：它就退化成了标准 LinkedList，内存开销大。</ul><p>Redis 通过 <code>list-max-ziplist-size</code> 参数（对应 <code>fill</code> 字段）来控制每个 ZipList 节点的大小，寻找最佳平衡点。<h2 id=3-liang-duan-ya-suo>3. 两端压缩</h2><p>List 通常用于队列或栈，操作主要集中在头尾。中间的数据很少被访问。 因此，QuickList 支持 <strong>LZF 压缩</strong>。除了头尾两端的 N 个节点外，中间的节点可以被压缩存储，进一步节省内存。由 <code>list-compress-depth</code> 参数控制。</div></div></section>