<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Redis 源码阅读：系列大纲与学习路径 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/redis/> /redis </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-10</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Redis 源码阅读：系列大纲与学习路径</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><blockquote><p><strong>千里之行，始于足下。</strong><p>Redis 源码博大精深，为了避免在浩如烟海的代码中迷失方向，制定一个清晰的阅读大纲至关重要。本文作为本系列的“第 0 篇”，旨在规划一条从底层到上层、从单机到集群的学习路径。</blockquote><p>本系列将基于 <strong>Redis 7.2</strong> 版本源码进行解读。<h2 id=map-zheng-ti-lan-tu>🗺️ 整体蓝图</h2><p>我们将 Redis 源码阅读分为七个阶段：<ol><li><strong>基础篇</strong>：万丈高楼平地起，搞懂 Redis 独特的底层数据结构。<li><strong>对象篇</strong>：理解 Redis 如何在底层结构之上构建出 String, List, Hash 等对外类型。<li><strong>核心篇</strong>：深入 Redis 的心脏 —— 事件循环与网络模型。<li><strong>数据库篇</strong>：探索键值对存储、过期策略与内存淘汰。<li><strong>持久化篇</strong>：RDB 与 AOF 如何保障数据安全。<li><strong>分布式篇</strong>：主从复制、哨兵与集群的实现原理。<li><strong>进阶篇</strong>：事务、Lua 脚本、Stream 等高级特性。</ol><hr><h2 id=books-xiang-xi-da-gang-chi-xu-geng-xin>📚 详细大纲 (持续更新)</h2><h3 id=phase-1-di-ceng-shu-ju-jie-gou-the-foundation>Phase 1: 底层数据结构 (The Foundation)</h3><p>Redis 为了追求极致性能，造了许多“轮子”。这些数据结构是理解 Redis 的基石。<ul><li><strong>[01. 源码地图与环境搭建]({{< ref “01-redis-source-code-map.md” >}})</strong> <ul><li>源码目录概览<li>开发环境配置 (VS Code/CLion)<li>调试技巧</ul><li><strong>02. SDS (Simple Dynamic String)</strong> <ul><li>C 字符串的痛点<li>SDS 结构设计与二进制安全<li>预分配与惰性释放</ul><li><strong>03. Dict (Dictionary)</strong> <ul><li>哈希表实现<li>哈希冲突解决 (链地址法)<li><strong>核心：渐进式 Rehash (Progressive Rehash)</strong> 详解</ul><li><strong>04. ZipList & ListPack</strong> <ul><li>内存紧凑型结构的设计哲学<li>ZipList 的连锁更新问题<li>ListPack 如何解决连锁更新</ul><li><strong>05. IntSet (Integer Set)</strong> <ul><li>整数集合的编码升级</ul><li><strong>06. SkipList (跳表)</strong> <ul><li>为什么 ZSet 用跳表而不用红黑树？<li>跳表的概率平衡机制</ul><li><strong>07. QuickList</strong> <ul><li>双向链表与压缩列表的混合体</ul></ul><h3 id=phase-2-dui-xiang-xi-tong-object-system>Phase 2: 对象系统 (Object System)</h3><p>连接底层结构与用户命令的桥梁。<ul><li><strong>08. redisObject 详解</strong> <ul><li>类型 (type) 与 编码 (encoding)<li>LRU/LFU 字段与内存淘汰的关联</ul><li><strong>09. String 对象</strong> <ul><li>int, embstr, raw 三种编码的区别与转换</ul><li><strong>10. List, Hash, Set, ZSet 对象</strong> <ul><li>不同场景下的编码选择与转换策略</ul></ul><h3 id=phase-3-he-xin-jia-gou-the-engine>Phase 3: 核心架构 (The Engine)</h3><p>Redis 为什么单线程还能这么快？<ul><li><strong>11. 启动流程</strong> <ul><li><code>server.c</code> 的 main 函数全解析<li>配置加载与初始化</ul><li><strong>12. AE 事件库 (Async Event)</strong> <ul><li>Reactor 模式<li>IO 多路复用 (epoll/kqueue/select) 封装<li>文件事件与时间事件</ul><li><strong>13. 网络层 (Networking)</strong> <ul><li>连接建立 (Accept)<li>请求读取与协议解析 (RESP)<li>命令回复缓冲区 (Client Output Buffer)</ul><li><strong>14. 命令执行模型</strong> <ul><li><code>processCommand</code> 流程<li>命令表查找与校验</ul></ul><h3 id=phase-4-shu-ju-ku-shi-xian-database>Phase 4: 数据库实现 (Database)</h3><p>作为数据库的核心职能。<ul><li><strong>15. DB 结构</strong> <ul><li><code>redisDb</code> 结构体<li>键空间 (Key Space) 与过期字典</ul><li><strong>16. 过期策略 (Expiration)</strong> <ul><li>惰性删除 (Lazy Expire)<li>定期删除 (Active Expire) 的实现细节</ul><li><strong>17. 内存淘汰机制 (Eviction)</strong> <ul><li>maxmemory 处理流程<li>LRU 与 LFU 的近似实现算法</ul></ul><h3 id=phase-5-chi-jiu-hua-persistence>Phase 5: 持久化 (Persistence)</h3><ul><li><strong>18. RDB (Redis Database)</strong> <ul><li>快照原理<li><code>fork</code> 与 Copy-On-Write (COW)<li>rdbSave 与 rdbLoad</ul><li><strong>19. AOF (Append Only File)</strong> <ul><li>命令追加与磁盘同步策略 (fsync)<li>AOF 重写 (Rewrite) 原理与管道通信</ul></ul><h3 id=phase-6-fen-bu-shi-distributed>Phase 6: 分布式 (Distributed)</h3><ul><li><strong>20. 主从复制 (Replication)</strong> <ul><li>全量复制与部分复制 (PSYNC)<li>复制积压缓冲区 (Replication Backlog)</ul><li><strong>21. Sentinel (哨兵)</strong> <ul><li>监控与主观/客观下线<li>Leader 选举与故障转移</ul><li><strong>22. Cluster (集群)</strong> <ul><li>Hash Slot (槽) 分配<li>MOVED 与 ASK 重定向<li>Gossip 协议</ul></ul><h3 id=phase-7-jin-jie-yu-cai-dan-advanced>Phase 7: 进阶与彩蛋 (Advanced)</h3><ul><li><strong>23. 事务 (Transaction)</strong> <ul><li>MULTI, EXEC, WATCH 实现<li>为什么 Redis 事务不支持回滚？</ul><li><strong>24. Lua 脚本</strong> <ul><li>Lua 环境初始化与调用</ul><li><strong>25. Stream</strong> <ul><li>Radix Tree (基数树) 实现</ul><li><strong>26. 其它</strong> <ul><li>HyperLogLog<li>Geo<li>Bloom Filter (Module)</ul></ul><hr><h2 id=dart-yue-du-jian-yi>🎯 阅读建议</h2><ol><li><strong>不要死磕每一行代码</strong>：Redis 源码注释非常详细，但代码量依然很大。初读时建议关注核心逻辑，忽略边界检查和异常处理。<li><strong>多动手调试</strong>：使用 IDE (如 CLion/VS Code) 打断点，观察变量变化，比单纯看代码效率高十倍。<li><strong>画图</strong>：对于复杂的数据结构（如 Dict, SkipList），画图能极大帮助理解。</ol><p>让我们开始这段奇妙的源码之旅吧！</div></div></section>