<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Java Double List 去除突刺点（异常值）的方法 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2025-11-12</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Java Double List 去除突刺点（异常值）的方法</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>本文面向需要在 Java 中对 <code>List&LTDouble></code> 数据做“去除突刺点（异常值）”的工程实践，给出 4 类常用方法（统计学、移动窗口、相邻点距离与多方法融合），并提供完整可运行的代码与 JUnit 测试示例，帮助你在不同业务场景下快速选择与落地。<p>注意：异常值并非总是“错误”。许多业务的“尖峰”有可能是合理的事件。本文更像一套工具箱，你需要结合业务知识合理使用与调参。<h2 id=1-ji-yu-tong-ji-xue-fang-fa-de-yi-chang-zhi-jian-ce>1. 基于统计学方法的异常值检测</h2><h3 id=z-score-fang-fa>Z-Score 方法</h3><ul><li>思想：计算全局均值 <code>μ</code> 与标准差 <code>σ</code>，当某点 <code>x</code> 满足 <code>| (x-μ) / σ | > k</code>（常用阈值 <code>k=3</code>）时，判为异常。<li>适用：近似正态分布、峰值显著偏离整体均值的场景。</ul><h3 id=iqr-si-fen-wei-ju-fang-fa>IQR (四分位距) 方法</h3><ul><li>思想：计算 Q1、Q3 与 IQR=<code>Q3-Q1</code>，当点落在 <code>[Q1 - α·IQR, Q3 + α·IQR]</code> 之外（常用 <code>α=1.5</code> 或 <code>3.0</code>）判为异常。<li>适用：偏态分布或存在重尾时较稳健（受极端值影响较小）。</ul><h2 id=2-ji-yu-yi-dong-chuang-kou-de-yi-chang-zhi-jian-ce>2. 基于移动窗口的异常值检测</h2><h3 id=hua-dong-chuang-kou-z-score>滑动窗口 Z-Score</h3><ul><li>思想：用邻域窗口的均值与标准差代替全局统计，适合非平稳或趋势性数据。</ul><h3 id=yi-dong-ping-jun-fa>移动平均法</h3><ul><li>思想：用窗口均值/中位数做局部“期望值”，当当前点偏离窗口均值超过一定阈值即判异常。<li>常见阈值：绝对差超过 <code>β·σ_window</code> 或超过固定常数 <code>δ</code>。</ul><h2 id=3-ji-yu-xiang-lin-dian-ju-chi-de-yi-chang-zhi-jian-ce>3. 基于相邻点距离的异常值检测</h2><ul><li>思想：突刺常表现为与相邻点差值显著增大。可用固定阈值或鲁棒阈值（如差值的 <code>MAD</code> 或四分位距）来判断。</ul><h2 id=4-zong-he-duo-chong-fang-fa-de-yi-chang-zhi-jian-ce>4. 综合多种方法的异常值检测</h2><ul><li>思想：多模型投票或加权融合。只有当多个方法一致判定为异常时才去除，可降低误杀风险。</ul><h2 id=5-wan-zheng-dai-ma-outlierdetectors-java-ke-zhi-jie-fu-zhi-shi-yong>5. 完整代码：OutlierDetectors.java（可直接复制使用）</h2><pre class=language-java data-lang=java><code class=language-java data-lang=java>import java.util.*;
import java.util.stream.*;

public final class OutlierDetectors {

    private OutlierDetectors() {}

    // ===================== 公共工具与预处理 =====================
    public static List&LTDouble> dropNullAndNaN(List&LTDouble> data) {
        if (data == null) return Collections.emptyList();
        List&LTDouble> cleaned = new ArrayList<>(data.size());
        for (Double d : data) {
            if (d != null && !d.isNaN() && !d.isInfinite()) {
                cleaned.add(d);
            }
        }
        return cleaned;
    }

    public static double mean(List&LTDouble> data) {
        if (data.isEmpty()) return 0.0;
        double s = 0.0;
        for (double v : data) s += v;
        return s / data.size();
    }

    // 样本标准差（n-1），窗口过小则回退为 0
    public static double sampleStd(List&LTDouble> data) {
        int n = data.size();
        if (n <= 1) return 0.0;
        double mu = mean(data);
        double sumSq = 0.0;
        for (double v : data) {
            double d = v - mu;
            sumSq += d * d;
        }
        return Math.sqrt(sumSq / (n - 1));
    }

    public static double median(List&LTDouble> data) {
        if (data.isEmpty()) return 0.0;
        List&LTDouble> sorted = new ArrayList<>(data);
        Collections.sort(sorted);
        int n = sorted.size();
        if (n % 2 == 1) return sorted.get(n / 2);
        return (sorted.get(n / 2 - 1) + sorted.get(n / 2)) / 2.0;
    }

    public static double[] quartiles(List&LTDouble> data) {
        // 简单实现，适用于一般场景；严谨场景可使用更精细的分位数算法
        List&LTDouble> sorted = new ArrayList<>(data);
        Collections.sort(sorted);
        int n = sorted.size();
        if (n == 0) return new double[]{0, 0, 0};
        double q2 = median(sorted);
        List&LTDouble> lower = sorted.subList(0, n / 2);
        List&LTDouble> upper = sorted.subList((n % 2 == 0 ? n / 2 : n / 2 + 1), n);
        double q1 = median(lower);
        double q3 = median(upper);
        return new double[]{q1, q2, q3};
    }

    public static double mad(List&LTDouble> data) {
        double med = median(data);
        List&LTDouble> dev = data.stream().map(v -> Math.abs(v - med)).collect(Collectors.toList());
        return median(dev);
    }

    // 根据掩码移除异常值
    public static List&LTDouble> removeByMask(List&LTDouble> data, List&LTBoolean> isOutlier) {
        List&LTDouble> out = new ArrayList<>(data.size());
        for (int i = 0; i < data.size(); i++) {
            if (!isOutlier.get(i)) out.add(data.get(i));
        }
        return out;
    }

    // ===================== 1) 统计学：Z-Score =====================
    public static List&LTBoolean> detectByZScore(List&LTDouble> data, double k) {
        List&LTDouble> cleaned = dropNullAndNaN(data);
        double mu = mean(cleaned);
        double std = sampleStd(cleaned);
        if (std == 0.0) {
            // 如果方差为 0，则所有值都相同；默认无异常
            return Collections.nCopies(data.size(), false);
        }
        List&LTBoolean> mask = new ArrayList<>(data.size());
        for (Double x : data) {
            boolean out = (x == null || x.isNaN() || x.isInfinite()) ? true : Math.abs((x - mu) / std) > k;
            mask.add(out);
        }
        return mask;
    }

    public static List&LTDouble> removeByZScore(List&LTDouble> data, double k) {
        return removeByMask(data, detectByZScore(data, k));
    }

    // ===================== 1) 统计学：IQR =====================
    public static List&LTBoolean> detectByIQR(List&LTDouble> data, double alpha) {
        List&LTDouble> cleaned = dropNullAndNaN(data);
        if (cleaned.isEmpty()) return Collections.nCopies(data.size(), false);
        double[] qs = quartiles(cleaned);
        double q1 = qs[0], q3 = qs[2];
        double iqr = q3 - q1;
        double lo = q1 - alpha * iqr;
        double hi = q3 + alpha * iqr;
        List&LTBoolean> mask = new ArrayList<>(data.size());
        for (Double x : data) {
            boolean out = (x == null || x.isNaN() || x.isInfinite()) ? true : (x < lo || x > hi);
            mask.add(out);
        }
        return mask;
    }

    public static List&LTDouble> removeByIQR(List&LTDouble> data, double alpha) {
        return removeByMask(data, detectByIQR(data, alpha));
    }

    // ===================== 2) 滑动窗口 Z-Score =====================
    public static List&LTBoolean> detectBySlidingZScore(List&LTDouble> data, int window, double k) {
        int n = data.size();
        List&LTBoolean> mask = new ArrayList<>(Collections.nCopies(n, false));
        for (int i = 0; i < n; i++) {
            int start = Math.max(0, i - window);
            int end = Math.min(n, i + window + 1);
            List&LTDouble> neigh = new ArrayList<>();
            for (int j = start; j < end; j++) {
                Double v = data.get(j);
                if (v != null && !v.isNaN() && !v.isInfinite()) neigh.add(v);
            }
            double mu = mean(neigh);
            double std = sampleStd(neigh);
            Double x = data.get(i);
            boolean out = (x == null || x.isNaN() || x.isInfinite()) ? true : (std == 0.0 ? false : Math.abs((x - mu) / std) > k);
            mask.set(i, out);
        }
        return mask;
    }

    public static List&LTDouble> removeBySlidingZScore(List&LTDouble> data, int window, double k) {
        return removeByMask(data, detectBySlidingZScore(data, window, k));
    }

    // ===================== 2) 移动平均法 =====================
    public static List&LTBoolean> detectByMovingAverage(List&LTDouble> data, int window, double beta) {
        int n = data.size();
        List&LTBoolean> mask = new ArrayList<>(Collections.nCopies(n, false));
        for (int i = 0; i < n; i++) {
            int start = Math.max(0, i - window);
            int end = Math.min(n, i + window + 1);
            List&LTDouble> neigh = new ArrayList<>();
            for (int j = start; j < end; j++) {
                Double v = data.get(j);
                if (v != null && !v.isNaN() && !v.isInfinite()) neigh.add(v);
            }
            double mu = mean(neigh);
            double std = sampleStd(neigh);
            Double x = data.get(i);
            boolean out = (x == null || x.isNaN() || x.isInfinite()) ? true : Math.abs(x - mu) > beta * (std == 0.0 ? 1.0 : std);
            mask.set(i, out);
        }
        return mask;
    }

    public static List&LTDouble> removeByMovingAverage(List&LTDouble> data, int window, double beta) {
        return removeByMask(data, detectByMovingAverage(data, window, beta));
    }

    // ===================== 3) 相邻点距离 =====================
    public static List&LTBoolean> detectByNeighborDistance(List&LTDouble> data, double threshold, boolean robust) {
        int n = data.size();
        if (n == 0) return Collections.emptyList();
        List&LTDouble> diffs = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            Double a = data.get(i - 1), b = data.get(i);
            if (a == null || b == null || a.isNaN() || b.isNaN() || a.isInfinite() || b.isInfinite()) continue;
            diffs.add(Math.abs(b - a));
        }
        double base;
        if (robust) {
            double m = median(diffs);
            double mdev = mad(diffs);
            base = m + 3.0 * (mdev == 0.0 ? 1.0 : mdev);
        } else {
            base = diffs.isEmpty() ? threshold : mean(diffs) + 3.0 * sampleStd(diffs);
        }
        double th = Math.max(threshold, base); // 使用用户阈值与数据驱动阈值的较大者

        List&LTBoolean> mask = new ArrayList<>(Collections.nCopies(n, false));
        for (int i = 0; i < n; i++) {
            Double x = data.get(i);
            if (x == null || x.isNaN() || x.isInfinite()) { mask.set(i, true); continue; }
            double left = (i > 0 && data.get(i - 1) != null && !data.get(i - 1).isNaN() && !data.get(i - 1).isInfinite()) ? Math.abs(x - data.get(i - 1)) : 0.0;
            double right = (i < n - 1 && data.get(i + 1) != null && !data.get(i + 1).isNaN() && !data.get(i + 1).isInfinite()) ? Math.abs(x - data.get(i + 1)) : 0.0;
            boolean out = left > th && right > th; // 两侧距离都大更像“尖刺”
            mask.set(i, out);
        }
        return mask;
    }

    public static List&LTDouble> removeByNeighborDistance(List&LTDouble> data, double threshold, boolean robust) {
        return removeByMask(data, detectByNeighborDistance(data, threshold, robust));
    }

    // ===================== 4) 多方法融合（投票） =====================
    public static class CombinedParams {
        public double zK = 3.0;            // 全局 Z-Score 阈值
        public double iqrAlpha = 1.5;      // IQR 系数
        public int slideWindow = 5;        // 滑动窗口大小（左右各 window）
        public double slideK = 3.0;        // 滑动 Z-Score 阈值
        public double maBeta = 3.0;        // 移动均值偏差倍数
        public double neighborThreshold = 0.0; // 最小固定距离阈值
        public boolean neighborRobust = true;  // 使用鲁棒阈值
        public int votesRequired = 2;      // 至少多少方法判为异常
    }

    public static List&LTBoolean> detectByCombined(List&LTDouble> data, CombinedParams p) {
        List&LTBoolean> m1 = detectByZScore(data, p.zK);
        List&LTBoolean> m2 = detectByIQR(data, p.iqrAlpha);
        List&LTBoolean> m3 = detectBySlidingZScore(data, p.slideWindow, p.slideK);
        List&LTBoolean> m4 = detectByMovingAverage(data, p.slideWindow, p.maBeta);
        List&LTBoolean> m5 = detectByNeighborDistance(data, p.neighborThreshold, p.neighborRobust);
        int n = data.size();
        List&LTBoolean> out = new ArrayList<>(Collections.nCopies(n, false));
        for (int i = 0; i < n; i++) {
            int votes = 0;
            if (m1.get(i)) votes++;
            if (m2.get(i)) votes++;
            if (m3.get(i)) votes++;
            if (m4.get(i)) votes++;
            if (m5.get(i)) votes++;
            out.set(i, votes >= p.votesRequired);
        }
        return out;
    }

    public static List&LTDouble> removeByCombined(List&LTDouble> data, CombinedParams p) {
        return removeByMask(data, detectByCombined(data, p));
    }

    // ===================== 5) 演示用主程序 =====================
    public static void main(String[] args) {
        List&LTDouble> raw = Arrays.asList(
                10.0, 10.5, 10.2, 9.9, 10.1,
                45.0, // 突刺
                10.0, 9.8, 10.3, 10.2,
                -30.0, // 负向突刺
                10.1, 9.9, 10.0
        );

        System.out.println("原始数据:  " + raw);
        System.out.println("Z-Score 清洗: " + removeByZScore(raw, 3.0));
        System.out.println("IQR 清洗:     " + removeByIQR(raw, 1.5));
        System.out.println("滑动Z 清洗:   " + removeBySlidingZScore(raw, 3, 3.0));
        System.out.println("移动均值 清洗: " + removeByMovingAverage(raw, 3, 3.0));
        System.out.println("相邻距离 清洗: " + removeByNeighborDistance(raw, 0.0, true));

        CombinedParams p = new CombinedParams();
        p.votesRequired = 2; // 至少两种方法判为异常才移除
        System.out.println("融合清洗:     " + removeByCombined(raw, p));
    }
}
</code></pre><h2 id=6-ce-shi-yong-li-junit-5>6. 测试用例（JUnit 5）</h2><pre class=language-java data-lang=java><code class=language-java data-lang=java>import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;

public class OutlierDetectorsTest {

    @Test
    void zscore_removes_spikes() {
        List&LTDouble> data = Arrays.asList(10.0, 10.2, 10.1, 50.0, 9.9, 10.0);
        List&LTDouble> cleaned = OutlierDetectors.removeByZScore(data, 3.0);
        assertFalse(cleaned.contains(50.0));
        assertTrue(cleaned.size() >= 4);
    }

    @Test
    void iqr_handles_skewed() {
        List&LTDouble> data = Arrays.asList(1.0, 1.1, 1.2, 5.0, 1.0, 0.9);
        List&LTDouble> cleaned = OutlierDetectors.removeByIQR(data, 1.5);
        assertFalse(cleaned.contains(5.0));
    }

    @Test
    void sliding_zscore_detects_local_spike() {
        List&LTDouble> data = Arrays.asList(10.0, 10.1, 30.0, 10.2, 10.1);
        List&LTDouble> cleaned = OutlierDetectors.removeBySlidingZScore(data, 2, 2.5);
        assertFalse(cleaned.contains(30.0));
    }

    @Test
    void moving_average_removes_outliers() {
        List&LTDouble> data = Arrays.asList(100.0, 100.1, 99.9, 400.0, 100.0);
        List&LTDouble> cleaned = OutlierDetectors.removeByMovingAverage(data, 2, 3.0);
        assertFalse(cleaned.contains(400.0));
    }

    @Test
    void neighbor_distance_catches_spike_between_flat_values() {
        List&LTDouble> data = Arrays.asList(10.0, 10.0, 50.0, 10.0, 10.0);
        List&LTDouble> cleaned = OutlierDetectors.removeByNeighborDistance(data, 0.0, true);
        assertFalse(cleaned.contains(50.0));
    }

    @Test
    void combined_voting_is_conservative() {
        List&LTDouble> data = Arrays.asList(10.0, 10.1, 11.0, 10.2, 10.0);
        OutlierDetectors.CombinedParams p = new OutlierDetectors.CombinedParams();
        p.votesRequired = 2;
        List&LTDouble> cleaned = OutlierDetectors.removeByCombined(data, p);
        // 11.0 不一定被去除（取决于窗口与阈值），这里检查不发生误杀（示例）
        assertTrue(cleaned.contains(11.0));
    }
}
</code></pre><h2 id=7-shi-ji-ying-yong-shi-li>7. 实际应用示例</h2><p>例如 IoT 设备的温度读数，每分钟一个点，偶尔出现硬件抖动导致的尖峰。建议：<ul><li>先用“滑动窗口 Z-Score（window=5，k=3）”检测局部异常。<li>再用“相邻点距离（robust=true）”做二次确认。<li>两者都判异常才移除（<code>votesRequired=2</code>）。</ul><p>这样可以兼顾对局部突变的敏感性与稳健性，降低误杀风险。<h2 id=8-xing-neng-you-hua-jian-yi>8. 性能优化建议</h2><ul><li>预计算滚动均值/方差（O(n)），避免重复遍历。<li>大数据量时优先选用 IQR/MAD 等一次扫描算法。<li>使用并行流或分块处理提升吞吐（注意线程安全）。<li>对近似实时流，优先滑窗方法，避免全量重算。<li>对多次查询的静态数据，缓存中间统计结果。</ul><h2 id=9-zhu-yi-shi-xiang-qiang-lie-tui-jian-shi-jian>9. 注意事项（强烈推荐实践）</h2><ul><li>数据预处理：在检测异常值之前，先过滤掉 NULL 值和 NaN 值。<li>参数选择：根据具体业务场景调整阈值（如 Z-Score 的 k、IQR 的 α、滑窗大小、β 等）。<li>数据分布：考虑数据分布特性，正态更适合 Z-Score，偏态/重尾用 IQR/MAD 更稳健。<li>性能考虑：大数据量时使用近似方法或并行处理；滚动统计更高效。<li>业务逻辑：结合业务知识判断哪些“异常值”实际上是合理的事件，不要轻易删除。</ul><h2 id=10-dai-ma-yun-xing-shuo-ming-ke-xuan>10. 代码运行说明（可选）</h2><ul><li>复制 <code>OutlierDetectors.java</code> 与测试到你的工程。<li>使用 Maven/Gradle 引入 JUnit 5 后运行测试。<li>或直接 <code>javac OutlierDetectors.java</code> 后运行 <code>java OutlierDetectors</code> 查看演示输出。</ul><p>以上方法可根据你的具体需求进行选择和调整，以有效去除 Double 列表中的突刺点。</div></div></section>