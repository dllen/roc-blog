<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>03. 高阶函数：抽象的艺术与软件设计哲学 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/sicp-with-python/> /sicp-with-python </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-02-07</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">03. 高阶函数：抽象的艺术与软件设计哲学</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=di-san-zhang-gao-jie-han-shu-chou-xiang-de-yi-shu-yu-ruan-jian-she-ji-zhe-xue>第三章：高阶函数——抽象的艺术与软件设计哲学</h1><blockquote><p>“Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new ‘features’.”<br> — Doug McIlroy (UNIX Philosophy)</blockquote><p>在前面的章节中，我们学习了如何通过函数抽象具体的<strong>值</strong>和<strong>操作</strong>。现在，我们将进入更抽象的领域：<strong>高阶函数 (Higher-Order Functions)</strong>。<p>这不仅仅是一个语法特性，它是<strong>软件复用</strong>和<strong>系统解耦</strong>的基石。在这一章，我们将不仅仅学习“怎么写”，更要结合 <strong>UNIX 哲学</strong> 和 <strong>设计模式</strong> 来探讨“为什么这么写”。<h2 id=1-6-gao-jie-han-shu-higher-order-functions>1.6 高阶函数 (Higher-Order Functions)</h2><p>如果说普通函数是将<strong>数据</strong>作为参数，那么高阶函数则是将<strong>逻辑</strong>作为参数。它允许我们将“做什么”和“怎么做”分离开来。<h3 id=1-6-1-zuo-wei-can-shu-de-han-shu-functions-as-arguments>1.6.1 作为参数的函数 (Functions as Arguments)</h3><p>让我们看一个经典的例子：求和。<pre class=language-python data-lang=python><code class=language-python data-lang=python>def sum_naturals(n):
    """Sum of the first n natural numbers."""
    total, k = 0, 1
    while k <= n:
        total, k = total + k, k + 1
    return total

def sum_cubes(n):
    """Sum of the first n cubes of natural numbers."""
    total, k = 0, 1
    while k <= n:
        total, k = total + pow(k, 3), k + 1
    return total
</code></pre><p><strong>设计嗅觉 (Code Smell)</strong>：这两个函数极其相似，只有 <code>k</code> 和 <code>pow(k, 3)</code> 这一处不同。这违反了 <strong>DRY (Don’t Repeat Yourself)</strong> 原则。<p>在传统的面向对象设计模式中，我们会想到 <strong>策略模式 (Strategy Pattern)</strong> —— 定义一系列算法，把它们封装起来，并且使它们可互换。<p>在函数式编程中，这变得异常简单：<pre class=language-python data-lang=python><code class=language-python data-lang=python>def summation(n, term):
    """
    通用求和函数。
    :param n: 上界
    :param term: 一个函数，决定如何计算每一项
    """
    total, k = 0, 1
    while k <= n:
        total, k = total + term(k), k + 1
    return total

def cube(x):
    return x * x * x

def sum_cubes(n):
    return summation(n, cube)
</code></pre><p><strong>深度思考</strong>：<ul><li><code>summation</code> 表达了“求和”这个通用的<strong>控制流</strong>。<li><code>cube</code> 表达了“计算立方”这个具体的<strong>策略</strong>。<li>我们将<strong>机制 (Mechanism)</strong> 与 <strong>策略 (Policy)</strong> 分离了，这正是操作系统设计（如《深入理解计算机系统》中所述）的核心原则之一。</ul><h3 id=1-6-2-zuo-wei-fan-hui-zhi-de-han-shu-functions-as-general-methods>1.6.2 作为返回值的函数 (Functions as General Methods)</h3><p>UNIX 哲学强调<strong>组合 (Composition)</strong>：小工具通过管道连接成大系统。在 Python 中，我们可以编写“制造函数的函数”来实现这种组合。<pre class=language-python data-lang=python><code class=language-python data-lang=python>def make_adder(n):
    """Return a function that takes one argument k and returns k + n."""
    def adder(k):
        return k + n
    return adder
</code></pre><p>这对应于设计模式中的 <strong>工厂模式 (Factory Pattern)</strong>，但更加轻量。<pre class=language-python data-lang=python><code class=language-python data-lang=python>>>> add_three = make_adder(3)
>>> add_three(4)
7
</code></pre><p>这里的 <code>make_adder</code> 创建了一个<strong>闭包 (Closure)</strong>。<code>adder</code> 函数不仅记住了代码，还记住了它定义时的环境（即 <code>n=3</code>）。这通过<strong>环境图</strong>可以清晰地看到：<code>adder</code> 的帧指向了 <code>make_adder</code> 的帧。<h3 id=1-6-3-lambda-biao-da-shi-yu-ni-ming-han-shu>1.6.3 Lambda 表达式与匿名函数</h3><p>有时我们不需要给策略起名字，只需要“用完即走”。<pre class=language-python data-lang=python><code class=language-python data-lang=python>>>> summation(3, lambda x: x * x * x)
36
</code></pre><p>Lambda 表达式让代码更紧凑，但要小心使用。如果逻辑复杂，定义一个具名函数通常可读性更好（正如《编程珠玑》中强调的，代码是写给人看的）。<h3 id=1-6-4-ke-li-hua-currying>1.6.4 柯里化 (Currying)</h3><p>柯里化是将一个多参数函数转换成一系列单参数函数的技术。<pre class=language-python data-lang=python><code class=language-python data-lang=python>def curried_pow(x):
    def h(y):
        return pow(x, y)
    return h

>>> curried_pow(2)(3)
8
</code></pre><p><strong>为什么需要柯里化？</strong> 它允许我们<strong>部分应用 (Partial Application)</strong> 函数。例如，我们可以轻松创建一个 <code>map</code> 函数的变体，专门用于处理特定类型的数据流。这在构建数据处理管道（Pipeline）时非常强大，类似于 UNIX 的 <code>grep | sed | awk</code>。<h3 id=1-6-5-zhuang-shi-qi-decorators-python-de-yu-fa-tang>1.6.5 装饰器 (Decorators) —— Python 的语法糖</h3><p>虽然 SICP 原书没有强调装饰器，但在 Python 中，这是高阶函数的终极应用。它对应于 <strong>装饰器模式 (Decorator Pattern)</strong>。<pre class=language-python data-lang=python><code class=language-python data-lang=python>def trace(fn):
    """一个用于追踪函数调用的高阶函数"""
    def wrapped(x):
        print('-> ', fn, 'called with argument', x)
        return fn(x)
    return wrapped

@trace
def triple(x):
    return 3 * x

>>> triple(12)
->  &LTfunction triple at 0x...> called with argument 12
36
</code></pre><p>这体现了 <strong>AOP (面向切面编程)</strong> 的思想：在不修改原有逻辑（<code>triple</code>）的情况下，横向切入并添加功能（日志记录）。<h2 id=zong-jie-yu-si-kao>总结与思考</h2><ul><li><strong>抽象层级</strong>：从“抽象数字”到“抽象过程”，再到“抽象过程的生成器”，我们的编程能力随着抽象层级的提升而指数级增长。<li><strong>设计哲学</strong>：高阶函数完美体现了“开闭原则” (Open/Closed Principle) —— 对扩展开放（传入新函数），对修改关闭（通用逻辑不用变）。</ul><p>在下一章，我们将探索 <strong>递归 (Recursion)</strong>。如果说高阶函数是横向的组合，那么递归就是纵向的深入，它是分治算法和很多复杂数据结构的基础。</div></div></section>