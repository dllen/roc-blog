<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>07. 可变数据：时间、状态与同一性 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/sicp-with-python/> /sicp-with-python </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-02-07</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">07. 可变数据：时间、状态与同一性</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=di-qi-zhang-ke-bian-shu-ju-shi-jian-zhuang-tai-yu-tong-yi-xing>第七章：可变数据——时间、状态与同一性</h1><blockquote><p>“Change is the only constant in life.”<br> — Heraclitus</blockquote><p>在之前的章节中，我们的函数都是<strong>纯函数</strong>：对于相同的输入，永远返回相同的输出。这种特性被称为<strong>引用透明性 (Referential Transparency)</strong>。<p>但在现实世界中，事物是随<strong>时间</strong>变化的。为了模拟这种变化，我们需要引入<strong>状态 (State)</strong> 和 <strong>可变性 (Mutation)</strong>。<h2 id=2-4-ke-bian-shu-ju-mutable-data>2.4 可变数据 (Mutable Data)</h2><h3 id=2-4-1-dui-xiang-de-yin-yu-the-object-metaphor>2.4.1 对象的隐喻 (The Object Metaphor)</h3><p>对象不仅仅是数据和函数的集合，它还拥有<strong>行为</strong>和<strong>状态</strong>。 让我们看一个经典的例子：银行账户。<pre class=language-python data-lang=python><code class=language-python data-lang=python>def make_withdraw(balance):
    def withdraw(amount):
        nonlocal balance  # 声明 balance 不是局部变量
        if amount > balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw
</code></pre><p>这里发生了一些神奇的事情：<pre class=language-python data-lang=python><code class=language-python data-lang=python>>>> withdraw = make_withdraw(100)
>>> withdraw(25)
75
>>> withdraw(25)
50
</code></pre><p>同一个函数 <code>withdraw</code>，输入相同的参数 <code>25</code>，却返回了不同的结果！ 这是因为 <code>withdraw</code> 函数拥有了<strong>局部状态 (Local State)</strong> —— <code>balance</code>。<h3 id=2-4-2-nonlocal-yu-ju>2.4.2 nonlocal 语句</h3><p>在 Python 中，<code>nonlocal</code> 关键字至关重要。它告诉解释器：“不要在当前帧（Frame）中查找或创建 <code>balance</code>，而去父级帧中查找并修改它。”<p>如果没有 <code>nonlocal</code>，<code>balance = balance - amount</code> 会报错，因为 Python 会认为你在试图修改一个未定义的局部变量。<p><strong>这标志着我们失去了引用透明性。</strong> 我们的替代模型从<strong>代换模型 (Substitution Model)</strong> 变成了更复杂的<strong>环境模型 (Environment Model)</strong>。<h3 id=2-4-3-tong-yi-xing-yu-xiang-deng-xing-identity-vs-equality>2.4.3 同一性与相等性 (Identity vs. Equality)</h3><p>一旦引入了变化，我们就必须区分“同一个东西”和“看起来一样的东西”。<ul><li><strong>相等性 (Equality, <code>==</code>)</strong>：两个对象的内容是否相同？<li><strong>同一性 (Identity, <code>is</code>)</strong>：两个名字是否指向内存中的同一个对象？</ul><pre class=language-python data-lang=python><code class=language-python data-lang=python>>>> list_a = [1, 2, 3]
>>> list_b = [1, 2, 3]

>>> list_a == list_b
True  # 内容一样

>>> list_a is list_b
False # 它们是两个独立的列表

>>> list_c = list_a
>>> list_c is list_a
True  # 它们指向同一个列表
</code></pre><p>如果修改 <code>list_a</code>：<pre class=language-python data-lang=python><code class=language-python data-lang=python>>>> list_a.append(4)
>>> list_b
[1, 2, 3]  # list_b 不受影响
>>> list_c
[1, 2, 3, 4] # list_c 变了！因为它是 list_a 的别名
</code></pre><h3 id=2-4-4-ke-bian-xing-de-dai-jia>2.4.4 可变性的代价</h3><p>引入可变性赋予了我们模拟真实世界的能力（如模拟银行系统、物理引擎），但也带来了巨大的代价：<ol><li><strong>时间维度</strong>：以前我们只需要关心 <code>x</code> 是什么，现在我们需要关心 <code>x</code> <strong>现在</strong>是什么，以及它<strong>之前</strong>是什么。<li><strong>并发问题</strong>：如果两个线程同时修改同一个对象，会发生什么？（这是并发编程中最头疼的问题）。<li><strong>测试困难</strong>：无法再简单地通过输入输出来测试函数，必须先设置好特定的状态。</ol><h2 id=zong-jie-yu-si-kao>总结与思考</h2><ul><li><strong>状态</strong>：让程序有了“记忆”。<li><strong>nonlocal</strong>：打破了函数式编程的洁癖，引入了副作用。<li><strong>同一性</strong>：在可变世界中，知道“你是谁”比“你像谁”更重要。</ul><p>在下一章，我们将正式进入 <strong>2.5 面向对象编程 (Object-Oriented Programming)</strong>。我们将看到 Python 的 <code>class</code> 机制是如何封装这些状态管理逻辑的，以及继承、多态等核心概念。</div></div></section>