<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>10. 递归对象：链表与树的类实现 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/sicp-with-python/> /sicp-with-python </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-02-07</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">10. 递归对象：链表与树的类实现</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=di-shi-zhang-di-gui-dui-xiang-lian-biao-yu-shu-de-lei-shi-xian>第十章：递归对象——链表与树的类实现</h1><blockquote><p>“To understand recursion, you must first understand recursion.”</blockquote><p>在前面的章节中，我们使用函数和元组实现了链表和树。那时候，数据（元组）和行为（处理函数）是分离的。 现在，我们已经掌握了面向对象编程 (OOP)，是时候将这两者结合起来，构建<strong>递归对象 (Recursive Objects)</strong>。<p>当一个对象的属性值是该对象所属类的实例时，我们称其为递归对象。<h2 id=2-9-1-lian-biao-lei-linked-list-class>2.9.1 链表类 (Linked List Class)</h2><p>我们在 2.3 节中用嵌套元组 <code>(1, (2, (3, empty)))</code> 模拟了链表。现在，我们可以定义一个 <code>Link</code> 类来封装这种逻辑。<h3 id=ding-yi-link-lei>定义 <code>Link</code> 类</h3><p>核心思想依然不变：链表由 <strong>first</strong> (第一个元素) 和 <strong>rest</strong> (剩余部分) 组成。<code>rest</code> 必须也是一个 <code>Link</code> 实例，或者是空链表 (<code>Link.empty</code>)。<pre class=language-python data-lang=python><code class=language-python data-lang=python>class Link:
    """A linked list with a first element and the rest."""
    empty = ()

    def __init__(self, first, rest=empty):
        assert rest is Link.empty or isinstance(rest, Link)
        self.first = first
        self.rest = rest

    def __getitem__(self, i):
        if i == 0:
            return self.first
        else:
            return self.rest[i-1]

    def __len__(self):
        return 1 + len(self.rest)

    def __repr__(self):
        if self.rest is Link.empty:
            rest = ''
        else:
            rest = ', ' + repr(self.rest)
        return 'Link({0}{1})'.format(self.first, rest)
</code></pre><p><strong>代码解析：</strong><ol><li><strong>递归定义</strong>：<code>__len__</code> 和 <code>__getitem__</code> 都调用了 <code>self.rest</code> 的对应方法。<li><strong>魔术方法</strong>：实现了 <code>__len__</code> 和 <code>__getitem__</code> 后，<code>Link</code> 对象就可以使用 <code>len()</code> 函数和索引 <code>[]</code> 访问，表现得像 Python 内置序列一样。<li><strong><code>__repr__</code></strong>：提供了友好的字符串表示，方便调试。</ol><pre class=language-python data-lang=python><code class=language-python data-lang=python>s = Link(3, Link(4, Link(5)))
# >>> len(s)
# 3
# >>> s[1]
# 4
# >>> s
# Link(3, Link(4, Link(5)))
</code></pre><h3 id=lian-biao-de-di-gui-cao-zuo>链表的递归操作</h3><p>有了 <code>Link</code> 类，我们可以定义各种高阶函数来处理它。注意，这些操作通常也是递归的。<pre class=language-python data-lang=python><code class=language-python data-lang=python>def extend_link(s, t):
    """连接两个链表 s 和 t"""
    if s is Link.empty:
        return t
    else:
        return Link(s.first, extend_link(s.rest, t))

def map_link(f, s):
    """对链表 s 的每个元素应用函数 f"""
    if s is Link.empty:
        return s
    else:
        return Link(f(s.first), map_link(f, s.rest))

def filter_link(f, s):
    """过滤链表 s，只保留满足 f 的元素"""
    if s is Link.empty:
        return s
    else:
        filtered = filter_link(f, s.rest)
        if f(s.first):
            return Link(s.first, filtered)
        else:
            return filtered
</code></pre><p>这不仅演示了递归处理，也展示了 OOP 如何与函数式编程（Map/Filter）完美融合。<h2 id=2-9-2-shu-lei-tree-class>2.9.2 树类 (Tree Class)</h2><p>同样地，我们在 2.3 节用列表嵌套列表实现了树。现在，我们定义一个 <code>Tree</code> 类。 一棵树包含一个 <strong>label</strong> (根节点值) 和一组 <strong>branches</strong> (分支，每个分支也是一棵 <code>Tree</code>)。<pre class=language-python data-lang=python><code class=language-python data-lang=python>class Tree:
    def __init__(self, label, branches=()):
        self.label = label
        for branch in branches:
            assert isinstance(branch, Tree)
        self.branches = list(branches)

    def __repr__(self):
        if self.branches:
            branch_str = ', ' + repr(self.branches)
        else:
            branch_str = ''
        return 'Tree({0}{1})'.format(self.label, branch_str)

    def is_leaf(self):
        return not self.branches
</code></pre><h3 id=ying-yong-fei-bo-na-qi-shu>应用：斐波那契树</h3><p>我们可以构建一棵树来可视化斐波那契数列的计算过程。这极好地展示了树递归的结构。<pre class=language-python data-lang=python><code class=language-python data-lang=python>def fib_tree(n):
    if n == 0 or n == 1:
        return Tree(n)
    else:
        left = fib_tree(n-2)
        right = fib_tree(n-1)
        fib_n = left.label + right.label
        return Tree(fib_n, [left, right])

# >>> fib_tree(5)
# Tree(5, [Tree(2, [Tree(1, [Tree(0), Tree(1)]), Tree(1)]), Tree(3, [Tree(1), Tree(2, [Tree(1, [Tree(0), Tree(1)]), Tree(1)])])])
</code></pre><h3 id=ji-yi-hua-memoization-yu-xiao-lu>记忆化 (Memoization) 与效率</h3><p>递归对象的一个潜在问题是效率。例如 <code>fib_tree(35)</code> 会生成海量的节点。 通过结合 <strong>Memoization (记忆化)</strong> 技术，我们可以确保相同的子树只被创建一次。<pre class=language-python data-lang=python><code class=language-python data-lang=python>def memo(f):
    cache = {}
    def memoized(n):
        if n not in cache:
            cache[n] = f(n)
        return cache[n]
    return memoized

fib_tree = memo(fib_tree)
big_fib_tree = fib_tree(35)
# 此时，计算瞬间完成，且内存占用极低，因为大量子树被共享引用了。
</code></pre><p>这展示了对象模型的一个重要特性：<strong>对象标识 (Identity)</strong>。虽然逻辑上树很大，但物理上许多分支指向的是同一个内存对象。<h2 id=2-9-3-ji-he-sets-de-shi-xian>2.9.3 集合 (Sets) 的实现</h2><p>最后，我们来看看如何利用递归对象来实现<strong>集合 (Set)</strong>。 集合的特性是：元素不重复、无序。<p>如果我们用 <code>Link</code> 来实现集合（作为无序序列）：<pre class=language-python data-lang=python><code class=language-python data-lang=python>def set_contains(s, v):
    """判断集合 s 是否包含 v"""
    if s is Link.empty:
        return False
    elif s.first == v:
        return True
    else:
        return set_contains(s.rest, v)

def adjoin_set(s, v):
    """向集合 s 添加元素 v"""
    if set_contains(s, v):
        return s
    else:
        return Link(v, s)
</code></pre><p><strong>效率分析</strong>：<ul><li><code>set_contains</code> 需要遍历整个链表，时间复杂度为 $O(n)$。<li><code>adjoin_set</code> 也需要调用 <code>set_contains</code>，所以也是 $O(n)$。<li>两个集合的交集或并集操作，则可能达到 $O(n^2)$。</ul><p>这为我们后续讨论<strong>效率 (Efficiency)</strong> 埋下了伏笔：如果我们使用<strong>排序链表</strong>或<strong>二叉搜索树</strong>来实现集合，能否将复杂度降低到 $O(\log n)$？<h2 id=zong-jie>总结</h2><p>递归对象是数据结构课程的核心。通过 <code>Link</code> 和 <code>Tree</code> 类，我们：<ol><li>将<strong>递归结构</strong>封装在类定义中。<li>利用<strong>特殊方法</strong>让自定义对象融入 Python 生态。<li>结合<strong>记忆化</strong>优化了递归结构的性能。</ol><p>至此，SICP Python 版的第二部分“数据抽象”的主要内容已经完成。我们从简单的数字，到函数，再到序列、树，最后到通用的对象系统。<p>下一章，我们将稍作停顿，专门探讨<strong>效率 (Efficiency)</strong>，用大 O 表示法来量化我们的代码性能。<hr><p><em>参考链接：</em><ul><li><a href=https://www.composingprograms.com/pages/29-recursive-objects.html>Composing Programs 2.9 Recursive Objects</a></ul></div></div></section>