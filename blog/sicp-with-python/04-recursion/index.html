<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>04. 递归与分治：跨越抽象的鸿沟 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/sicp-with-python/> /sicp-with-python </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-02-07</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">04. 递归与分治：跨越抽象的鸿沟</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=di-si-zhang-di-gui-yu-fen-zhi-kua-yue-chou-xiang-de-hong-gou>第四章：递归与分治——跨越抽象的鸿沟</h1><blockquote><p>“To understand recursion, you must first understand recursion.”</blockquote><p>如果说高阶函数是编程的“瑞士军刀”，那么<strong>递归 (Recursion)</strong> 就是“魔法”。在这一章，我们将深入探讨递归的本质，并结合《深入理解计算机系统》(CSAPP) 和《具体数学》中的思想，揭示它背后的原理。<h2 id=1-7-di-gui-han-shu-recursive-functions>1.7 递归函数 (Recursive Functions)</h2><p>递归函数是<strong>直接或间接调用自身</strong>的函数。<h3 id=1-7-1-di-gui-de-san-ge-fa-ze>1.7.1 递归的三个法则</h3><p>编写递归函数时，我们必须遵循三个核心法则，这与<strong>数学归纳法 (Mathematical Induction)</strong> 不谋而合：<ol><li><strong>基准情况 (Base Case)</strong>：有一个最简单的情况，不需要递归就能求解（对应数学归纳法的 $n=1$ 或 $n=0$）。<li><strong>递归步骤 (Recursive Step)</strong>：将问题分解为更小的子问题（对应假设 $n=k$ 成立，推导 $n=k+1$）。<li><strong>收敛性 (Convergence)</strong>：递归调用必须向基准情况靠近。</ol><p><strong>经典案例：阶乘 (Factorial)</strong><p>$$n! = \begin{cases} 1 & \text{if } n=0 \ n \times (n-1)! & \text{if } n>0 \end{cases}$$<pre class=language-python data-lang=python><code class=language-python data-lang=python>def factorial(n):
    if n == 0:          # Base Case
        return 1
    else:               # Recursive Step
        return n * factorial(n - 1)
</code></pre><h3 id=1-7-2-pou-xi-di-gui-csapp-shi-jiao-xia-de-zhan-zheng>1.7.2 剖析递归：CSAPP 视角下的栈帧</h3><p>很多初学者觉得递归“烧脑”，是因为试图在脑子里模拟每一层调用。 <strong>不要这样做！</strong> 相信“递归的信念 (Leap of Faith)”。<p>但在底层（如 CSAPP 第 3 章所述），递归没有任何魔法。它只是利用了<strong>栈 (Stack)</strong> 数据结构。<ul><li>每次函数调用，都会在内存栈上分配一个<strong>栈帧 (Stack Frame)</strong>。<li>栈帧存储了局部变量、参数和返回地址。<li><code>factorial(3)</code> 调用 <code>factorial(2)</code> 时，<code>factorial(3)</code> 的栈帧被挂起，等待 <code>factorial(2)</code> 返回。</ul><p>这就是为什么过深的递归会导致 <code>RecursionError: maximum recursion depth exceeded</code> —— 栈空间耗尽了（Stack Overflow）。<h3 id=1-7-3-hu-di-gui-mutual-recursion>1.7.3 互递归 (Mutual Recursion)</h3><p>函数 A 调用函数 B，函数 B 又调用函数 A。这种模式在处理复杂语法（如编译器设计中的递归下降解析）时非常有用。<p><strong>案例：判断奇偶性</strong><pre class=language-python data-lang=python><code class=language-python data-lang=python>def is_even(n):
    if n == 0:
        return True
    return is_odd(n - 1)

def is_odd(n):
    if n == 0:
        return False
    return is_even(n - 1)

>>> is_even(4)
True
</code></pre><p>虽然这个例子效率不高，但它展示了状态在函数间流转的机制。<h3 id=1-7-4-shu-xing-di-gui-tree-recursion>1.7.4 树形递归 (Tree Recursion)</h3><p>当一个递归函数在一次调用中多次调用自己时，就形成了树形递归。这是<strong>分治算法 (Divide and Conquer)</strong> 的原型。<p><strong>经典案例：斐波那契数列（递归版）</strong><pre class=language-python data-lang=python><code class=language-python data-lang=python>def fib(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 2) + fib(n - 1)
</code></pre><p><strong>性能分析</strong>： 这个算法极其低效。计算 <code>fib(5)</code> 需要计算 <code>fib(3)</code> 和 <code>fib(4)</code>，而 <code>fib(4)</code> 又要计算 <code>fib(3)</code>… 时间复杂度是 $O(\phi^n)$（指数级爆炸）。在后续章节（动态规划/Memoization）中我们将优化它。<h3 id=1-7-5-he-xin-an-li-zheng-shu-chai-fen-partitions>1.7.5 核心案例：整数拆分 (Partitions)</h3><p>这是 SICP 中最精彩的递归案例之一。 <strong>问题</strong>：将正整数 $n$ 拆分为最大不超过 $m$ 的正整数之和，有多少种拆法？ 例如：$n=6, m=4$ <code>6 = 4 + 2</code> <code>6 = 3 + 3</code> <code>6 = 3 + 2 + 1</code> <code>6 = 3 + 1 + 1 + 1</code> … 等等<p><strong>递归思考</strong>： 将问题 <code>count_partitions(n, m)</code> 分解为两种情况：<ol><li><strong>至少包含一个 m</strong>：那么剩下的数就是 $n-m$，我们要继续对它进行拆分（最大仍为 $m$）。即 <code>count_partitions(n-m, m)</code>。<li><strong>完全不包含 m</strong>：那么所有拆分出的数都必须小于 $m$（即最大为 $m-1$）。即 <code>count_partitions(n, m-1)</code>。</ol><p>总数 = 情况1 + 情况2。<pre class=language-python data-lang=python><code class=language-python data-lang=python>def count_partitions(n, m):
    if n == 0:
        return 1  # 拆分成功（刚好减完）
    if n < 0:
        return 0  # 拆分失败（减多了）
    if m == 0:
        return 0  # 没得拆了
    return count_partitions(n-m, m) + count_partitions(n, m-1)
</code></pre><p>这段代码虽短，却蕴含了强大的<strong>分类讨论</strong>思想。这正是算法设计的精髓。<h2 id=zong-jie-yu-si-kao>总结与思考</h2><ul><li><strong>递归与迭代</strong>：理论上它们是等价的（图灵完备）。迭代更省内存，递归更符合人类思维（尤其是处理树形结构时）。<li><strong>分治思想</strong>：将大问题拆解为小问题，是解决复杂系统问题的唯一途径（无论是软件架构还是算法设计）。</ul><p>在下一章，我们将离开纯粹的函数世界，开始探索<strong>数据抽象 (Data Abstraction)</strong> —— 如何构造属于我们自己的数据类型。</div></div></section>