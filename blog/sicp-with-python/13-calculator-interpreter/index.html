<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>13. 构建计算器解释器：从语法分析到求值 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/sicp-with-python/> /sicp-with-python </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-02-07</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">13. 构建计算器解释器：从语法分析到求值</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=di-shi-san-zhang-gou-jian-ji-suan-qi-jie-shi-qi-yuan-yu-yan-chou-xiang-de-qi-dian>第十三章：构建计算器解释器——元语言抽象的起点</h1><blockquote><p>“The evaluator, which determines the meaning of expressions in a programming language, is just another program.” — SICP</blockquote><p>在上一章中，我们体验了 Scheme 的简洁语法。今天，我们将跨越使用语言和设计语言的界限，利用<strong>元语言抽象 (Metalinguistic Abstraction)</strong> 的思想，用 Python 实现一个简单的 Scheme 语法计算器 (Calculator)。<p>虽然它只能做加减乘除，但它包含了所有解释器的核心组件：<strong>解析 (Parsing)</strong> 和 <strong>求值 (Evaluation)</strong>。<h2 id=3-4-1-he-xin-zu-jian-gai-lan>3.4.1 核心组件概览</h2><p>一个解释器通常由四个主要部分组成，构成经典的 <strong>REPL</strong> 循环：<ol><li><strong>Read (读取)</strong>: 将用户输入的字符串转换为计算机可处理的数据结构（表达式树）。<li><strong>Eval (求值)</strong>: 确定表达式树的意义（计算结果）。<li><strong>Print (打印)</strong>: 将结果转换回人类可读的字符串。<li><strong>Loop (循环)</strong>: 不断重复上述过程，并处理可能出现的<strong>异常 (Exceptions)</strong>。</ol><h2 id=3-4-2-biao-da-shi-shu-expression-trees>3.4.2 表达式树 (Expression Trees)</h2><p>在解释器内部，代码不是字符串，而是数据结构。我们使用嵌套的 <code>Pair</code> 对象（我们在第十章定义的链表）来表示 Scheme 表达式。<p>例如，Scheme 表达式 <code>(+ 1 (* 2 3))</code> 在 Python 中被表示为：<pre class=language-python data-lang=python><code class=language-python data-lang=python>Pair('+', Pair(1, Pair(Pair('*', Pair(2, Pair(3, nil))), nil)))
</code></pre><p>这不仅是数据，更是<strong>抽象语法树 (AST)</strong>。<h2 id=3-4-3-jie-xi-parsing>3.4.3 解析 (Parsing)</h2><p>解析过程分为两步：<ol><li><p><strong>词法分析 (Lexical Analysis)</strong>: 将字符流拆分为 Token 序列。</p> <ul><li>输入: <code>'(+ 1 2)'</code><li>输出: <code>['(', '+', 1, 2, ')']</code></ul><li><p><strong>语法分析 (Syntactic Analysis)</strong>: 将 Token 序列组装成表达式树。</p> <ul><li>这是一个递归过程：遇到 <code>(</code> 开始读取一个列表，遇到 <code>)</code> 结束。</ul></ol><pre class=language-python data-lang=python><code class=language-python data-lang=python>def scheme_read(src):
    """读取下一个完整的表达式。"""
    if src.current() is None:
        raise EOFError
    val = src.pop()
    if val == '(':
        return read_tail(src) # 读取列表内容
    else:
        return val # 数字或符号

def read_tail(src):
    """读取列表的剩余部分。"""
    if src.current() == ')':
        src.pop()
        return nil
    first = scheme_read(src)
    rest = read_tail(src)
    return Pair(first, rest)
</code></pre><h2 id=3-4-4-qiu-zhi-evaluation>3.4.4 求值 (Evaluation)</h2><p>这是解释器的心脏。对于我们的计算器，求值规则非常简单：<ol><li><strong>自求值表达式 (Self-Evaluating)</strong>: 数字的值就是它本身。<li><strong>调用表达式 (Call Expressions)</strong>: <ul><li>递归求值所有操作数 (Operands)。<li>将操作符 (Operator) 应用于求值后的参数 (Arguments)。</ul></ol><pre class=language-python data-lang=python><code class=language-python data-lang=python>def calc_eval(exp):
    """求值表达式。"""
    if type(exp) in (int, float):
        return exp
    elif isinstance(exp, Pair):
        # 1. 递归求值操作数
        arguments = exp.rest.map(calc_eval)
        # 2. 应用操作符
        return calc_apply(exp.first, arguments)
    else:
        raise TypeError(f"{exp} is not a number or call expression")
</code></pre><p><code>calc_apply</code> 函数负责根据操作符（<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>）执行实际的 Python 运算。<pre class=language-python data-lang=python><code class=language-python data-lang=python>def calc_apply(operator, args):
    """将操作符应用于参数。"""
    if operator == '+':
        return sum(args)
    elif operator == '*':
        return reduce(mul, args, 1)
    # ... 处理 - 和 /
</code></pre><h2 id=3-3-yi-chang-chu-li-exceptions>3.3 异常处理 (Exceptions)</h2><p>一个健壮的解释器必须能优雅地处理错误，而不是直接崩溃。Python 的 <code>try...except</code> 机制在这里发挥了关键作用。<p>在 REPL 循环中，我们捕获所有预期的错误（如语法错误、除零错误），打印错误信息，然后开始下一次循环。<pre class=language-python data-lang=python><code class=language-python data-lang=python>def read_eval_print_loop():
    while True:
        try:
            src = buffer_input() # 获取用户输入
            while src.more_on_line:
                expression = scheme_read(src) # Read
                result = calc_eval(expression) # Eval
                print(result)                  # Print
        except (SyntaxError, TypeError, ZeroDivisionError) as err:
            print(type(err).__name__ + ':', err) # Handle Error
        except (KeyboardInterrupt, EOFError):
            break # Exit
</code></pre><h2 id=zong-jie>总结</h2><p>通过构建这个简单的计算器，我们揭示了编程语言的魔法：<strong>语言只是另一种程序</strong>。<ul><li><strong>Read</strong> 将文本转化为树。<li><strong>Eval</strong> 遍历树并计算结果。<li><strong>REPL</strong> 让这一切动起来。</ul><p>下一章，我们将面对真正的挑战：让我们的解释器支持变量定义、环境模型和用户自定义函数，从而构建一个完整的 Scheme 解释器。<hr><p><em>参考链接：</em><ul><li><a href=https://www.composingprograms.com/pages/33-exceptions.html>Composing Programs 3.3 Exceptions</a><li><a href=https://www.composingprograms.com/pages/34-interpreters-for-languages-with-combination.html>Composing Programs 3.4 Interpreters for Languages with Combination</a></ul></div></div></section>