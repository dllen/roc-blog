<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>17. 逻辑编程：通过事实与规则进行推理 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/sicp-with-python/> /sicp-with-python </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-02-07</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">17. 逻辑编程：通过事实与规则进行推理</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=di-shi-qi-zhang-luo-ji-bian-cheng-tong-guo-shi-shi-yu-gui-ze-jin-xing-tui-li>第十七章：逻辑编程——通过事实与规则进行推理</h1><blockquote><p>“In logic programming, we specify ‘what is true’, and the computer figures out ‘how to prove it’.”</blockquote><p>在上一章的 SQL 中，我们通过声明“要什么数据”来进行查询。今天，我们将这种<strong>声明式</strong>思想推向极致：<strong>逻辑编程 (Logic Programming)</strong>。<p>我们将不再编写函数来计算结果，而是定义<strong>事实 (Facts)</strong> 和 <strong>规则 (Rules)</strong>，然后向计算机提问。计算机通过<strong>推理 (Inference)</strong> 来寻找答案。这种范式的代表语言是 <strong>Prolog</strong>。<h2 id=4-4-1-shi-shi-yu-cha-xun-facts-and-queries>4.4.1 事实与查询 (Facts and Queries)</h2><p>在逻辑编程中，程序就是一系列事实的数据库。我们使用一种类似 Scheme 的语法来描述关系。<h3 id=ding-yi-shi-shi>定义事实</h3><p>假设我们要记录狗的族谱：<pre class=language-scheme data-lang=scheme><code class=language-scheme data-lang=scheme>(fact (parent abraham barack))
(fact (parent abraham clinton))
(fact (parent delano herbert))
(fact (parent fillmore abraham))
(fact (parent fillmore delano))
(fact (parent fillmore grover))
(fact (parent eisenhower fillmore))
</code></pre><p>这里 <code>(parent abraham barack)</code> 并不表示函数调用，而是声明一个关系：Abraham 是 Barack 的父亲。<h3 id=jin-xing-cha-xun>进行查询</h3><p>一旦有了事实，我们就可以提问。我们用 <code>?variable</code> 来表示未知量。<pre class=language-scheme data-lang=scheme><code class=language-scheme data-lang=scheme>(query (parent abraham ?child))
</code></pre><p>解释器会查找所有匹配的事实，并告诉我们 <code>?child</code> 可以是谁：<ul><li>Success! <code>?child</code> = <code>barack</code><li>Success! <code>?child</code> = <code>clinton</code></ul><h2 id=4-4-2-fu-za-luo-ji-yu-gui-ze>4.4.2 复杂逻辑与规则</h2><p>逻辑编程的强大之处在于定义<strong>规则</strong>。规则是基于其他事实的推论。<p>语法：<code>(fact <结论> <假设1> <假设2> ...)</code> 读作：“如果假设1、假设2…都成立，那么结论成立。”<h3 id=shi-li-1-zu-xian-guan-xi-ancestor>示例 1：祖先关系 (Ancestor)</h3><p>如果 A 是 Y 的父母，或者 A 是 Y 的父母的祖先，那么 A 就是 Y 的祖先。这是一个递归定义。<pre class=language-scheme data-lang=scheme><code class=language-scheme data-lang=scheme>; 基础情况：直接父母是祖先
(fact (ancestor ?a ?y) (parent ?a ?y))

; 递归情况：父母的祖先也是祖先
(fact (ancestor ?a ?y) (parent ?a ?z) (ancestor ?z ?y))
</code></pre><p>现在我们可以查询 Herbert 的所有祖先：<pre class=language-scheme data-lang=scheme><code class=language-scheme data-lang=scheme>(query (ancestor ?a herbert))
</code></pre><p>解释器会自动进行多步推理，找到 Delano, Fillmore, Eisenhower 等所有祖先。<h3 id=shi-li-2-lie-biao-pin-jie-append>示例 2：列表拼接 (Append)</h3><p>在 Python 中，我们需要写代码来拼接列表。在逻辑编程中，我们定义“拼接关系”。<ol><li><strong>基础情况</strong>：空列表拼上任何列表 <code>?x</code>，结果都是 <code>?x</code>。<li><strong>递归情况</strong>：如果 <code>?r</code> 和 <code>?y</code> 拼成 <code>?z</code>，那么 <code>(?a . ?r)</code> 和 <code>?y</code> 就能拼成 <code>(?a . ?z)</code>。</ol><pre class=language-scheme data-lang=scheme><code class=language-scheme data-lang=scheme>(fact (append () ?x ?x))
(fact (append (?a . ?r) ?y (?a . ?z))
      (append ?r ?y ?z))
</code></pre><p>神奇的事情发生了：这个定义不仅能用来<strong>计算</strong>拼接结果，还能用来<strong>反向求解</strong>！<p><strong>正向计算</strong>：<pre class=language-scheme data-lang=scheme><code class=language-scheme data-lang=scheme>(query (append (a b) (c d) ?result))
; Success! ?result = (a b c d)
</code></pre><p><strong>反向求解</strong>：问“什么两个列表拼起来是 (a b c d e)？”<pre class=language-scheme data-lang=scheme><code class=language-scheme data-lang=scheme>(query (append ?left ?right (a b c d e)))
</code></pre><p>解释器会列出所有可能的组合：<ul><li><code>?left</code>=(), <code>?right</code>=(a b c d e)<li><code>?left</code>=(a), <code>?right</code>=(b c d e)<li>…<li><code>?left</code>=(a b c d e), <code>?right</code>=()</ul><h2 id=zong-jie>总结</h2><p>逻辑编程展示了一种完全不同的编程思维：<ol><li><strong>程序即逻辑</strong>：你不需要思考控制流（循环、递归调用栈），只需要定义逻辑关系。<li><strong>多向计算</strong>：定义好的关系通常可以从任意方向使用（已知输入求输出，或已知输出求输入）。<li><strong>模式匹配</strong>：核心机制是<strong>统一化 (Unification)</strong>，即寻找变量的赋值使得两个表达式相等。</ol><p>下一章，我们将深入逻辑解释器的内部，探索 <strong>Unification 算法</strong> —— 驱动这一切魔法的引擎。<hr><p><em>参考链接：</em><ul><li><a href=https://www.composingprograms.com/pages/44-logic-programming.html>Composing Programs 4.4 Logic Programming</a></ul></div></div></section>