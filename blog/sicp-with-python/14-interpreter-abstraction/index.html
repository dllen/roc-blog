<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>14. 环境模型与解释器：构建完整的编程语言 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/sicp-with-python/> /sicp-with-python </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-02-07</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">14. 环境模型与解释器：构建完整的编程语言</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=di-shi-si-zhang-huan-jing-mo-xing-yu-jie-shi-qi-cong-ji-suan-qi-dao-bian-cheng-yu-yan>第十四章：环境模型与解释器——从计算器到编程语言</h1><blockquote><p>“The interpreter is a universal machine.” — SICP</blockquote><p>在上一章，我们构建了一个简单的计算器，它能做加减乘除，但没有记忆能力——不能定义变量，也不能定义函数。今天，我们将引入<strong>环境模型 (Environment Model)</strong>，赋予解释器“记忆”和“抽象”的能力，将其升级为一个真正的 Scheme 编程语言解释器。<p>这是《SICP》中最激动人心的时刻之一：我们不再只是使用语言，而是在创造语言。<h2 id=3-5-1-jie-shi-qi-de-he-xin-jie-gou>3.5.1 解释器的核心结构</h2><p>一个完整的 Scheme 解释器在结构上与计算器类似，但在<strong>求值 (Evaluation)</strong> 阶段引入了两个关键的新概念：<strong>环境 (Environment)</strong> 和 <strong>特有形式 (Special Forms)</strong>。<h3 id=he-xin-xun-huan-eval-apply-hu-di-gui>核心循环：Eval/Apply 互递归</h3><p>解释器的执行过程本质上是 <code>scheme_eval</code> 和 <code>scheme_apply</code> 两个函数的<strong>互递归 (Mutual Recursion)</strong>：<ol><li><p><strong>Eval (求值)</strong>: 在特定<strong>环境</strong>中计算表达式的值。</p> <ul><li>如果是<strong>基本值</strong>（数字、字符串），直接返回。<li>如果是<strong>符号</strong>（变量名），在环境中查找其值。<li>如果是<strong>特有形式</strong>（<code>define</code>, <code>if</code>, <code>lambda</code>），按特殊规则处理。<li>如果是<strong>调用表达式</strong>，先求值操作符和操作数，然后调用 <strong>Apply</strong>。</ul><li><p><strong>Apply (应用)</strong>: 将过程（函数）应用于参数。</p> <ul><li>如果是<strong>基本过程</strong>（内置函数），直接运行对应的 Python 代码。<li>如果是<strong>用户定义过程</strong>（Lambda），创建一个<strong>新环境</strong>（新栈帧），绑定参数，然后在这个新环境中 <strong>Eval</strong> 函数体。</ul></ol><p>这种“求值调用应用，应用调用求值”的循环，构成了程序的动态执行流。<pre class=language-python data-lang=python><code class=language-python data-lang=python>def scheme_eval(expr, env):
    """在环境 env 中求值表达式 expr"""
    if scheme_symbolp(expr):
        return env.lookup(expr) # 查找变量
    elif scheme_atomp(expr):
        return expr
    
    first, rest = expr.first, expr.rest
    
    if first == 'define':       # 特有形式：定义
        return do_define_form(rest, env)
    elif first == 'lambda':     # 特有形式：函数
        return do_lambda_form(rest, env)
    else:                       # 调用表达式
        procedure = scheme_eval(first, env)
        args = rest.map(lambda operand: scheme_eval(operand, env))
        return scheme_apply(procedure, args, env)
</code></pre><h2 id=3-5-2-huan-jing-mo-xing-environments>3.5.2 环境模型 (Environments)</h2><p>环境赋予了程序“状态”。在实现上，我们使用 <code>Frame</code> 类来表示环境中的一个<strong>帧 (Frame)</strong>。<h3 id=frame-lei-she-ji>Frame 类设计</h3><p>每个 <code>Frame</code> 包含：<ol><li><strong>Bindings</strong>: 一个字典，存储变量名到值的映射。<li><strong>Parent</strong>: 指向父帧的引用（全局帧的父帧为 <code>None</code>）。</ol><pre class=language-python data-lang=python><code class=language-python data-lang=python>class Frame:
    def __init__(self, parent):
        self.bindings = {}
        self.parent = parent

    def define(self, symbol, value):
        """在当前帧定义变量"""
        self.bindings[symbol] = value

    def lookup(self, symbol):
        """查找变量值：当前帧 -> 父帧 -> ... -> 报错"""
        if symbol in self.bindings:
            return self.bindings[symbol]
        elif self.parent is not None:
            return self.parent.lookup(symbol)
        else:
            raise SchemeError(f"unknown identifier: {symbol}")
</code></pre><h3 id=yong-hu-ding-yi-guo-cheng-user-defined-procedures>用户定义过程 (User-Defined Procedures)</h3><p>当我们定义一个函数时（使用 <code>lambda</code>），解释器会创建一个 <code>LambdaProcedure</code> 对象。这个对象不仅保存了代码（函数体），还保存了<strong>定义该函数时的环境</strong>。这正是<strong>闭包 (Closure)</strong> 的实现原理！<pre class=language-python data-lang=python><code class=language-python data-lang=python>class LambdaProcedure:
    def __init__(self, formals, body, env):
        self.formals = formals  # 参数列表
        self.body = body        # 函数体
        self.env = env          # 定义时的环境（闭包）

    def __str__(self):
        return f"(lambda {self.formals} {self.body})"
</code></pre><h2 id=3-5-3-yun-xing-shi-li-jie-cheng>3.5.3 运行示例：阶乘</h2><p>让我们看看当解释器执行 <code>(factorial 5)</code> 时发生了什么：<pre class=language-scheme data-lang=scheme><code class=language-scheme data-lang=scheme>(define (factorial n)
  (if (= n 0) 1 (* n (factorial (- n 1)))))

(factorial 5)
</code></pre><ol><li><strong>定义阶段</strong>: <code>do_define_form</code> 创建一个 <code>LambdaProcedure</code>，将其绑定到全局帧 (Global Frame) 的符号 <code>factorial</code> 上。<li><strong>调用阶段</strong>: <ul><li><code>scheme_eval</code> 遇到 <code>(factorial 5)</code>。<li>求值 <code>factorial</code> -> 得到 <code>LambdaProcedure</code>。<li>求值 <code>5</code> -> 得到 <code>5</code>。<li>调用 <code>scheme_apply</code>。</ul><li><strong>应用阶段</strong>: <ul><li><code>scheme_apply</code> 创建一个新的 <code>Frame</code>（E1），其父帧是 <code>factorial</code> 的定义环境（Global）。<li>在 E1 中绑定 <code>n = 5</code>。<li>在 E1 中 <code>scheme_eval</code> 函数体。</ul><li><strong>递归</strong>: 函数体执行中再次调用 <code>factorial</code>，重复上述过程，创建 E2, E3… 直到基准情况 <code>n=0</code>。</ol><p>这与我们在第四章（递归）和第十章（环境图）中学到的理论完全一致，只不过这次是用代码实现了它。<h2 id=3-5-4-shu-ju-ji-cheng-xu-data-as-programs>3.5.4 数据即程序 (Data as Programs)</h2><p>Scheme 的一个深刻特性是<strong>同像性 (Homoiconicity)</strong>：代码和数据使用相同的结构（列表）。<ul><li><code>(define x 10)</code> 既是一个列表数据，也是一段代码。<li>解释器就是一个将“数据”视为“程序”并运行它的机器。</ul><p>这种特性使得 Scheme 非常适合编写处理程序的程序（如解释器、编译器、宏系统）。<h2 id=zong-jie>总结</h2><p>至此，我们已经理解了一个图灵完备语言的核心骨架：<ul><li><strong>Eval/Apply 循环</strong> 驱动计算。<li><strong>Frame 链</strong> 实现作用域和闭包。<li><strong>LambdaProcedure</strong> 封装逻辑与环境。</ul><p>有了这个解释器，我们不仅能计算数学题，还能实现对象系统、逻辑编程，甚至在 Scheme 解释器上再运行一个 Scheme 解释器（元循环求值器）！<hr><p><em>参考链接：</em><ul><li><a href=https://www.composingprograms.com/pages/35-interpreters-for-languages-with-abstraction.html>Composing Programs 3.5 Interpreters for Languages with Abstraction</a><li><a href=https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1>SICP 4.1 The Metacircular Evaluator</a></ul></div></div></section>