<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>21. 并行计算：驾驭多线程的野兽 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/sicp-with-python/> /sicp-with-python </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-02-08</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">21. 并行计算：驾驭多线程的野兽</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=di-er-shi-yi-zhang-bing-xing-ji-suan-jia-yu-duo-xian-cheng-de-ye-shou>第二十一章：并行计算——驾驭多线程的野兽</h1><blockquote><p>“The speed of individual processor cores has increased much more slowly… Instead, CPU manufacturers began to place multiple cores in a single processor.”</blockquote><p>随着摩尔定律的放缓，单核 CPU 的性能提升遭遇瓶颈。为了追求更快的速度，硬件厂商转向了多核架构。这意味着，作为程序员，我们必须学会<strong>并行计算 (Parallel Computing)</strong>，让程序同时做多件事。<h2 id=4-8-1-bing-xing-vs-bing-fa-parallelism-vs-concurrency>4.8.1 并行 vs 并发 (Parallelism vs Concurrency)</h2><ul><li><strong>并发 (Concurrency)</strong>: 指系统<strong>管理</strong>多个任务的能力。即使在单核 CPU 上，操作系统通过快速切换上下文 (Context Switching)，让我们感觉多个程序在同时运行。<li><strong>并行 (Parallelism)</strong>: 指系统<strong>同时执行</strong>多个任务的能力。这通常需要多核 CPU 或多台机器。</ul><h3 id=python-zhong-de-bing-xing>Python 中的并行</h3><p>Python 提供了两种主要的并行方式：<ol><li><p><strong>Threading (多线程)</strong>:</p> <ul><li>所有线程运行在同一个进程中，共享内存。<li><strong>GIL (Global Interpreter Lock)</strong>: CPython 解释器的全局锁限制了同一时刻只能有一个线程执行 Python 字节码。因此，Python 多线程适合 <strong>I/O 密集型</strong>任务（如爬虫、文件读写），但不适合 CPU 密集型任务。</ul> <pre class=language-python data-lang=python><code class=language-python data-lang=python>import threading

def hello():
    print('Hello from', threading.current_thread().name)

t = threading.Thread(target=hello)
t.start()
t.join()
</code></pre><li><p><strong>Multiprocessing (多进程)</strong>:</p> <ul><li>启动多个独立的解释器进程。<li>每个进程有独立的内存空间，避开了 GIL 的限制。<li>适合 <strong>CPU 密集型</strong>任务（如科学计算、图像处理）。</ul></ol><h2 id=4-8-2-gong-xiang-zhuang-tai-de-wei-ji-jing-tai-tiao-jian-race-conditions>4.8.2 共享状态的危机：竞态条件 (Race Conditions)</h2><p>并行编程最大的挑战在于<strong>共享可变状态 (Shared Mutable State)</strong>。当多个线程同时修改同一个变量时，结果可能不可预测。<h3 id=shi-li-bu-an-quan-de-ji-shu-qi>示例：不安全的计数器</h3><pre class=language-python data-lang=python><code class=language-python data-lang=python>import threading

counter = [0]

def increment():
    current = counter[0]
    # 线程可能在这里被切换！
    counter[0] = current + 1

threads = [threading.Thread(target=increment) for _ in range(100)]
for t in threads: t.start()
for t in threads: t.join()
</code></pre><p>如果两个线程同时读取了 <code>current=0</code>，然后都写入 <code>1</code>，那么计数器只增加了 1，而不是 2。这就是<strong>竞态条件</strong>。<h2 id=4-8-3-tong-bu-ji-zhi-synchronization>4.8.3 同步机制 (Synchronization)</h2><p>为了解决竞态条件，我们需要保护共享资源，确保同一时刻只有一个线程能访问它。<h3 id=1-suo-locks>1. 锁 (Locks)</h3><p>锁是最基本的同步原语。<ul><li><code>acquire()</code>: 获取锁。如果锁已被占用，则等待。<li><code>release()</code>: 释放锁。</ul><pre class=language-python data-lang=python><code class=language-python data-lang=python>lock = threading.Lock()

def safe_increment():
    with lock:  # 自动 acquire 和 release
        current = counter[0]
        counter[0] = current + 1
</code></pre><h3 id=2-dui-lie-queues>2. 队列 (Queues)</h3><p><code>queue.Queue</code> 是线程安全的队列，非常适合<strong>生产者-消费者</strong>模型。它内部实现了锁，程序员无需手动管理。<pre class=language-python data-lang=python><code class=language-python data-lang=python>from queue import Queue
q = Queue()

# 生产者
q.put(item)

# 消费者
item = q.get()
# 处理 item...
q.task_done()
</code></pre><h3 id=3-ping-zhang-barriers>3. 屏障 (Barriers)</h3><p><code>threading.Barrier(n)</code> 允许 n 个线程相互等待，直到所有线程都到达屏障点，然后再同时继续执行。<h2 id=4-8-4-si-suo-deadlocks>4.8.4 死锁 (Deadlocks)</h2><p>同步带来了新的问题：<strong>死锁</strong>。 如果线程 A 持有锁 1 等待锁 2，而线程 B 持有锁 2 等待锁 1，两者就会永远僵持下去。<p><strong>避免死锁的策略</strong>：<ul><li>按固定顺序获取锁。<li>使用超时机制。<li>尽量减少锁的使用，优先使用消息传递 (Message Passing) 或无锁数据结构。</ul><h2 id=zong-jie-cong-han-shu-shi-dao-fen-bu-shi>总结：从函数式到分布式</h2><p>至此，我们完成了 SICP (Composing Programs) 的所有核心章节。回顾我们的旅程：<ol><li><strong>函数抽象</strong>: 构建复杂系统的基石。<li><strong>数据抽象</strong>: 隔离实现细节与使用接口。<li><strong>解释器构造</strong>: 理解编程语言的执行模型。<li><strong>分布式与并行</strong>: 跨越单机的界限，连接世界。</ol><p>计算机科学的本质，就是<strong>管理复杂性</strong>。无论是通过函数封装逻辑，还是通过锁同步线程，我们都在试图在一个混乱的世界中建立秩序。<p>希望这系列博客能成为你编程之路上的坚实阶梯。<hr><p><em>参考链接：</em><ul><li><a href=https://www.composingprograms.com/pages/48-parallel-computing.html>Composing Programs 4.8 Parallel Computing</a></ul></div></div></section>