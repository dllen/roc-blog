<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>1brc CalculateAverage_thomaswue 代码解读 | Roc's Blog</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2025-09-01</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">1brc CalculateAverage_thomaswue 代码解读</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>这是一个高性能的Java程序，用于解决“1 Billion Row Challenge“（十亿行挑战）问题。该程序专门用于快速处理大量温度测量数据。详细解读：<h2 id=cheng-xu-zheng-ti-jia-gou>程序整体架构</h2><h3 id=1-duo-jin-cheng-she-ji>1. 多进程设计</h3><pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span style=color:#f92672>private static</span><span> void spawnWorker() throws </span><span style=color:#66d9ef;font-style:italic>IOException </span><span>{
</span><span>    </span><span style=color:#75715e>// 启动工作子进程，主进程负责启动和收集结果
</span><span>    </span><span style=color:#75715e>// 子进程负责实际的数据处理工作
</span><span>}
</span></code></pre><ul><li>使用子进程处理数据，主进程快速返回结果<li>避免内存映射清理延迟问题</ul><h3 id=2-bing-xing-chu-li-ce-lue>2. 并行处理策略</h3><pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span style=color:#66d9ef;font-style:italic>int</span><span> numberOfWorkers </span><span style=color:#f92672>= </span><span style=color:#66d9ef;font-style:italic>Runtime</span><span>.getRuntime().availableProcessors();
</span><span style=color:#75715e>// 每个CPU核心创建一个工作线程
</span></code></pre><h2 id=he-xin-you-hua-ji-shu>核心优化技术</h2><h3 id=1-nei-cun-ying-she-unsafecao-zuo>1. 内存映射 + Unsafe操作</h3><pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span style=color:#f92672>final </span><span style=color:#66d9ef;font-style:italic>long</span><span> fileStart </span><span style=color:#f92672>=</span><span> fileChannel.map(</span><span style=color:#66d9ef;font-style:italic>FileChannel</span><span>.</span><span style=color:#66d9ef;font-style:italic>MapMode</span><span>.</span><span style=color:#ae81ff>READ_ONLY</span><span>, </span><span style=color:#ae81ff>0</span><span>, fileSize, 
</span><span>    </span><span style=color:#66d9ef;font-style:italic>java</span><span>.</span><span style=color:#66d9ef;font-style:italic>lang</span><span>.</span><span style=color:#66d9ef;font-style:italic>foreign</span><span>.</span><span style=color:#66d9ef;font-style:italic>Arena</span><span>.global()).address();
</span></code></pre><ul><li>直接内存映射文件，避免传统IO开销<li>使用<code>sun.misc.Unsafe</code>进行底层内存操作</ul><h3 id=2-fen-duan-bing-xing-chu-li>2. 分段并行处理</h3><pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span style=color:#f92672>private static final </span><span style=color:#66d9ef;font-style:italic>int </span><span style=color:#ae81ff>SEGMENT_SIZE </span><span style=color:#f92672>= </span><span style=color:#ae81ff>1 </span><span style=color:#f92672><< </span><span style=color:#ae81ff>21</span><span>; </span><span style=color:#75715e>// 2MB段
</span></code></pre><ul><li>将文件分成2MB的段<li>使用工作窃取模式而非简单的平均分配</ul><h3 id=3-san-lu-bing-xing-sao-miao>3. 三路并行扫描</h3><pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span style=color:#66d9ef;font-style:italic>long</span><span> dist </span><span style=color:#f92672>= </span><span>(segmentEnd </span><span style=color:#f92672>-</span><span> segmentStart) </span><span style=color:#f92672>/ </span><span style=color:#ae81ff>3</span><span>;
</span><span style=color:#66d9ef;font-style:italic>Scanner</span><span> scanner1 </span><span style=color:#f92672>= new </span><span style=color:#66d9ef;font-style:italic>Scanner</span><span>(segmentStart, midPoint1);
</span><span style=color:#66d9ef;font-style:italic>Scanner</span><span> scanner2 </span><span style=color:#f92672>= new </span><span style=color:#66d9ef;font-style:italic>Scanner</span><span>(midPoint1 </span><span style=color:#f92672>+ </span><span style=color:#ae81ff>1</span><span>, midPoint2);
</span><span style=color:#66d9ef;font-style:italic>Scanner</span><span> scanner3 </span><span style=color:#f92672>= new </span><span style=color:#66d9ef;font-style:italic>Scanner</span><span>(midPoint2 </span><span style=color:#f92672>+ </span><span style=color:#ae81ff>1</span><span>, segmentEnd);
</span></code></pre><ul><li>每个段内部再分成3部分，同时处理<li>提高单线程内的并行度</ul><h3 id=4-wu-fen-zhi-shu-zi-jie-xi>4. 无分支数字解析</h3><pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span style=color:#f92672>private static </span><span style=color:#66d9ef;font-style:italic>long </span><span>convertIntoNumber(</span><span style=color:#66d9ef;font-style:italic>int</span><span> decimalSepPos, </span><span style=color:#66d9ef;font-style:italic>long</span><span> numberWord) {
</span><span>    </span><span style=color:#75715e>// Quan Anh Mai的无分支数字解析算法
</span><span>    </span><span style=color:#75715e>// 避免条件分支导致的CPU流水线停顿
</span><span>}
</span></code></pre><h3 id=5-wei-cao-zuo-you-hua-de-fen-ge-fu-cha-zhao>5. 位操作优化的分隔符查找</h3><pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span style=color:#f92672>private static </span><span style=color:#66d9ef;font-style:italic>long </span><span>findDelimiter(</span><span style=color:#66d9ef;font-style:italic>long</span><span> word) {
</span><span>    </span><span style=color:#66d9ef;font-style:italic>long</span><span> input </span><span style=color:#f92672>=</span><span> word </span><span style=color:#f92672>^ </span><span style=color:#ae81ff>0x3B3B3B3B3B3B3B3B</span><span style=color:#66d9ef;font-style:italic>L</span><span>; </span><span style=color:#75715e>// 查找';'字符
</span><span>    </span><span style=color:#f92672>return </span><span>(input </span><span style=color:#f92672>- </span><span style=color:#ae81ff>0x0101010101010101</span><span style=color:#66d9ef;font-style:italic>L</span><span>) </span><span style=color:#f92672>& ~</span><span>input </span><span style=color:#f92672>& </span><span style=color:#ae81ff>0x8080808080808080</span><span style=color:#66d9ef;font-style:italic>L</span><span>;
</span><span>}
</span></code></pre><ul><li>一次操作可以在8个字节中查找分隔符<li>避免逐字节比较</ul><h3 id=6-gao-xiao-ha-xi-biao>6. 高效哈希表</h3><pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span style=color:#f92672>private static final </span><span style=color:#66d9ef;font-style:italic>int </span><span style=color:#ae81ff>HASH_TABLE_SIZE </span><span style=color:#f92672>= </span><span style=color:#ae81ff>1 </span><span style=color:#f92672><< </span><span style=color:#ae81ff>17</span><span>; </span><span style=color:#75715e>// 128K
</span></code></pre><ul><li>使用开放寻址法处理哈希冲突<li>针对城市名称优化的哈希函数</ul><h3 id=7-zi-fu-chuan-bi-jiao-you-hua>7. 字符串比较优化</h3><pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span style=color:#75715e>// 直接比较内存中的long值而非字符串
</span><span style=color:#f92672>if </span><span>(existingResult.firstNameWord </span><span style=color:#f92672>==</span><span> word </span><span style=color:#f92672>&&</span><span> existingResult.secondNameWord </span><span style=color:#f92672>==</span><span> word2) {
</span><span>    </span><span style=color:#f92672>return</span><span> existingResult;
</span><span>}
</span></code></pre><h2 id=xing-neng-te-dian>性能特点</h2><h3 id=chu-li-su-du>处理速度</h3><ul><li>在Intel i9-13900K上运行时间：0.31秒<li>相比参考实现的120.37秒，提升约388倍</ul><h3 id=guan-jian-you-hua-lai-yuan>关键优化来源</h3><ol><li><strong>内存映射</strong> - 消除文件IO开销<li><strong>SIMD式处理</strong> - 8字节批量操作<li><strong>无分支算法</strong> - 避免CPU分支预测失败<li><strong>多级并行</strong> - 进程+线程+段内并行<li><strong>缓存友好</strong> - 连续内存访问模式</ol><h2 id=shu-ju-jie-gou>数据结构</h2><h3 id=resultlei>Result类</h3><pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span style=color:#f92672>private static final </span><span style=color:#66d9ef;font-style:italic>class </span><span style=color:#a6e22e;text-decoration:underline>Result </span><span>{
</span><span>    </span><span style=color:#66d9ef;font-style:italic>long </span><span>firstNameWord, secondNameWord; </span><span style=color:#75715e>// 城市名前16字节
</span><span>    </span><span style=color:#66d9ef;font-style:italic>short </span><span>min, max;                     </span><span style=color:#75715e>// 最小/最大温度
</span><span>    </span><span style=color:#66d9ef;font-style:italic>int </span><span>count;                          </span><span style=color:#75715e>// 记录数量
</span><span>    </span><span style=color:#66d9ef;font-style:italic>long </span><span>sum;                           </span><span style=color:#75715e>// 温度总和
</span><span>    </span><span style=color:#66d9ef;font-style:italic>long </span><span>nameAddress;                   </span><span style=color:#75715e>// 名称在内存中的地址
</span><span>}
</span></code></pre><p>这个程序展示了现代Java在极端性能优化方面的能力，通过底层内存操作、并行计算和算法优化，实现了接近C/C++级别的性能。</div></div></section>