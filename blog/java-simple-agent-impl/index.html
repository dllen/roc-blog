<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>How to Write a Javaagent | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2021-03-18</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">How to Write a Javaagent</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h2 id=shen-me-shi-java-agentji-shu>什么是Java Agent技术</h2><p>Java Agent本质上可以理解为一个插件，该插件就是一个精心提供的Jar包，这个Jar包通过JVMTI（JVM Tool Interface）完成加载，最终借助<a href=https://github.com/openjdk/jdk/blob/master/src/java.instrument/share/native/libinstrument/JPLISAgent.c>JPLISAgent</a>（Java Programming Language Instrumentation Services Agent）完成对目标代码的修改。<p><strong>Java agent的功能</strong><ul><li>可以在加载Java文件之前做拦截把字节码做修改<li>可以在运行期将已经加载的类的字节码做变更<li>………..</ul><p>使用场景<ul><li><p>APM 工具：如 Pinpoint、SkyWalking 等</p><li><p>动态调试和诊断：比较流行的 btrace、arthas 等</p><li><p>热部署：jrebel</p><li><p>混沌工程：jvm-sandbox 等</p></ul><p><img alt src=https://scp-net-cn.oss-cn-beijing.aliyuncs.com/blog-images/java-agent-overview-min.png><h4 id=shi-xian-agentqi-dong-fang-fa>实现Agent启动方法</h4><p>Java Agent支持目标JVM启动时加载，也支持在目标JVM运行时加载，这两种不同的加载模式会使用不同的入口函数，如果需要在目标JVM启动的同时加载Agent，那么可以选择实现下面的方法：<pre><code>[1] public static void premain(String agentArgs, Instrumentation inst);
[2] public static void premain(String agentArgs);
</code></pre><p>JVM将首先寻找[1]，如果没有发现[1]，再寻找[2]。如果希望在目标JVM运行时加载Agent，则需要实现下面的方法：<pre><code>[1] public static void agentmain(String agentArgs, Instrumentation inst);
[2] public static void agentmain(String agentArgs);
</code></pre><p>这两组方法的第一个参数AgentArgs是随同 <code>–javaagent</code> 一起传入的程序参数，如果这个字符串代表了多个参数，就需要自己解析这些参数。inst是<code>Instrumentation</code>类型的对象，是JVM自动传入的，我们可以拿这个参数进行类增强等操作。<h4 id=zhi-ding-main-class>指定Main-Class</h4><p>Agent需要打包成一个jar包，在ManiFest属性中指定<code>Premain-Class</code>或者<code>Agent-Class</code>：<pre><code>Premain-Class: class
Agent-Class: class
</code></pre><h4 id=gua-zai-dao-mu-biao-jvm>挂载到目标JVM</h4><p>将编写的Agent打成jar包后，就可以挂载到目标JVM上去了。如果选择在目标JVM启动时加载Agent，则可以使用<code>-javaagent:[=]</code>，具体的使用方法可以使用<code>Java -Help</code>来查看。<p>如果想要在运行时挂载Agent到目标JVM，就需要做一些额外的开发了。<p>``com.sun.tools.attach.VirtualMachine 这个类代表一个JVM抽象，可以通过这个类找到目标JVM，并且将Agent挂载到目标JVM上。<p>下面是使用<code>com.sun.tools.attach.VirtualMachine</code>进行动态挂载Agent的一般实现：<pre class=language-java data-lang=java><code class=language-java data-lang=java>    private void attachAgentToTargetJVM() throws Exception {
        List&LTVirtualMachineDescriptor> virtualMachineDescriptors = VirtualMachine.list();
        VirtualMachineDescriptor targetVM = null;
        for (VirtualMachineDescriptor descriptor : virtualMachineDescriptors) {
            if (descriptor.id().equals(configure.getPid())) {
                targetVM = descriptor;
                break;
            }
        }
        if (targetVM == null) {
            throw new IllegalArgumentException("could not find the target jvm by process id:" + configure.getPid());
        }
        VirtualMachine virtualMachine = null;
        try {
            virtualMachine = VirtualMachine.attach(targetVM);
            virtualMachine.loadAgent("{agent}", "{params}");
        } catch (Exception e) {
            if (virtualMachine != null) {
                virtualMachine.detach();
            }
        }
    }
</code></pre><p>首先通过指定的进程ID找到目标JVM，然后通过Attach挂载到目标JVM上，执行加载Agent操作。VirtualMachine的Attach方法就是用来将Agent挂载到目标JVM上去的，而Detach则是将Agent从目标JVM卸载。<p><strong><a href=https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html>Instrumentation (Java Platform SE 8 )</a></strong> 类提供检测 Java 编程语言代码所需的服务。Instrumentation 是在方法中添加字节码，以收集工具使用的数据。由于更改纯粹是附加的，因此这些工具不会修改应用程序状态或行为。这种良性工具的示例包括监控代理、分析器、覆盖分析器和事件记录器。<ul><li><code>addTransformer</code>: 添加一个类转换器<li><code>removeTransformer</code>: 删除一个类转换器<li><code>isRetransformClassesSupported</code>: 判断是否支持类的重新转换<li><code>retransformClasses</code>: 在类加载后，重新定义该类<li><code>isRedefineClassesSupported</code>: 判断是否支持重新定义类<li><code>redefineClasses</code>: 重新进行类的定义<li><code>isModifiableClass</code>: 确定一个类是否可以通过重新转换或重新定义来修改<li><code>getAllLoadedClasses</code>: 返回 JVM 当前加载的所有类的数组<li><code>getInitiatedClasses</code>: 返回 loader 为其初始加载器的所有类的数组。如果提供的加载器为空，则返回由引导类加载器启动的类<li>……</ul><h3 id=premain-jing-tai-fang-shi>premain 静态方式</h3><blockquote><p>大多数中间件/工具的使用方式<p>使用方法：java -javaagent:xxx.jar MyApp</blockquote><p>代码地址：<a href=https://gitee.com/dllen/dllen-demos/tree/master/application-premain>application-premain</a><p>编译和测试：<pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 编译打包
mvn clean package
# 执行
java -javaagent:target/application-premain-jar-with-dependencies.jar  -cp target/application-premain-jar-with-dependencies.jar com.ks.test.app.MyApp

# 执行结果（方法执行前后添加代码）
=====start=====
Hello World!
=====end=====
=====start=====
Hello World!
=====end=====
</code></pre><h4 id=he-xin-dai-ma>核心代码</h4><p><code>MyTransformer.java</code> 类是具体实现字节码植入的实现类<pre class=language-java data-lang=java><code class=language-java data-lang=java>import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.security.ProtectionDomain;
import java.util.Objects;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;

public class MyTransformer implements ClassFileTransformer {


    public byte[] transform(ClassLoader loader, String className, Class&LT?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {

        //跳过java自带方法
        if (className.startsWith("java") || className.startsWith("sun")) {
            return classfileBuffer;
        }

        //好像使用premain这个className是没问题的，但使用attach时className的.变成了/，所以如果是attach，那么这里需要替换
        className = className.replace("/", ".");

        //只处理MyApp类
        if (!className.endsWith("MyApp")) {
            return classfileBuffer;
        }
        //使用javassist类库对字节码修改
        try {
            ClassPool classPool = ClassPool.getDefault();
            CtClass ctClass = classPool.get(className);
            CtMethod[] declaredMethods = ctClass.getDeclaredMethods();

            for (CtMethod declaredMethod : declaredMethods) {
                //只处理printSth方法
                if (Objects.equals("printHello", declaredMethod.getName())) {
                    //在方法执行前插入打印语句
                    declaredMethod.insertBefore("System.out.println(\"=====start=====\");");
                    //在方法执行后插入打印语句
                    declaredMethod.insertAfter("System.out.println(\"=====end=====\");");

                    break;
                }
            }

            return ctClass.toBytecode();

        } catch (Exception e) {
            e.printStackTrace();
        }

        return classfileBuffer;
    }
}
</code></pre><p><code>PremainMain.java</code> Java Agent内部约定的 <code>premain</code> 实现：<pre class=language-java data-lang=java><code class=language-java data-lang=java>import java.lang.instrument.Instrumentation;

public class PremainMain {

    /*
     * 注意，这个premain方法签名是Java Agent约定的，不要随意修改
     * @param agentArgs
     * @param instrumentation
     */
    public static void premain(String agentArgs, Instrumentation instrumentation) {
        instrumentation.addTransformer(new MyTransformer());
    }

    //PremainMain#premain的方法签名是Java Agent内部约定的，不能随意修改。

}
</code></pre><p><code>resouces/META-INF/MANIFEST.MF</code>通过 <code>MANIFEST.MF</code> 文件找到 <code>premain</code> 的实现类<pre class=language-java data-lang=java><code class=language-java data-lang=java>Manifest-Version: 1.0
Created-By: dllen
Premain-Class: com.ks.test.app.PremainMain
</code></pre><blockquote><p>注意：最后一行需要留一个空行</blockquote><p><code>MyApp.java</code> 测试应用<pre class=language-java data-lang=java><code class=language-java data-lang=java>import java.util.concurrent.TimeUnit;


public class MyApp {

    public static void main(String[] args) {
        while (true) {
            printHello();
        }
    }


    private static void printHello() {
        System.out.println("Hello World!");

        try {
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h3 id=attach-dong-tai-fang-shi>attach 动态方式</h3><blockquote><p>混沌工程-故障注入，应用调试和诊断的实现方式</blockquote><p>代码地址：<a href=https://gitee.com/dllen/dllen-demos/tree/master/application-attach>application-attach</a><p>编译和测试：<pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 编译打包
mvn clean package

# 终端 1
java -cp target/application-premain-jar-with-dependencies.jar com.ks.test.app.MyApp

# 终端 2
# 使用 ps 找到 进程id
java -cp ./target/application-premain-jar-with-dependencies.jar com.ks.test.app.AttachMain ${pid} ./target/application-premain-jar-with-dependencies.jar
# attach success!


# 终端 1 结果

Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
come in agentmain
clazz = com.ks.test.app.AttachAgent
clazz = com.ks.test.app.MyApp
=====start=====
Hello World!
=====end=====
=====start=====
Hello World!
=====end=====
</code></pre><h4 id=he-xin-dai-ma-1>核心代码</h4><p><code>MyAttachTransformer.java</code> 代码植入类<pre class=language-java data-lang=java><code class=language-java data-lang=java>import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.security.ProtectionDomain;
import java.util.Objects;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;

public class MyAttachTransformer implements ClassFileTransformer {


    public byte[] transform(ClassLoader loader, String className, Class&LT?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
        //跳过java自带方法
        if (className.startsWith("java") || className.startsWith("sun")) {
            return classfileBuffer;
        }

        //好像使用premain这个className是没问题的，但使用attach时className的.变成了/，所以如果是attach，那么这里需要替换
        className = className.replace("/", ".");

        //只处理MyApp类
        if (!className.endsWith("MyApp")) {
            return classfileBuffer;
        }

        try {
            ClassPool classPool = ClassPool.getDefault();
            CtClass ctClass = classPool.get(className);
            CtMethod[] declaredMethods = ctClass.getDeclaredMethods();

            for (CtMethod declaredMethod : declaredMethods) {
                //只处理printSth方法
                if (Objects.equals("printHello", declaredMethod.getName())) {
                    //在方法执行前插入打印语句
                    declaredMethod.insertBefore("System.out.println(\"=====start=====\");");
                    //在方法执行后插入打印语句
                    declaredMethod.insertAfter("System.out.println(\"=====end=====\");");

                    break;
                }
            }

            return ctClass.toBytecode();

        } catch (Exception e) {
            e.printStackTrace();
        }

        return classfileBuffer;
    }
}
</code></pre><p><code>AttachAgent.java</code>实现 <code>agentmain</code> 方法<pre class=language-java data-lang=java><code class=language-java data-lang=java>import java.lang.instrument.Instrumentation;
import java.lang.instrument.UnmodifiableClassException;

public class AttachAgent {

    /*
     * 注意：agentmain的方法签名也是约定好的，不能随意修改
     *
     * 其实如果要支持premain和attach两种方式的话，可以把premain和agentmain两个方法写在一个类里，这里为了方便演示，写成了两个
     *
     * @param agentArgs
     * @param instrumentation
     */
    public static void agentmain(String agentArgs, Instrumentation instrumentation) {
        String targetClassPath = "com.ks.test.app.MyApp";

        System.out.println("come in agentmain");

        for (Class&LT?> clazz : instrumentation.getAllLoadedClasses()) {

            // 过滤掉不能修改的类
            if (!instrumentation.isModifiableClass(clazz)) {
                continue;
            }

            System.out.println("clazz = " + clazz.getName());

            // 只修改我们关心的类
            if (clazz.getName().equals(targetClassPath)) {
                // 最根本的目的还是把MyTransformer添加到instrumentation中
                instrumentation.addTransformer(new MyAttachTransformer(), true);
                try {
                    instrumentation.retransformClasses(clazz);
                } catch (UnmodifiableClassException e) {
                    e.printStackTrace();
                }

                return;
            }
        }
    }
}
</code></pre><p><code>resouces/META-INF/MANIFEST.MF</code>通过 <code>MANIFEST.MF</code> 文件找到 <code>agentmain</code> 的实现类<pre><code>Manifest-Version: 1.0
Created-By: dllen
Agent-Class: com.ks.test.app.AttachAgent
Can-Redefine-Classes: true
Can-Retransform-Classes: true
</code></pre><p><code>AttachMain.java</code> 在运行时挂载Agent到目标JVM<pre class=language-java data-lang=java><code class=language-java data-lang=java>import com.sun.tools.attach.VirtualMachine;
import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;

public class AttachMain {

    /*
     * 加载 tools.jar
     *
     * @throws NoSuchMethodException
     * @throws MalformedURLException
     * @throws InvocationTargetException
     * @throws IllegalAccessException
     */
    private static void prepareAttach() throws NoSuchMethodException, MalformedURLException, InvocationTargetException, IllegalAccessException {
        String binPath = System.getProperty("sun.boot.library.path");
        // remove jre/bin, replace with lib
        String libPath = binPath.substring(0, binPath.length() - 7) + "lib";
        URLClassLoader loader = (URLClassLoader) AttachMain.class.getClassLoader();
        Method addURLMethod = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
        addURLMethod.setAccessible(true);
        File toolsJar = new File(libPath + "/tools.jar");
        if (!toolsJar.exists()) {
            throw new RuntimeException(toolsJar.getAbsolutePath() + " does not exist");
        }
        addURLMethod.invoke(loader, new File(libPath + "/tools.jar").toURI().toURL());
    }

    public static void main(String[] args) {

        String pid = args[0];
        String agentPath = args[1];

        File agentFile = new File(agentPath);

        if (!agentFile.exists()) {
            System.out.println("Agent not exist!");
            return;
        }

        try {

            prepareAttach();

            VirtualMachine virtualMachine = VirtualMachine.attach(pid);
            virtualMachine.loadAgent(agentFile.getAbsolutePath());

            virtualMachine.detach();

            System.out.println("attach success!");
        } catch (Exception e) {
            e.printStackTrace();
        }

        // attach ok
    }
}
</code></pre><blockquote><p>需要传递2个参数<p>    目标Java进程ID<p>    Agent的路径</blockquote><h3 id=can-kao-zi-liao>参考资料</h3><ul><li><p><a href=http://www.taoxuefeng.com/JAVA/jdk/agent.html>java agent · GitBook</a></p><li><p><a href=https://zhengw-tech.com/2023/05/27/java-agent/>JavaAgent使用及原理 | 个人网页</a></p><li><p><a href=https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html>Java 动态调试技术原理及实践 - 美团技术团队</a></p><li><p><a href=https://www.cnblogs.com/rickiyang/p/11368932.html>javaagent使用指南 - rickiyang - 博客园</a></p><li><p><a href=https://www.kancloud.cn/alex_wsc/javajvm/1844993>第21讲：深入剖析：如何使用 Java Agent 技术对字节码进行修改 · 深入浅出Java虚拟机 · 看云</a></p><li><p><a href=https://cloud.tencent.com/developer/article/2161810>谈谈Java Agent技术的实现-腾讯云开发者社区-腾讯云</a></p><li><p>https://segmentfault.com/a/1190000039731381</p><li><p><a href=https://veryjj.github.io/2021/01/01/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0Java%E5%AD%97%E8%8A%82%E7%A0%81Demo/>手把手教你Java字节码Demo</a></p><li><p><a href=https://www.hollischuang.com/archives/592>深入探索 Java 热部署</a></p></ul><h3 id=zi-jie-ma-cao-zuo-ku>字节码操作库</h3><ul><li><p>https://asm.ow2.io/</p><li><p><a href=https://github.com/cglib/cglib>GitHub - cglib/cglib</a></p><li><p>https://www.javassist.org/</p><li><p><a href=https://bytebuddy.net/#/>Byte Buddy - runtime code generation for the Java virtual machine</a></p></ul><h3 id=kai-yuan-xiang-mu>开源项目</h3><ul><li><p><a href=https://github.com/alibaba/jvm-sandbox>GitHub - alibaba/jvm-sandbox: Real - time non-invasive AOP framework container based on JVM</a></p><li><p><a href=https://github.com/btraceio/btrace>GitHub - btraceio/btrace: BTrace - a safe, dynamic tracing tool for the Java platform</a></p><li><p><a href=https://github.com/alibaba/arthas>GitHub - alibaba/arthas: Alibaba Java Diagnostic Tool Arthas/Alibaba Java诊断利器Arthas</a></p><li><p><a href=https://github.com/pinpoint-apm/pinpoint>GitHub - pinpoint-apm/pinpoint: APM, (Application Performance Management) tool for large-scale distributed systems.</a></p><li><p><a href=https://github.com/apache/skywalking>GitHub - apache/skywalking: APM, Application Performance Monitoring System</a></p><li><p><a href=https://github.com/pandening/Java-debug-tool>GitHub - pandening/Java-debug-tool: Java dynamic debug tool</a></p></ul></div></div></section>