<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Spring 源码阅读：04. 依赖注入 (DI) 的实现 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/spring/> /spring </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-14</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Spring 源码阅读：04. 依赖注入 (DI) 的实现</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>依赖注入 (Dependency Injection) 是 IoC 的具体实现。Spring 如何解决最棘手的“循环依赖”问题？<h2 id=1-getbean-de-di-gui-luo-ji>1. getBean 的递归逻辑</h2><p>当 Spring 创建 Bean A 时，发现 A 依赖 B：<ol><li><code>getBean(A)</code> -> <code>createBean(A)</code>。<li><code>populateBean(A)</code> -> 发现依赖 B。<li><code>getBean(B)</code> -> <code>createBean(B)</code>。<li><code>populateBean(B)</code> -> 发现依赖 A。<li><code>getBean(A)</code> -> <strong>?</strong></ol><p>如果直接递归，会死循环。Spring 引入了“三级缓存”。<h2 id=2-san-ji-huan-cun-defaultsingletonbeanregistry>2. 三级缓存 (<code>DefaultSingletonBeanRegistry</code>)</h2><pre class=language-java data-lang=java><code class=language-java data-lang=java>// 1. 一级缓存：成品 Bean (已完成初始化)
Map&LTString, Object> singletonObjects = new ConcurrentHashMap<>(256);

// 2. 二级缓存：半成品 Bean (已实例化，未初始化，未填充属性)
Map&LTString, Object> earlySingletonObjects = new HashMap<>(16);

// 3. 三级缓存：ObjectFactory (用于生成半成品 Bean，可能包含 AOP 逻辑)
Map&LTString, ObjectFactory&LT?>> singletonFactories = new HashMap<>(16);
</code></pre><h2 id=3-jie-jue-liu-cheng>3. 解决流程</h2><p>回到 A 和 B 的例子：<ol><li><code>createBean(A)</code>: 实例化 A。将 <code>() -> getEarlyBeanReference(A)</code> 放入<strong>三级缓存</strong>。<li><code>populateBean(A)</code>: 需要 B。调用 <code>getBean(B)</code>。<li><code>createBean(B)</code>: 实例化 B。将 B 的工厂放入三级缓存。<li><code>populateBean(B)</code>: 需要 A。调用 <code>getBean(A)</code>。<li><code>getBean(A)</code>: <ul><li>一级缓存？没有。<li>二级缓存？没有。<li>三级缓存？<strong>有！</strong> 调用 Factory 获取 A 的半成品引用（如果有 AOP，这里会提前创建代理）。<li>将 A 放入<strong>二级缓存</strong>，移除三级缓存。返回 A。</ul><li><code>populateBean(B)</code>: 拿到 A 的引用，B 初始化完成。放入一级缓存。<li><code>populateBean(A)</code>: 拿到 B 的引用 (B 已经是成品)，A 初始化完成。放入一级缓存。</ol><h2 id=4-wei-shen-me-xu-yao-san-ji-er-ji-bu-gou-ma>4. 为什么需要三级？二级不够吗？</h2><p>如果只有二级缓存，可以解决普通对象的循环依赖。 但在 <strong>AOP</strong> 场景下，B 需要注入的是 A 的代理对象 ($Proxy)，而不是 A 的原始对象。 Spring 的原则是：Bean 在生命周期的最后一步 (<code>postProcessAfterInitialization</code>) 才创建代理。 为了解决循环依赖，必须提前创建代理。 <strong>三级缓存 (<code>singletonFactories</code>) 的作用就是</strong>：延迟决策。只有当真正发生循环依赖时，才通过 <code>ObjectFactory</code> 提前执行 AOP 代理创建逻辑；否则，按正常流程在最后创建。<hr><p><strong>Next</strong>: <a href=../05-aop-proxy/>Spring 源码阅读：05. AOP 代理机制</a></div></div></section>