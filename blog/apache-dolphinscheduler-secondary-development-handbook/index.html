<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Apache DolphinScheduler 二次开发技术手册 | Roc's Blog</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2025-10-25</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Apache DolphinScheduler 二次开发技术手册</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=1-xiang-mu-jie-shao>1. 项目介绍</h1><p>Apache DolphinScheduler 是一款面向数据工程的现代化工作流编排平台，支持通过 Web 可视化拖拽构建复杂的依赖拓扑，具备高可用与高性能的分布式架构，提供丰富的内置任务类型（Shell、Python、Spark、Flink、HTTP、SQL 等），并支持跨云与多数据中心编排。<a href=https://github.com/apache/dolphinscheduler>参考：GitHub 项目主页</a><ul><li>核心功能：工作流定义与版本管理、任务编排与重试、定时调度、资源中心、告警与权限、多租户与项目隔离。<li>架构设计：去中心化多 Master/Worker 架构，基于队列/注册中心的调度协调，任务类型采用插件化机制，UI 前后端分离。<li>主要场景：数据集成、ETL/ELT、机器学习训练与部署流水线、跨系统批任务编排。<li>技术特点：高并发调度、水平扩展、插件化任务/告警通道、开放 API 与 SDK、K8s/容器化支持。</ul><p>示意架构（简化）：<pre style=color:#f8f8f2;background-color:#272822><code><span>+-----------+      +----------+      +-----------+
</span><span>|   UI/API  | ---> |  Master  | ---> |   Worker  |
</span><span>+-----------+      +----------+      +-----------+
</span><span>      |                 |                   |
</span><span>      v                 v                   v
</span><span>   Metadata         Queue/ZK             Task Plugins
</span><span>   (MySQL/PG)    (Coordination)         (Shell/SQL/...)
</span></code></pre><h1 id=2-kai-fa-huan-jing-da-jian>2. 开发环境搭建</h1><p>软硬件要求（建议值）：<ul><li>OS：macOS/Linux（x86_64/arm64）<li>JDK：Java 8/11（开发者常用 11）<li>构建：Maven 3.6+，Node.js 16+/npm 或 pnpm（前端），Git<li>中间件：MySQL/PG、ZooKeeper（或注册服务）、可选：Docker/K8s<li>资源：8GB+ 内存，20GB+ 磁盘</ul><p>配置步骤：<ol><li>安装 JDK 与 Maven，并设置 <code>JAVA_HOME</code>、<code>MAVEN_HOME</code> 与 <code>PATH</code>。<li>安装 Node.js 与 npm（用于构建前端 UI）。<li>准备数据库（MySQL/PG）与用户；初始化 DolphinScheduler 元数据（参考官方文档）。<li>获取源代码：</ol><pre style=color:#f8f8f2;background-color:#272822><code><span># 拉取源码
</span><span>git clone https://github.com/apache/dolphinscheduler.git
</span><span>cd dolphinscheduler
</span><span>
</span><span># 构建后端（跳过测试可加快首次构建）
</span><span>mvn -Prelease -DskipTests clean package
</span><span>
</span><span># 构建前端 UI（不同版本可能已集成到 Maven）
</span><span>cd dolphinscheduler-ui
</span><span>npm install && npm run build
</span></code></pre><ol start=5><li>本地快速体验（不同版本命令略有差异）：</ol><pre style=color:#f8f8f2;background-color:#272822><code><span># Standalone/本地启动示例（参考官方 quickstart）
</span><span># 部署包生成后进入 bin 目录
</span><span>./bin/dolphinscheduler-daemon.sh start master-server
</span><span>./bin/dolphinscheduler-daemon.sh start worker-server
</span><span>./bin/dolphinscheduler-daemon.sh start api-server
</span></code></pre><h1 id=3-er-ci-kai-fa-zhi-nan>3. 二次开发指南</h1><p>核心模块与扩展点（以 3.x 为例）：<ul><li>Server 层：Master（调度协调）、Worker（任务执行）、API（接口与权限）。<li>Task 插件：通过 SPI/插件机制扩展任务类型（自定义 TaskChannel/Factory）。<li>Alert 插件：扩展告警渠道（邮件、钉钉、飞书、企业微信、Webhook 等）。<li>Resource/Storage：交互资源中心（脚本、UDF、队列、数据源适配）。<li>UI 扩展：前端新增任务表单字段、类型图标与配置联动。</ul><p>自定义任务类型示例（伪代码，展示结构）：<pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span style=color:#75715e>// 依赖：实现任务插件工厂与执行器，按版本对应接口命名可能不同
</span><span style=color:#f92672>public </span><span style=color:#66d9ef;font-style:italic>class </span><span style=color:#a6e22e;text-decoration:underline>HttpTaskChannelFactory </span><span style=color:#f92672>implements </span><span style=color:#a6e22e;font-style:italic;text-decoration:underline>TaskChannelFactory </span><span>{
</span><span>  @Override
</span><span>  </span><span style=color:#f92672>public </span><span style=color:#66d9ef;font-style:italic>String </span><span style=color:#a6e22e>getName</span><span>() { </span><span style=color:#f92672>return </span><span style=color:#e6db74>"HTTP"</span><span>; }
</span><span>  @Override
</span><span>  </span><span style=color:#f92672>public </span><span style=color:#66d9ef;font-style:italic>TaskChannel </span><span style=color:#a6e22e>create</span><span>() { </span><span style=color:#f92672>return new </span><span style=color:#66d9ef;font-style:italic>HttpTaskChannel</span><span>(); }
</span><span>}
</span><span>
</span><span style=color:#f92672>public </span><span style=color:#66d9ef;font-style:italic>class </span><span style=color:#a6e22e;text-decoration:underline>HttpTaskChannel </span><span style=color:#f92672>implements </span><span style=color:#a6e22e;font-style:italic;text-decoration:underline>TaskChannel </span><span>{
</span><span>  @Override
</span><span>  </span><span style=color:#f92672>public </span><span style=color:#66d9ef;font-style:italic>TaskExecutor </span><span style=color:#a6e22e>createExecutor</span><span>(</span><span style=color:#66d9ef;font-style:italic>TaskExecutionContext </span><span style=color:#fd971f;font-style:italic>ctx</span><span>) {
</span><span>    </span><span style=color:#f92672>return new </span><span style=color:#66d9ef;font-style:italic>HttpTaskExecutor</span><span>(ctx);
</span><span>  }
</span><span>}
</span><span>
</span><span style=color:#f92672>public </span><span style=color:#66d9ef;font-style:italic>class </span><span style=color:#a6e22e;text-decoration:underline>HttpTaskExecutor </span><span style=color:#f92672>extends </span><span style=color:#a6e22e;font-style:italic;text-decoration:underline>AbstractTaskExecutor </span><span>{
</span><span>  </span><span style=color:#f92672>public </span><span style=color:#a6e22e>HttpTaskExecutor</span><span>(</span><span style=color:#66d9ef;font-style:italic>TaskExecutionContext </span><span style=color:#fd971f;font-style:italic>ctx</span><span>) { super(ctx); }
</span><span>  @Override
</span><span>  </span><span style=color:#f92672>public </span><span style=color:#66d9ef;font-style:italic>void </span><span style=color:#a6e22e>handle</span><span>(</span><span style=color:#66d9ef;font-style:italic>TaskExecutionContext </span><span style=color:#fd971f;font-style:italic>ctx</span><span>) </span><span style=color:#f92672>throws </span><span style=color:#66d9ef;font-style:italic>Exception </span><span>{
</span><span>    </span><span style=color:#75715e>// 从上下文读取参数（URL、Method、Headers、Body 等）
</span><span>    </span><span style=color:#66d9ef;font-style:italic>String</span><span> url </span><span style=color:#f92672>=</span><span> ctx.getTaskParams().get(</span><span style=color:#e6db74>"url"</span><span>);
</span><span>    </span><span style=color:#75715e>// 调用 HTTP 客户端执行，写入日志与结果
</span><span>    </span><span style=color:#66d9ef;font-style:italic>int</span><span> code </span><span style=color:#f92672>= </span><span style=color:#66d9ef;font-style:italic>HttpClient</span><span>.post(url, ctx.getTaskParams());
</span><span>    </span><span style=color:#f92672>if </span><span>(code </span><span style=color:#f92672>!= </span><span style=color:#ae81ff>200</span><span>) </span><span style=color:#f92672>throw new </span><span style=color:#66d9ef;font-style:italic>RuntimeException</span><span>(</span><span style=color:#e6db74>"HTTP task failed"</span><span>);
</span><span>  }
</span><span>}
</span></code></pre><p>注册与打包：<ul><li>将自定义插件模块按项目约定放入 <code>dolphinscheduler-*-plugin</code> 目录，并在 <code>pom.xml</code> 中声明。<li>按需使用 <code>META-INF/services</code> 或注解方式（例如 AutoService）注册接口实现。<li>在 UI 中为新任务类型增加表单与校验，API 增加参数映射。</ul><p>自定义告警通道示例（伪代码）：<pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span style=color:#f92672>public </span><span style=color:#66d9ef;font-style:italic>class </span><span style=color:#a6e22e;text-decoration:underline>FeishuAlertChannel </span><span style=color:#f92672>implements </span><span style=color:#a6e22e;font-style:italic;text-decoration:underline>AlertChannel </span><span>{
</span><span>  @Override
</span><span>  </span><span style=color:#f92672>public </span><span style=color:#66d9ef;font-style:italic>AlertResult </span><span style=color:#a6e22e>send</span><span>(</span><span style=color:#66d9ef;font-style:italic>AlertInfo </span><span style=color:#fd971f;font-style:italic>info</span><span>) {
</span><span>    </span><span style=color:#75715e>// 将告警内容组装成消息卡片，调用飞书 Webhook
</span><span>    </span><span style=color:#66d9ef;font-style:italic>String</span><span> webhook </span><span style=color:#f92672>=</span><span> info.getProps().get(</span><span style=color:#e6db74>"webhook"</span><span>);
</span><span>    </span><span style=color:#f92672>return </span><span style=color:#66d9ef;font-style:italic>HttpClient</span><span>.jsonPost(webhook, info.toJson());
</span><span>  }
</span><span>}
</span></code></pre><p>常见扩展场景：<ul><li>新增任务类型（如：自研服务调用、特定数据源同步）。<li>增强执行策略（超时、自定义重试、幂等保障）。<li>接入企业统一告警与审计平台。<li>扩展资源中心（版本化脚本、集中密钥/凭据管理）。</ul><h1 id=4-zui-jia-shi-jian>4. 最佳实践</h1><p>经验与教训：<ul><li>与生产环境隔离：先在独立项目/租户验证插件，再灰度到生产。<li>参数与密钥：通过环境变量/凭据管理，不把密钥写入任务参数。<li>可观测性：统一日志格式、关联 traceId，收敛告警风暴。<li>版本管理：任务与工作流版本化，保持脚本与镜像可复现。</ul><p>性能优化：<ul><li>Master/Worker 水平扩展，合理分配队列与并发度。<li>使用批量与异步 IO 的任务实现，减少阻塞。<li>避免热点资源争用，拆分长链路任务，利用子工作流与并行化。<li>调整心跳与容错参数，降低无效重试与频繁超时。</ul><p>安全加固：<ul><li>细化权限与租户边界，限制高危任务类型的使用范围。<li>审计与合规：记录关键操作轨迹，敏感参数脱敏。<li>插件白名单与代码扫描（SAST/DAST），发布前强制检查。</ul><p>系统集成：<ul><li>通过 OpenAPI/SDK 将编排作为外部系统的“控制面”。<li>事件驱动集成：任务完成事件推送到消息总线触发下游流程。<li>与数据源平台/元数据中心打通，实现任务参数与血缘的自动化维护。</ul><h1 id=5-ce-shi-yu-bu-shu>5. 测试与部署</h1><p>测试方法：<ul><li>单元测试：任务/告警插件核心逻辑的快速覆盖。<li>集成测试：模拟 Master/Worker 的调度与执行链路（本地 Docker Compose）。<li>UI 测试：表单校验与交互流程（Cypress/Playwright）。</ul><p>部署方案：<ul><li>传统部署：多 Master/Worker + API，数据库高可用，ZooKeeper 集群。<li>容器化：K8s + Helm Chart，使用 HPA 与亲和/反亲和策略。<li>升级策略：先扩展新版本旁路节点，完成数据迁移与兼容验证后切流。</ul><p>贡献社区：<ul><li>遵循 Apache 规范（版权头、License、DCO），代码风格与 Checkstyle。<li>提交 PR 前：补充文档、测试用例与变更说明，关联 Issue。<li>与社区沟通：邮件列表/Slack，善用“good first issue”。</ul><hr><p>参考资料与延伸阅读：<ul><li>Apache DolphinScheduler GitHub：https://github.com/apache/dolphinscheduler<li>官方文档与 QuickStart（不同版本入口可能不同，请以官方文档为准）<li>Helm Chart 与 K8s 部署示例（社区维护）</ul><p>本文示例代码为演示结构，具体接口与包名以对应版本的官方源码与文档为准。</div></div></section>