<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>容器不同网络模式下iptables配置 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2024-01-14</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">容器不同网络模式下iptables配置</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h2 id=rong-qi-de-wang-luo-mo-shi>容器的网络模式</h2><table><thead><tr><th>Driver<th>Description<tbody><tr><td><code>bridge</code><td>The default network driver.<tr><td><code>host</code><td>Remove network isolation between the container and the Docker host.<tr><td><code>none</code><td>Completely isolate a container from the host and other containers.<tr><td><code>overlay</code><td>Overlay networks connect multiple Docker daemons together.<tr><td><code>ipvlan</code><td>IPvlan networks provide full control over both IPv4 and IPv6 addressing.<tr><td><code>macvlan</code><td>Assign a MAC address to a container.</table><h2 id=hostwang-luo-mo-shi>Host网络模式</h2><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># Create a new cgroup and assign it a classid
mkdir /sys/fs/cgroup/net_cls/my_cgroup
echo 0x100001 > /sys/fs/cgroup/net_cls/my_cgroup/net_cls.classid

# Run a Docker container and move its process to the newly created cgroup
docker run -d --name my_container my_image
echo $(docker inspect -f '{{.State.Pid}}' my_container) > /sys/fs/cgroup/net_cls/my_cgroup/cgroup.procs

# Use iptables to mark the packets based on the classid
iptables -t mangle -A OUTPUT -m cgroup --cgroup 0x100001 -j MARK --set-mark 1

# Use tc
# configuring tc
tc qdisc add dev eth0 root handle 10: htb
tc class add dev eth0 parent 10: classid 10:1 htb rate 40mbit
# creating traffic class 10:1
tc filter add dev eth0 parent 10: protocol ip prio 10 handle 1: cgroup
</code></pre><p>说明：<blockquote><p><strong>Host模式，容器与主机的网络配置没有隔离</strong>，需要通过设置 net_cls.classid 标记流量<p>参考文档：<a href=https://www.kernel.org/doc/html/v5.3/admin-guide/cgroup-v1/net_cls.html>Network classifier cgroup</a></blockquote><blockquote><p>net_cls.classid 数据格式：0xAAAABBBB， AAAA is the major handle number and BBBB is the minor handle number，eg： 0x100001 => 10:1</blockquote><h2 id=fei-hostwang-luo-mo-shi>非Host网络模式</h2><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># Get the PID of the container's network namespace
PID=$(docker inspect -f '{{.State.Pid}}' &LTcontainer_name_or_id>)

# Enter the network namespace using nsenter
nsenter --net=/proc/$PID/ns/net iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080
</code></pre><p>说明：<blockquote><p><strong>非Host模式，容器与主机网络配置通过 <a href=https://lwn.net/Articles/580893/>Network namespaces</a> 隔离</strong>，需要切换 network namespace 进行配置</blockquote><blockquote><p>network_namespaces手册：<a href=https://man7.org/linux/man-pages/man7/network_namespaces.7.html>network_namespaces(7) - Linux manual page</a></blockquote><p><strong>namespace 执行小工具</strong>，<code>nsexec.c</code> <a href=https://github.com/chaosblade-io/chaosblade/blob/master/nsexec.c>nsexec.c</a><pre class=language-c data-lang=c><code class=language-c data-lang=c>#define _GNU_SOURCE
#include &LTstdio.h>
#include &LTunistd.h>
#include &LTerrno.h>
#include &LTsched.h>
#include &LTstdio.h>
#include &LTstdlib.h>
#include &LTstring.h>
#include &LTfcntl.h>
#include &LTgetopt.h>
#include &LTsys/types.h>
#include &LTsys/wait.h>
#include &LTsys/prctl.h>
#include &LTsys/stat.h>
#include &LTsys/syscall.h>

extern char** environ;

int enter_ns(int pid, const char* type) {
#ifdef __NR_setns
    char path[64], selfpath[64];
    snprintf(path, sizeof(path), "/proc/%d/ns/%s", pid, type);
    snprintf(selfpath, sizeof(selfpath), "/proc/self/ns/%s", type);

    struct stat oldns_stat, newns_stat;
    if (stat(selfpath, &oldns_stat) == 0 && stat(path, &newns_stat) == 0) {
        // Don't try to call setns() if we're in the same namespace already
        if (oldns_stat.st_ino != newns_stat.st_ino) {
            int newns = open(path, O_RDONLY);
            if (newns < 0) {
                return -1;
            }

            // Some ancient Linux distributions do not have setns() function
            int result = syscall(__NR_setns, newns, 0);
            close(newns);
            return result < 0 ? -1 : 1;
        }
    }
#endif // __NR_setns
    return 0;
}

void sig(int signum){}

int main(int argc, char *argv[]) {

    int target = 0;
    char *cmd;

    int stop = 0;
    int opt;
    int option_index = 0;
    char *string = "st:mpuni";

    int ipcns = 0;
    int utsns = 0;
    int netns = 0;
    int pidns = 0;
    int mntns = 0;

    while((opt =getopt(argc, argv, string))!= -1) {
        switch (opt) {
            case 's':
                stop = 1;
                break;
            case 't':
                target = atoi(optarg);
                break;
            case 'm':
                mntns = 1;
                break;
            case 'p':
                pidns = 1;
                break;
            case 'u':
                utsns = 1;
                break;
            case 'n':
                netns = 1;
                break;
            case 'i':
                ipcns = 1;
                break;
            default:
                break;
        }
    }

    // check target pid
    if (target <= 0) {
        fprintf(stderr, "%s is not a valid process ID\n", target);
        return 1;
    }

    // pause
    if(stop) {
            char *pe = "pause";
            prctl(PR_SET_NAME, pe);
            signal(SIGCONT,sig);
            pause();
            char *nc = "nsexec";
            prctl(PR_SET_NAME, nc);
    }

    // enter namespace
    if(ipcns) {
        enter_ns(target, "ipc");
    }

    if(utsns) {
        enter_ns(target, "uts");
    }

    if(netns) {
        enter_ns(target, "net");
    }

    if(pidns) {
        enter_ns(target, "pid");
    }

    if(mntns) {
        enter_ns(target, "mnt");
    }

    // fork exec
    pid_t pid;
    int status;

    if((pid = fork())&LT0) {
        status = -1;
    } else if(pid == 0){
        // args
        int i,j=0;
        char *args[256] = {NULL};
        for(i = optind; i < argc; i++, j++) {
            args[j] = argv[i];
        }
        execvp(argv[optind], args);
        _exit(127);
    } else {
        while(waitpid(pid, &status, 0) < 0){
            if(errno != EINTR){
                status = -1;
                break;
            }
        }
        if(WIFEXITED(status)){
            exit(WEXITSTATUS(status));
        }
    }
    return 0;
}

</code></pre><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 测试

# compile
gcc nsexec.c -o nsexec

# Get the PID of the container's network namespace
PID=$(docker inspect -f '{{.State.Pid}}' &LTcontainer_name_or_id>)

# exec
./nsexec -n -t PID -- /bin/sh -c 'iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080'

# check
./nsexec -n -t PID -- /bin/sh -c 'iptables -t nat -L'


Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination
REDIRECT   tcp  --  anywhere             anywhere             tcp dpt:http redir ports 8080

Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
</code></pre></div></div></section>