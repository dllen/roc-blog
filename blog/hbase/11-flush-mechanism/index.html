<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>HBase 源码阅读：11. Flush 机制 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/hbase/> /hbase </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-12</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">HBase 源码阅读：11. Flush 机制</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>在 HBase 的 LSM-Tree 架构中，数据首先写入内存中的 MemStore。当 MemStore 达到一定大小时，需要将数据刷写（Flush）到磁盘生成 HFile。Flush 机制是连接内存与磁盘的关键桥梁，它直接影响写入性能、内存使用率以及后续的 Compaction 压力。<p>本文将基于 HBase 2.x 源码，深入分析 Flush 的触发时机、核心流程以及相关策略。<h2 id=1-flush-de-hong-fa-shi-ji-trigger>1. Flush 的触发时机 (Trigger)</h2><p>HBase 中触发 Flush 的条件非常多样，不仅限于 MemStore 大小，还涉及 RegionServer 的内存压力、WAL 文件数量等。<h3 id=1-1-memstore-ji-bie-xian-zhi-region-level>1.1 MemStore 级别限制 (Region Level)</h3><p>这是最常见的触发方式。当一个 Region 中所有 MemStore 的大小总和超过阈值时，会触发 Flush。<ul><li><strong>参数</strong>: <code>hbase.hregion.memstore.flush.size</code> (默认 128MB)<li><strong>行为</strong>: 这是一个 Soft Limit。当达到此值时，RegionServer 会请求 Flush 该 Region，但<strong>不会阻塞写请求</strong>。</ul><h3 id=1-2-regionserver-quan-ju-nei-cun-xian-zhi-global-level>1.2 RegionServer 全局内存限制 (Global Level)</h3><p>为了防止 RegionServer OOM，HBase 有全局的内存限制。<ul><li><strong>低水位 (Low Watermark)</strong>: <code>hbase.regionserver.global.memstore.size.lower.limit</code> (默认堆内存 * 0.4 * 0.95) <ul><li>当 RS 上所有 MemStore 总大小超过此值，会强制 Flush 占用内存最大的 Region，直到总大小降到低水位以下。<strong>此时不会阻塞写</strong>，但在日志中会有警告。</ul><li><strong>高水位 (High Watermark)</strong>: <code>hbase.regionserver.global.memstore.size</code> (默认堆内存 * 0.4) <ul><li>当 RS 上所有 MemStore 总大小超过此值，<strong>会阻塞该 RS 上的所有写请求</strong>，并强制 Flush，直到内存回落到低水位。这是非常严重的性能卡顿点。</ul></ul><h3 id=1-3-region-ji-bie-zu-sai-xian-zhi-blocking>1.3 Region 级别阻塞限制 (Blocking)</h3><p>如果某个 Region 的 MemStore 持续增长（写入速度 > Flush 速度），达到了 Flush Size 的倍数，为了保护 RS，会阻塞该 Region 的写请求。<ul><li><strong>参数</strong>: <code>hbase.hregion.memstore.block.multiplier</code> (默认 4)<li><strong>阈值</strong>: <code>flush.size</code> * <code>block.multiplier</code> (默认 128MB * 4 = 512MB)<li><strong>行为</strong>: 阻塞写请求，直到 Flush 完成。</ul><h3 id=1-4-wal-shu-liang-xian-zhi>1.4 WAL 数量限制</h3><p>为了限制故障恢复（Replay WAL）的时间，HBase 不允许保留过多的 WAL 文件。<ul><li><strong>参数</strong>: <code>hbase.regionserver.maxlogs</code> (默认 32)<li><strong>行为</strong>: 当 WAL 文件数量超过阈值，会找到最老的 WAL 对应的 Region 进行 Flush，以便可以归档旧的 WAL 文件。</ul><h3 id=1-5-ding-qi-flush>1.5 定期 Flush</h3><p>即使没有写请求，为了数据安全，HBase 也会定期 Flush。<ul><li><strong>参数</strong>: <code>hbase.regionserver.optionalcacheflushinterval</code> (默认 3600000ms = 1小时)<li><strong>行为</strong>: 只有当 MemStore 大小大于 0 且上次 Flush 距离现在超过间隔时触发。</ul><h3 id=1-6-shou-dong-flush>1.6 手动 Flush</h3><p>用户可以通过 Shell (<code>flush 'tableName'</code>) 或 Admin API 手动触发。<h2 id=2-he-xin-lei-gai-lan>2. 核心类概览</h2><p>在深入流程之前，先认识几个关键类：<ul><li><strong><code>HRegion</code></strong>: Region 的核心实现，负责处理 Put/Get 请求，也是 Flush 的发起者。<li><strong><code>MemStoreFlusher</code></strong>: RegionServer 内部的后台线程（Chore），维护一个 Flush 队列 (<code>FlushQueue</code>)，负责异步执行 Flush 任务。<li><strong><code>HStore</code></strong>: 对应一个 Column Family，包含 MemStore 和 StoreFiles。<li><strong><code>DefaultStoreFlusher</code></strong>: 具体的 Flush 逻辑实现者，负责将内存数据写成 HFile。</ul><h2 id=3-flush-he-xin-liu-cheng-process>3. Flush 核心流程 (Process)</h2><p>Flush 的执行过程大致可以分为三个阶段：<strong>Prepare (准备)</strong>、<strong>Flush (刷写)</strong>、<strong>Commit (提交)</strong>。<h3 id=3-1-jie-duan-yi-prepare-zhun-bei-jie-duan>3.1 阶段一：Prepare (准备阶段)</h3><p>此阶段在 <code>HRegion.internalFlushcache</code> 中进行。目标是创建 MemStore 的快照 (Snapshot)。<ol><li><strong>加写锁 / 更新锁</strong>: 阻塞对该 Region 的更新操作（或者更细粒度的锁），确保内存状态一致性。<li><strong>创建快照</strong>: 遍历 Region 下的所有 Store，调用 <code>Store.snapshot()</code>。 <ul><li>这步操作非常快，只是将当前的 <code>Active MemStore</code> 切换为 <code>Snapshot MemStore</code>，并创建一个新的空 <code>Active MemStore</code> 接收新写入。</ul><li><strong>释放锁</strong>: 快照创建完成后，立即释放锁。 <ul><li><strong>关键点</strong>: 这里实现了 <strong>Non-Blocking Flush</strong>。只有在创建快照的短暂时间内会阻塞写，后续的磁盘 IO 过程不会阻塞写请求。</ul></ol><h3 id=3-2-jie-duan-er-flush-shua-xie-jie-duan>3.2 阶段二：Flush (刷写阶段)</h3><p>此阶段比较耗时，主要是磁盘 IO 操作。<ol><li><strong>选择 Store</strong>: 根据 Flush 策略（如 <code>FlushAllLargeStoresPolicy</code>），决定哪些 Store 需要刷写。<li><strong>执行刷写</strong>: 对每个需要刷写的 Store，调用 <code>StoreFlusher.flushSnapshot()</code>。 <ul><li>遍历 Snapshot 中的 KeyValue。<li>通过 <code>StoreFileWriter</code> 将 KeyValue 写入临时目录下的 HFile 文件。<li><strong>追加 MemStore 扫描</strong>: 如果在刷写过程中有新的数据写入（因为锁已释放），这些新数据在新的 Active MemStore 中，不会包含在本次 Flush 中。</ul></ol><h3 id=3-3-jie-duan-san-commit-ti-jiao-jie-duan>3.3 阶段三：Commit (提交阶段)</h3><p>IO 完成后，需要更新元数据并清理快照。<ol><li><strong>移动文件</strong>: 将 HFile 从临时目录移动到正式的 Region 目录下。<li><strong>加载 Reader</strong>: 创建 <code>StoreFile</code> 对象并加载 Reader，将其加入到 <code>StoreFileManager</code> 中，此时新生成的 HFile 对读请求可见。<li><strong>清理快照</strong>: 清空 <code>Snapshot MemStore</code>，释放内存。<li><strong>更新 WAL</strong>: 记录 Flush Marker 到 WAL 中，表示该 SequenceId 之前的数据已持久化，对应的旧 WAL 可以被清理了。</ol><h2 id=4-yuan-ma-diao-yong-lian-fen-xi>4. 源码调用链分析</h2><pre class=language-java data-lang=java><code class=language-java data-lang=java>// 1. 触发入口 (例如 MemStoreFlusher 线程)
MemStoreFlusher.flushRegion(FlushRegionEntry)
  -> HRegion.flushcache() // 发起 Flush

// 2. HRegion 内部逻辑
HRegion.internalFlushcache() {
  // --- Phase 1: Prepare ---
  // 获取写锁 (updatesLock.writeLock())
  // 遍历 Stores，创建快照
  for (HStore s : stores) {
    s.snapshot(); // Active -> Snapshot
  }
  // 释放写锁，允许新的写入
  
  // --- Phase 2: Flush ---
  // 具体的 IO 操作，耗时最长
  for (HStore s : specificStoresToFlush) {
    HStore.flushCache();
      -> StoreFlusher.flushSnapshot()
        -> 创建 HFile Writer
        -> 遍历 MemStoreScanner 写入磁盘
  }
  
  // --- Phase 3: Commit ---
  // 移动文件，更新 StoreFileManager
  HStore.commitFile();
  // 清理 Snapshot
  HRegion.clearSnapshots();
}
</code></pre><h2 id=5-guan-jian-wen-ti-yu-diao-you>5. 关键问题与调优</h2><h3 id=5-1-wei-shen-me-hui-chan-sheng-xiao-wen-jian>5.1 为什么会产生小文件？</h3><p>如果 Flush 过于频繁（例如 <code>flush.size</code> 设置过小，或者因为全局内存压力导致强制 Flush），会生成大量小的 HFile。<ul><li><strong>后果</strong>: 增加 Compaction 压力，影响读取性能。<li><strong>解决</strong>: 调大 <code>hbase.hregion.memstore.flush.size</code>，合理设置全局内存水位。</ul><h3 id=5-2-flush-dui-du-xie-de-ying-xiang>5.2 Flush 对读写的影响</h3><ul><li><strong>对写</strong>: 正常情况下影响微乎其微（毫秒级锁）。但如果触发 Blocking 机制（MemStore 积压），写请求会被严重阻塞。<li><strong>对读</strong>: Flush 完成后，新的 HFile 加入，可能会触发 Minor Compaction，短时间内增加 IO 压力，但长期看有助于减少 MemStore 扫描开销。</ul><h3 id=5-3-diao-you-jian-yi>5.3 调优建议</h3><ol><li><strong>增加 Flush Size</strong>: 在内存允许的情况下，尽量调大 <code>hbase.hregion.memstore.flush.size</code> (如 256MB)，减少 Flush 频率和 HFile 数量。<li><strong>调整 Blocking 倍数</strong>: 如果写入突发流量大，可以适当调大 <code>hbase.hregion.memstore.block.multiplier</code>，给系统更多缓冲时间。<li><strong>关注日志</strong>: 监控日志中出现的 <code>Too many store files</code> 或 <code>Blocking updates</code> 警告。</ol><h2 id=6-zong-jie>6. 总结</h2><p>HBase 的 Flush 机制是 LSM-Tree 实现的核心环节。它巧妙地通过“快照+异步IO”实现了高吞吐的写入，同时通过多级触发策略保证了内存的安全。理解 Flush 流程对于排查写入性能抖动（Write Stalls）至关重要。<hr><p><strong>Next</strong>: <a href=../12-compaction/>HBase 源码阅读：12. Compaction 原理</a></div></div></section>