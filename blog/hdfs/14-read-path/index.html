<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>HDFS 源码阅读：14. 文件读取流程 (Read Path) | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/hdfs/> /hdfs </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-25</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">HDFS 源码阅读：14. 文件读取流程 (Read Path)</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p><code>FileSystem.open()</code> 返回 <code>FSDataInputStream</code>，底层是 <code>DFSInputStream</code>。<h2 id=1-hong-guan-liu-cheng>1. 宏观流程</h2><ol><li><strong>getBlockLocations (RPC)</strong>: Client 向 NameNode 查询文件的前几个 Block 的位置。 <ul><li>NameNode 返回 <code>LocatedBlocks</code>，包含 Block ID 和每个 Block 的 DataNode 列表（按距离排序，最近的排前面）。</ul><li><strong>Read Block</strong>: Client 选取最近的 DataNode，建立连接读取 Block。<li><strong>Next Block</strong>: 读完一个 Block 后，再读下一个。如果缓存的 <code>LocatedBlocks</code> 用完了，再次请求 NameNode。</ol><h2 id=2-ju-chi-pai-xu-distance-sorting>2. 距离排序 (Distance Sorting)</h2><p>NameNode 在返回 Block 位置时，会计算 Client 与 DataNode 的距离：<ul><li><strong>本地</strong>: 距离 0。<li><strong>同机架</strong>: 距离 2。<li><strong>跨机架</strong>: 距离 4。<li><strong>跨数据中心</strong>: 距离 6。</ul><p>Client 优先读取距离最近的节点。<h2 id=3-dfsinputstream-shi-xian>3. DFSInputStream 实现</h2><p><code>DFSInputStream</code> 管理着读取逻辑。<ul><li><strong><code>BlockReader</code></strong>: 抽象了读取 Block 的接口。 <ul><li><code>BlockReaderRemote</code>: 通过 TCP 读取。<li><code>BlockReaderLocal</code>: 短路读 (Short Circuit Read)。</ul></ul><pre class=language-java data-lang=java><code class=language-java data-lang=java>// DFSInputStream.java
private BlockReader getBlockReader(LocatedBlock targetBlock, ...) {
    // 尝试短路读
    if (shortCircuitEnabled && isLocal(targetBlock)) {
        return new BlockReaderLocal(...);
    }
    // 否则走 TCP
    return new BlockReaderRemote(...);
}
</code></pre><h2 id=4-gu-zhang-chu-li>4. 故障处理</h2><p>如果在读取 Block 时，DataNode A 挂了或 Checksum 校验失败：<ol><li><strong>记录坏块</strong>: 将 A 放入 <code>deadNodes</code> 列表，本次读取不再尝试 A。<li><strong>切换节点</strong>: 尝试该 Block 的下一个副本 B。<li><strong>汇报</strong>: 如果是 Checksum 错误，Client 会通过 RPC <code>reportBadBlocks</code> 告知 NameNode，NameNode 会安排副本修复。</ol><h2 id=5-zong-jie>5. 总结</h2><p>读取流程相对简单，核心在于<strong>就近读取</strong>和<strong>故障自动切换</strong>。</div></div></section>