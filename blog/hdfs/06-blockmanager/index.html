<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>HDFS 源码阅读：06. 块管理 (BlockManager) | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/hdfs/> /hdfs </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2026-01-17</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">HDFS 源码阅读：06. 块管理 (BlockManager)</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p><code>BlockManager</code> 负责管理 Block 的元数据（Block -> DataNodes 的映射），并确保副本数满足要求。<h2 id=1-he-xin-shu-ju-jie-gou>1. 核心数据结构</h2><ul><li><strong><code>BlocksMap</code></strong>: 存储 <code>BlockInfo</code> 对象。 <ul><li>Key: <code>Block</code> (blockId)<li>Value: <code>BlockInfo</code> (包含该 Block 所在的 DataNode 列表)</ul><li><strong><code>BlockInfo</code></strong>: 继承自 <code>Block</code>，增加了 <code>Triplets</code>（三元组）来存储副本位置。 <ul><li>为了节省内存，使用 Object 数组存储 DataNode 引用和链表结构。</ul></ul><pre class=language-java data-lang=java><code class=language-java data-lang=java>// BlockInfo.java
private Object[] triplets; 
// triplets[3*i]: DatanodeStorageInfo (存储该副本的 DN)
// triplets[3*i+1]: Previous BlockInfo (链表前驱)
// triplets[3*i+2]: Next BlockInfo (链表后继)
</code></pre><h2 id=2-fu-ben-fang-zhi-ce-lue-blockplacementpolicy>2. 副本放置策略 (BlockPlacementPolicy)</h2><p>当客户端写入新 Block 时，NameNode 需要选择 DataNode。默认策略 (<code>BlockPlacementPolicyDefault</code>)：<ul><li><strong>第 1 副本</strong>: 本地节点（如果是 Client 也是 DataNode），或者随机选择一个（如果 Client 在集群外）。<li><strong>第 2 副本</strong>: 不同机架的节点（保证机架容错）。<li><strong>第 3 副本</strong>: 与第 2 副本相同机架的另一个节点（减少跨机架网络流量）。<li><strong>更多副本</strong>: 随机，但尽量不放在已有的机架。</ul><h2 id=3-fu-ben-jian-kong-replicationmonitor>3. 副本监控 (ReplicationMonitor)</h2><p><code>RedundancyMonitor</code> 线程定期检查：<ol><li><p><strong>Under-replicated Blocks (副本数不足)</strong>:</p> <ul><li>加入优先队列 <code>neededReconstruction</code>。<li>优先级规则：副本数越少（如只有 1 个），优先级越高。<li>安排 DataNode 进行复制 (Block Replication Work)。</ul><li><p><strong>Over-replicated Blocks (副本数过多)</strong>:</p> <ul><li>加入 <code>invalidateBlocks</code> 集合。<li>通知 DataNode 删除多余副本。<li>删除策略：优先删除磁盘空间不足的、负载高的节点上的副本。</ul></ol><h2 id=4-sun-pi-kuai-chu-li-corrupt-blocks>4. 损坏块处理 (Corrupt Blocks)</h2><p>当 DataNode 汇报块损坏（Checksum 错误）或长时间未汇报心跳时，Block 会被标记为 Corrupt。<p>NameNode 不会立即删除 Corrupt Block，而是先尝试从正常的副本恢复。只有当正常副本数达到要求后，才清理 Corrupt Block。<h2 id=5-an-quan-mo-shi-zhong-de-block>5. 安全模式中的 Block</h2><p>在 SafeMode 期间，<code>BlockManager</code> 会统计所有 Block 的汇报情况。如果某个 Block 一个副本都没收到，说明数据丢失。</div></div></section>