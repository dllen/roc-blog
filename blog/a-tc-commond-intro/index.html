<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Linux TC 进阶：一行命令实现特定流量延迟 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2025-12-04</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Linux TC 进阶：一行命令实现特定流量延迟</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>本文将详细解析一行复杂的 <code>tc</code> (Traffic Control) 命令。这行命令通常用于混沌工程（Chaos Engineering）或网络模拟测试中，目的是<strong>在不影响其他流量的情况下，精准地对特定数据包施加延迟</strong>。<h2 id=ming-ling-quan-mao>命令全貌</h2><p>为了方便理解，我们先将这行命令还原为标准的 Shell 脚本格式（假设设备为 <code>eth0</code>，延迟为 <code>100ms</code>，标记为 <code>123</code>）：<pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 1. 创建优先队列
tc qdisc add dev eth0 root handle 1:0 prio bands 4

# 2. 在第4个频带添加延迟
tc qdisc add dev eth0 parent 1:4 netem delay 100ms

# 3. 添加过滤器，将标记为 123 的流量导向第4个频带
tc filter add dev eth0 parent 1:0 prio 4 protocol ip handle 123 fw flowid 1:4
</code></pre><p>在 Go 语言项目中，它通常以字符串格式化的形式出现：<pre class=language-go data-lang=go><code class=language-go data-lang=go>cmdString := fmt.Sprintf(`tc qdisc add dev %s root handle 1:0 prio bands 4 &&\
            tc qdisc add dev %s parent 1:4 netem delay %sms &&\
            tc filter add dev %s parent 1:0 prio 4 protocol ip handle %s fw flowid 1:4`, dev, dev, delayTime, dev, mark)
</code></pre><hr><h2 id=he-xin-mu-biao>核心目标</h2><p>这组命令的<strong>核心目标</strong>是：<strong>在指定的网络设备（如 <code>eth0</code>）上，仅对携带特定防火墙标记（fwmark）的数据包施加延迟，而让其他数据包保持原有的转发速度。</strong><p>它利用 <code>iptables</code> 打标和 <code>tc</code> 分流的配合来实现这一精确控制。<hr><h2 id=ming-ling-chai-jie-fen-xi>命令拆解分析</h2><p>这行长命令实际上是由三个独立的 <code>tc</code> 子命令通过 <code>&&</code> 连接而成的。我们逐一拆解：<h3 id=1-jian-li-fen-liu-shu-niu-prio-diao-du-qi>1. 建立分流枢纽：<code>prio</code> 调度器</h3><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash>tc qdisc add dev %s root handle 1:0 prio bands 4
</code></pre><ul><li><strong><code>tc qdisc add</code></strong>: 添加一个队列规则（Queueing Discipline）。<li><strong><code>dev %s</code></strong>: 指定操作的网卡设备。<li><strong><code>root</code></strong>: 挂载到根节点，接管该设备的所有出口流量。<li><strong><code>handle 1:0</code></strong>: 给这个规则分配句柄 ID <code>1:0</code>。<li><strong><code>prio bands 4</code></strong>: 使用 <code>prio</code>（优先级）调度器，并创建 4 个频道（bands，编号 0-3）。</ul><p><strong>作用</strong>：在网卡出口建立一个拥有 4 条车道的“交通枢纽”。默认情况下，流量会根据优先级进入不同的车道，但我们稍后会强制指定某些流量的去向。<h3 id=2-zhi-zao-yong-du-lu-duan-netem-yan-chi-dui-lie>2. 制造拥堵路段：<code>netem</code> 延迟队列</h3><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash>tc qdisc add dev %s parent 1:4 netem delay %sms
</code></pre><ul><li><strong><code>parent 1:4</code></strong>: 关键点！将新规则挂载到刚才 <code>prio</code> 调度器的第 4 个频道（Band 3，ID 为 <code>1:4</code>）上。<li><strong><code>netem delay %sms</code></strong>: 使用 <code>netem</code>（网络模拟器）规则，增加 <code>%s</code> 毫秒的延迟。</ul><p><strong>作用</strong>：将第 4 条车道改造成“拥堵路段”。任何进入这条车道的数据包，都必须等待指定时间才能通过。<h3 id=3-she-zhi-jiao-tong-jing-cha-filter-guo-lu-qi>3. 设置交通警察：<code>filter</code> 过滤器</h3><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash>tc filter add dev %s parent 1:0 prio 4 protocol ip handle %s fw flowid 1:4
</code></pre><ul><li><strong><code>parent 1:0</code></strong>: 过滤器挂载在主枢纽 <code>1:0</code> 上。<li><strong><code>protocol ip</code></strong>: 仅处理 IP 协议包。<li><strong><code>handle %s fw</code></strong>: 匹配规则。<code>fw</code> 代表根据防火墙标记（Firewall Mark）匹配，<code>%s</code> 是具体的标记值（如 <code>123</code>）。<li><strong><code>flowid 1:4</code></strong>: 动作。匹配中的数据包被强制导向 ID 为 <code>1:4</code> 的队列（即我们的延迟队列）。</ul><p><strong>作用</strong>：在枢纽入口设置“交警”。交警检查数据包的标记，如果发现标记匹配，就强制指挥该数据包走第 4 条“拥堵车道”。<hr><h2 id=wan-zheng-gong-zuo-liu>完整工作流</h2><p>要让这套机制生效，还需要 <code>iptables</code> 的配合。<ol><li><p><strong>打标 (<code>iptables</code>)</strong>: 在数据包离开机器前，用 <code>iptables</code> 给特定流量打上标记。例如，给发往 80 端口的 TCP 包打上标记 <code>123</code>：</p> <pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash>iptables -t mangle -A OUTPUT -p tcp --dport 80 -j MARK --set-mark 123
</code></pre><li><p><strong>分流 (<code>tc</code>)</strong>:</p> <ul><li><strong>普通流量</strong>：没有标记 <code>123</code>，经过 <code>prio</code> 调度器时，按默认策略（通常走 Band 1 或 Band 2），<strong>无额外延迟</strong>。<li><strong>目标流量</strong>：带有标记 <code>123</code>，被过滤器捕获，强制送入 Band 3 (<code>1:4</code>)，经过 <code>netem</code> 增加延迟，<strong>实现慢速传输</strong>。</ul></ol><hr><h2 id=qian-zai-feng-xian-yu-fu-zuo-yong>潜在风险与副作用</h2><p>这是一个经常被忽视但至关重要的问题：<strong>这组命令会影响其他未被标记的流量吗？</strong><p><strong>答案是肯定的。</strong><p>当你执行 <code>tc qdisc add dev eth0 root ...</code> 时，你<strong>替换了</strong>网卡默认的队列调度器（通常是 <code>fq_codel</code> 或 <code>pfifo_fast</code>）。<ul><li><strong>默认调度器 (<code>fq_codel</code>)</strong>：非常智能，能保证不同连接间的公平性，有效抑制缓冲区膨胀。<li><strong>当前调度器 (<code>prio</code>)</strong>：简单的优先级调度。</ul><p><strong>后果</strong>： 未被标记的普通流量虽然不会经过延迟队列，但它们现在由 <code>prio</code> 调度器管理。这意味着它们失去了 <code>fq_codel</code> 提供的公平性保障。在高负载下，某些流量可能会“饿死”其他流量，或者整体网络抖动变大。<p><strong>结论</strong>：此方案非常适合<strong>测试环境</strong>或<strong>故障模拟</strong>，但在生产环境长期运行时需谨慎评估对整体网络模型的影响。<hr><h2 id=jin-jie-tan-tao-guan-yu-bands-shu-liang-de-xuan-ze>进阶探讨：关于 Bands 数量的选择</h2><p><strong>疑问</strong>：如果我们将 <code>bands 4</code> 改为 <code>bands 64</code>，是否能获得更精细的控制？<p><strong>回答</strong>：技术上可行，但通常<strong>没有必要</strong>，甚至会增加维护成本。<p>简单来说，<strong>你会成功创建一个拥有 64 个优先级队列的调度器，但默认情况下，其中绝大多数队列将是空的，不会被系统自动使用。</strong><h3 id=1-ji-shu-yuan-li>1. 技术原理</h3><p><code>prio</code> 调度器根据数据包的优先级将其分类到不同的 band 中。默认情况下，这个“优先级”来自于 IP 头中的 <strong><code>TOS</code> (Type of Service) 字段</strong>。<p>Linux 内核内置的 <code>priomap</code> 映射表非常简单，它只有效地使用了少数几个 band（通常是 Band 0, 1, 2）。<h3 id=2-shi-ji-xing-wei>2. 实际行为</h3><table><thead><tr><th style=text-align:left>TOS 值 (含义)<th style=text-align:left>对应的 Band (索引)<tbody><tr><td style=text-align:left><code>0x10</code> (最小延迟, SSH)<td style=text-align:left>1<tr><td style=text-align:left><code>0x08</code> (最大吞吐, FTP)<td style=text-align:left>2<tr><td style=text-align:left><strong><code>0x00</code> (普通服务, HTTP)</strong><td style=text-align:left><strong>2</strong></table><p><strong>结论</strong>：<ul><li><strong>绝大多数普通流量</strong>（TOS 为 0）都会自动进入 <strong>Band 2</strong>。<li>如果你创建了 64 个 band，<strong>Band 3 到 Band 63 将会是完全空的</strong>，除非你手动为每一个 band 添加过滤器规则。</ul><h3 id=3-wei-shen-me-bu-tui-jian-bands-64>3. 为什么不推荐 Bands 64？</h3><ol><li><strong>资源浪费</strong>：创建大量未使用的队列。<li><strong>配置复杂</strong>：要想利用这些队列，你需要维护海量的 <code>tc filter</code> 规则。<li><strong>替代方案</strong>：在需要复杂 QoS 的场景下（如 ISP 或数据中心），通常会使用更高级的 <strong><code>HTB</code> (Hierarchical Token Bucket)</strong> 调度器，而不是简单的 <code>prio</code>。</ol><p>对于本文的目标——<strong>隔离特定流量</strong>——使用默认的 <code>bands 3</code> 或 <code>bands 4</code> 已经绰绰有余：<ul><li><strong>Band 0-2</strong>: 处理系统默认流量。<li><strong>Band 3</strong>: 专用作延迟队列。</ul><h2 id=qing-li-yu-huan-yuan>清理与还原</h2><p>测试完成后，务必清理规则，恢复网络原状。<pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 1. 清理 tc 规则 (删除 root qdisc 会自动清除所有子 qdisc 和 filter)
tc qdisc del dev eth0 root

# 2. 清理 iptables 规则 (确保与添加时的参数一致，将 -A 换成 -D)
# 例如：
iptables -t mangle -D OUTPUT -p tcp --dport 80 -j MARK --set-mark 123
</code></pre></div></div></section>