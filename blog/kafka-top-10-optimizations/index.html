<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Kafka 调优十招：原理、实践与取舍 | Roc's Blog</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2025-10-23</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Kafka 调优十招：原理、实践与取舍</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h2 id=zhai-yao>摘要</h2><p>本文系统梳理提升 Kafka 吞吐与稳定性的十项关键调优，并结合生产经验给出参数示例、取舍建议与监控要点。内容涵盖主题分区、复制滞后、代理线程、生产者压缩、确认策略、消费者抓取、网络缓冲、KRaft 元数据超时、磁盘日志目录与复制因子。读完你可建立一套具备技术深度与工程可执行性的 Kafka 调优方法论。<h2 id=jia-gou-zong-lan-tu-jie>架构总览（图解）</h2><pre style=color:#f8f8f2;background-color:#272822><code><span>Producer → RecordAccumulator/Batch → Socket Send → NIC TX → Network
</span><span>                                               ↓
</span><span>Broker Socket Receive → Broker Threads → Page Cache → Log Segments (log.dirs)
</span><span>                                               ↓
</span><span>Consumer Fetch → Socket Receive → Application
</span></code></pre><p>关键瓶颈通常出现在：分区并行度不足、复制滞后、网络/磁盘 IO 饱和、抓取批次过小或等待过长。<hr><h2 id=1-zeng-jia-fen-qu-shu-liang-ti-gao-bing-xing-du>1) 增加分区数量（提高并行度）</h2><ul><li>原理：分区是并行与扩展的基本单位，消费者组的并发度≈分区数。<li>实践：热点主题优先扩分区，但避免超过消费者实例数太多导致上下文切换增多。<li>命令示例：</ul><pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#272822><code class=language-bash data-lang=bash><span style=color:#75715e># 增加主题分区数（注意不可减少）
</span><span>kafka-topics.sh</span><span style=color:#fd971f;font-style:italic> --bootstrap-server </span><span style=color:#f92672><</span><span>broker:9092</span><span style=color:#f92672>> </span><span>\
</span><span style=color:#fd971f;font-style:italic>  --alter --topic</span><span> orders</span><span style=color:#fd971f;font-style:italic> --partitions</span><span> 64
</span></code></pre><ul><li>经验：批次大、压缩好时分区更易发挥并行优势；观察 <code>record-send-rate</code> 与端到端延迟平衡扩分区节奏。</ul><h2 id=2-kong-zhi-fu-zhi-zhi-hou-replica-lag-time-max-ms>2) 控制复制滞后 replica.lag.time.max.ms</h2><ul><li>原理：跟随者滞后超过阈值会被踢出 ISR，影响持久性与写入确认路径。<li>配置：</ul><pre class=language-properties data-lang=properties style=color:#f8f8f2;background-color:#272822><code class=language-properties data-lang=properties><span style=color:#75715e># broker/server.properties
</span><span>replica.lag.time.max.ms=</span><span style=color:#e6db74>5000  # 示例：5s，需结合网络/磁盘能力与延迟容忍度
</span></code></pre><ul><li>取舍：滞后阈值太短易频繁出入 ISR，太长则风险积累；结合 <code>min.insync.replicas</code> 与 <code>acks</code> 联动。</ul><h2 id=3-diao-zheng-dai-li-xian-cheng-num-network-threads-num-io-threads>3) 调整代理线程 num.network.threads / num.io.threads</h2><ul><li>原理：网络线程负责连接与请求，IO 线程处理磁盘与日志操作。<li>配置：</ul><pre class=language-properties data-lang=properties style=color:#f8f8f2;background-color:#272822><code class=language-properties data-lang=properties><span style=color:#75715e># broker/server.properties
</span><span>num.network.threads=</span><span style=color:#e6db74>8
</span><span>num.io.threads=</span><span style=color:#e6db74>16
</span><span>num.replica.fetchers=</span><span style=color:#e6db74>4
</span></code></pre><ul><li>经验：磁盘为 SSD 且网络连接多时适当加大 IO/网络线程；监控线程池队列长度与请求处理时间。</ul><h2 id=4-sheng-chan-zhe-ya-suo-compression-type>4) 生产者压缩 compression.type</h2><ul><li>原理：减小网络传输与磁盘写入体积，提高吞吐；常用 lz4 兼顾速度与压缩率。</ul><pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span style=color:#75715e>// Producer 配置示例（Java）
</span><span style=color:#66d9ef;font-style:italic>Properties</span><span> props </span><span style=color:#f92672>= new </span><span style=color:#66d9ef;font-style:italic>Properties</span><span>();
</span><span>props.put(</span><span style=color:#e6db74>"bootstrap.servers"</span><span>, </span><span style=color:#e6db74>"broker1:9092,broker2:9092"</span><span>);
</span><span>props.put(</span><span style=color:#e6db74>"compression.type"</span><span>, </span><span style=color:#e6db74>"lz4"</span><span>);
</span><span>props.put(</span><span style=color:#e6db74>"batch.size"</span><span>, </span><span style=color:#ae81ff>65536</span><span>);       </span><span style=color:#75715e>// 64KB 批次
</span><span>props.put(</span><span style=color:#e6db74>"linger.ms"</span><span>, </span><span style=color:#ae81ff>10</span><span>);            </span><span style=color:#75715e>// 等待聚合
</span><span>props.put(</span><span style=color:#e6db74>"buffer.memory"</span><span>, </span><span style=color:#ae81ff>67108864</span><span>);  </span><span style=color:#75715e>// 64MB
</span></code></pre><ul><li>经验：压缩在高吞吐场景收益明显；CPU 紧张或消息极小（<几百字节）时可降低 batch 或取消压缩。</ul><h2 id=5-she-zhi-gua-dang-de-sheng-chan-zhe-que-ren-acks>5) 设置适当的生产者确认 acks</h2><ul><li>原理：<code>acks=1</code> 追求速度，<code>acks=all</code> 追求持久性。</ul><pre class=language-java data-lang=java style=color:#f8f8f2;background-color:#272822><code class=language-java data-lang=java><span>props.put(</span><span style=color:#e6db74>"acks"</span><span>, </span><span style=color:#e6db74>"all"</span><span>);             </span><span style=color:#75715e>// 强持久性，需配合 min.insync.replicas
</span><span style=color:#75715e>// 低延迟场景可用：props.put("acks", "1");
</span></code></pre><ul><li>经验：关键交易流选择 <code>acks=all + min.insync.replicas>=2</code>；日志/监控流可选 <code>acks=1</code> 提升吞吐。</ul><h2 id=6-xiao-fei-zhe-fetch-diao-you>6) 消费者 Fetch 调优</h2><ul><li>原理：每次抓取的最小字节与最大等待影响吞吐与延迟。</ul><pre class=language-properties data-lang=properties style=color:#f8f8f2;background-color:#272822><code class=language-properties data-lang=properties><span style=color:#75715e># consumer
</span><span>fetch.min.bytes=</span><span style=color:#e6db74>1048576      # 1MB，增大以减少请求开销
</span><span>fetch.max.wait.ms=</span><span style=color:#e6db74>50         # 最长等待以凑满批次
</span><span>max.partition.fetch.bytes=</span><span style=color:#e6db74>8388608  # 每分区最大抓取
</span></code></pre><ul><li>经验：延迟敏感业务降低 <code>fetch.max.wait.ms</code>；吞吐优先业务增大 <code>fetch.min.bytes</code> 与 <code>max.partition.fetch.bytes</code>。</ul><h2 id=7-socket-huan-chong-wang-luo-ceng-guan-jian>7) Socket 缓冲（网络层关键）</h2><ul><li>原理：发送/接收缓冲影响突发流量可承载能力。</ul><pre class=language-properties data-lang=properties style=color:#f8f8f2;background-color:#272822><code class=language-properties data-lang=properties><span style=color:#75715e># broker/server.properties
</span><span>socket.send.buffer.bytes=</span><span style=color:#e6db74>262144
</span><span>socket.receive.buffer.bytes=</span><span style=color:#e6db74>262144
</span></code></pre><pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#272822><code class=language-bash data-lang=bash><span style=color:#75715e># OS 层（Linux）建议上限
</span><span style=color:#66d9ef>echo </span><span style=color:#e6db74>'net.core.wmem_max = 134217728' </span><span style=color:#f92672>| </span><span>sudo tee</span><span style=color:#fd971f;font-style:italic> -a</span><span> /etc/sysctl.conf
</span><span style=color:#66d9ef>echo </span><span style=color:#e6db74>'net.core.rmem_max = 134217728' </span><span style=color:#f92672>| </span><span>sudo tee</span><span style=color:#fd971f;font-style:italic> -a</span><span> /etc/sysctl.conf
</span><span>sudo sysctl</span><span style=color:#fd971f;font-style:italic> -p
</span></code></pre><ul><li>经验：结合 NIC 驱动与 MTU 调优；观察丢包/重传与队列长度，避免过度放大导致内存占用攀升。</ul><h2 id=8-kraft-yuan-shu-ju-chao-shi>8) KRaft 元数据超时</h2><ul><li>原理：KRaft 替代 ZooKeeper，选举与元数据请求的超时影响控制面稳定性。</ul><pre class=language-properties data-lang=properties style=color:#f8f8f2;background-color:#272822><code class=language-properties data-lang=properties><span style=color:#75715e># broker/server.properties（KRaft 模式，具体参数名随版本差异）
</span><span>controller.quorum.election.timeout.ms=</span><span style=color:#e6db74>5000
</span><span>controller.quorum.request.timeout.ms=</span><span style=color:#e6db74>30000
</span></code></pre><ul><li>经验：在网络抖动或控制器负载高时适当放宽；务必结合当前 Kafka 版本文档验证参数名与默认值。</ul><h2 id=9-duo-mu-lu-log-dirs-you-hua-ci-pan-io>9) 多目录 log.dirs 优化磁盘 IO</h2><ul><li>原理：多物理盘分散日志写入与读取，降低单盘瓶颈。</ul><pre class=language-properties data-lang=properties style=color:#f8f8f2;background-color:#272822><code class=language-properties data-lang=properties><span>log.dirs=</span><span style=color:#e6db74>/data/kafka-logs1,/data/kafka-logs2,/data/kafka-logs3
</span></code></pre><ul><li>经验：保持盘间均衡与独立挂载；注意文件系统选型与磁盘调度器（SSD 建议 <code>none</code>/<code>mq-deadline</code>）。</ul><h2 id=10-fu-zhi-yin-zi-replication-factor-yu-zui-xiao-isr>10) 复制因子 Replication Factor 与最小 ISR</h2><ul><li>原理：复制因子提升容灾能力；<code>min.insync.replicas</code> 决定可写安全阈值。</ul><pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#272822><code class=language-bash data-lang=bash><span style=color:#75715e># 创建主题时指定复制因子
</span><span>kafka-topics.sh</span><span style=color:#fd971f;font-style:italic> --bootstrap-server </span><span style=color:#f92672><</span><span>broker:9092</span><span style=color:#f92672>> </span><span>\
</span><span style=color:#fd971f;font-style:italic>  --create --topic</span><span> payments</span><span style=color:#fd971f;font-style:italic> --partitions</span><span> 32</span><span style=color:#fd971f;font-style:italic> --replication-factor</span><span> 3
</span></code></pre><pre class=language-properties data-lang=properties style=color:#f8f8f2;background-color:#272822><code class=language-properties data-lang=properties><span style=color:#75715e># 强一致要求
</span><span>min.insync.replicas=</span><span style=color:#e6db74>2
</span></code></pre><ul><li>经验：一般生产建议 RF=3；跨机架部署配合机架感知，保障副本分布合理。</ul><hr><h2 id=jian-kong-yu-yan-zheng-qing-dan>监控与验证清单</h2><ul><li>关键指标：<code>request-rate/queue</code>、<code>records-per-request</code>、<code>bytes-in/out</code>、<code>replica-lag</code>、<code>fetch-latency</code>、磁盘/网络利用率。<li>端到端：生产-代理-消费延迟分解，定位瓶颈链路。<li>回归测试：基准压测覆盖消息大小分布、峰值/平均 QPS、网络/磁盘抖动。<li>变更策略：逐项调参、灰度发布、可回滚，记录版本与参数快照。</ul><h2 id=ge-ren-shi-jian-jing-yan-qu-she-yuan-ze>个人实践经验（取舍原则）</h2><ul><li>先“结构性并行”（分区数）再“局部高效”（批次与压缩）；避免只堆参数不改架构。<li>写入安全三件套：<code>acks=all + min.insync.replicas>=2 + RF>=3</code>；有压测支撑再降级到 <code>acks=1</code>。<li>抓取参数面向业务目标：低延迟用小批次、吞吐优先用大批次+等待。<li>网络与磁盘是基础设施瓶颈，Kafka 参数只是“放大器”，必须与 OS/NIC/盘配置协同优化。</ul><h2 id=can-kao-zi-liao>参考资料</h2><ul><li>Kafka 调优十招：https://mp.weixin.qq.com/s/RyPrlIps1tWUWgQcIyiEvw</ul></div></div></section>