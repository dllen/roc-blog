<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>分布式锁实践与对比：Redis、ZooKeeper、etcd、数据库 | Roc's Blog</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2025-10-19</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">分布式锁实践与对比：Redis、ZooKeeper、etcd、数据库</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h2 id=bei-jing-yu-mu-biao>背景与目标</h2><p>分布式锁用于在多节点间对共享资源的互斥访问进行协调。正确的分布式锁不仅要“拿到锁”，更要保证在网络分区、节点崩溃、时钟漂移等故障下行为可预期。《数据密集型应用》提出关键原则：<ul><li>使用线性一致（linearizable）的存储实现锁，或在架构中引入防护策略（如 fencing token）。<li>锁只是建议（advisory），业务层仍需幂等与回滚保障。<li>赋予锁“租约”（lease/TTL）并持续续约；结合会话（session）与心跳释放过期锁。<li>引入 <strong>fencing token</strong>（单调递增版本号）防止旧持有者在失效后仍然操作资源。</ul><h2 id=ping-gu-wei-du>评估维度</h2><ul><li>正确性与一致性：是否线性一致、是否能防止“双主/脑裂”。<li>可用性与容灾：跨机房、网络抖动、故障恢复能力。<li>公平性：是否支持排队、公平获取（FIFO）。<li>性能与成本：吞吐、延迟、存储/运维代价。<li>易用性：API成熟度、客户端生态、部署复杂度。</ul><h2 id=redis-fen-bu-shi-suo>Redis 分布式锁</h2><ul><li>基本模式：<code>SET key value NX PX ttl</code> 获取，释放用 Lua 保证原子性：</ul><pre class=language-lua data-lang=lua style=color:#f8f8f2;background-color:#272822><code class=language-lua data-lang=lua><span style=color:#75715e>-- 仅当持有者匹配时删除
</span><span style=color:#f92672>if </span><span>redis.call(</span><span style=color:#e6db74>'get'</span><span>, KEYS[</span><span style=color:#ae81ff>1</span><span>]) </span><span style=color:#f92672>== </span><span>ARGV[</span><span style=color:#ae81ff>1</span><span>] </span><span style=color:#f92672>then
</span><span>  </span><span style=color:#f92672>return </span><span>redis.call(</span><span style=color:#e6db74>'del'</span><span>, KEYS[</span><span style=color:#ae81ff>1</span><span>])
</span><span style=color:#f92672>else
</span><span>  </span><span style=color:#f92672>return </span><span style=color:#ae81ff>0
</span><span style=color:#f92672>end
</span></code></pre><ul><li>续约：定期延长 TTL，避免长 GC/Stop-The-World导致过期；需守护线程。<li>Redlock：通过多主实例多数派获取锁，但在强严格一致性语义上存在争议；不建议用于需要线性一致的关键场景。<li>适用场景：同机房内的“去重/防重复任务启动”、非关键资源短持锁；配合幂等和回滚机制。<li>风险与缓解： <ul><li>网络分区与主从切换可能导致锁可见性不一致；避免跨机房关键路径。<li>TTL不是严格终止条件，过期后旧持有者仍可能继续操作；加 <strong>fencing token</strong> 在资源侧校验。</ul></ul><h2 id=zookeeper-fen-bu-shi-suo>ZooKeeper 分布式锁</h2><ul><li>核心机制：临时节点（ephemeral）+ 顺序节点（sequential）。创建 <code>/${lock}/lock-</code> 顺序临时节点；序号最小者获锁，其余监听前驱节点删除后再竞争。<li>特性：强一致（基于 Zab），具备公平性（排队），会话失效自动释放。<li>客户端：推荐使用 Curator Recipes（<code>InterProcessMutex</code> 等），处理好 Watch 一次性触发与重入。<li>适用场景：需要强一致与公平的分布式协调（调度器、主选举、全局限流）。<li>风险与缓解： <ul><li>群聚效应（herd effect）：尽量只监听前驱而非根目录，避免大量节点同时唤醒。<li>会话过期与网络抖动：务必实现重连与锁重获逻辑。</ul></ul><h2 id=etcd-fen-bu-shi-suo>etcd 分布式锁</h2><ul><li>推荐模式：<code>lease</code> + <code>Txn(CAS)</code>。</ul><pre class=language-go data-lang=go style=color:#f8f8f2;background-color:#272822><code class=language-go data-lang=go><span style=color:#75715e>// 伪代码：创建带租约的锁键
</span><span>lease </span><span style=color:#f92672>:= </span><span>Grant(ttl)
</span><span>keepalive(lease)
</span><span>resp </span><span style=color:#f92672>:= </span><span>Txn().If(key_not_exists).Then(Put(key, owner, WithLease(lease))).Commit()
</span><span style=color:#f92672>if </span><span>resp.Succeeded { </span><span style=color:#75715e>/* got lock; use resp.Header.Revision 作为 fencing token */ </span><span>}
</span></code></pre><ul><li>特性：线性一致（Raft），原生支持 <code>lock</code> API 与租约续约；可用 <code>revision</code>/<code>mod_revision</code> 作为 <strong>fencing token</strong>。<li>适用场景：对一致性要求高的核心路径（支付、订单、分布式调度）。<li>风险与缓解： <ul><li>网络分区与领导者选举：设计重试与指数退避，降级为读一致或只读模式。<li>续约失败处理：监控 keepalive 延迟与失败率，及时释放与重获。</ul></ul><h2 id=shu-ju-ku-fen-bu-shi-suo>数据库分布式锁</h2><ul><li>模式一：行级锁/状态行 + 唯一约束 + CAS：</ul><pre class=language-sql data-lang=sql style=color:#f8f8f2;background-color:#272822><code class=language-sql data-lang=sql><span style=color:#75715e>-- 获取锁
</span><span style=color:#f92672>UPDATE</span><span> locks </span><span style=color:#f92672>SET</span><span> owner </span><span style=color:#f92672>=</span><span> :who, version </span><span style=color:#f92672>=</span><span> version </span><span style=color:#f92672>+ </span><span style=color:#ae81ff>1
</span><span style=color:#f92672>WHERE</span><span> name </span><span style=color:#f92672>=</span><span> :resource </span><span style=color:#f92672>AND</span><span> (owner </span><span style=color:#f92672>IS </span><span style=color:#ae81ff>NULL </span><span style=color:#f92672>OR</span><span> expired_at </span><span style=color:#f92672><</span><span> NOW());
</span><span style=color:#75715e>-- 判断影响行数以确定是否拿到锁；version 作为 fencing token
</span></code></pre><ul><li>模式二：PostgreSQL Advisory Lock：<code>SELECT pg_try_advisory_lock(hashtext(:resource));</code><li>模式三：MySQL <code>GET_LOCK('res', timeout)</code> 与 <code>RELEASE_LOCK('res')</code>（注意复制一致性与可靠性）。<li>特性：易用、无需新组件；但公平性与 TTL 支持有限，跨机房一致性取决于复制架构。<li>适用场景：单库/同机房、任务编排/批处理；或过渡方案。<li>风险与缓解： <ul><li>会话崩溃释放语义不一致（不同数据库实现差异）；建议显式心跳与过期字段。<li>复制延迟（主从）可能导致锁可见性问题；关键路径谨慎使用。</ul></ul><h2 id=guan-jian-shi-jian-fencing-token>关键实践：Fencing Token</h2><ul><li>原理：每次成功获取锁生成单调递增的令牌（版本号）。资源侧仅接受令牌更大的写入，防止“旧持有者”在锁过期/网络分区后继续写。<li>示例：将 <code>version</code>/<code>revision</code>随写入一起校验；存储系统需具备原子比较能力（CAS/upsert）。</ul><h2 id=chang-jing-zui-jia-fang-an>场景最佳方案</h2><ul><li>强一致、关键业务（支付/订单/配置变更）：优先 etcd/ZooKeeper + 租约续约 + fencing token。<li>公平排队（调度/限流/分布式队列）：ZooKeeper 顺序节点或 etcd 的队列/锁实现。<li>低一致性需求、短持锁（去重、定时任务防并发）：Redis <code>SET NX PX</code> + Lua 释放 + 续约守护；在单机房内使用。<li>单库内任务编排/过渡期：数据库行级锁/Advisory Lock，但避免跨机房关键路径。</ul><h2 id=jian-kong-yu-wen-ding-xing>监控与稳定性</h2><ul><li>监控：锁等待时长、失败率、租约续约延迟、会话过期次数、fencing token 单调性、网络分区事件。<li>降级：锁获取超时触发熔断或改为幂等重试；批任务降速；业务侧容错与回滚。</ul><h2 id=chang-jian-keng>常见坑</h2><ul><li>仅依赖 TTL 作为安全阀门；旧持有者仍可能继续写 => 用 fencing token。<li>忽视幂等与回滚；锁不是万能防线。<li>未处理客户端重连与会话过期；需自动重试与锁重获。<li>ZK 监听根目录导致群聚效应；只监听前驱节点。<li>Redis 跨机房使用 Redlock 期望强一致；不现实。</ul><h2 id=shi-li-su-lan>示例速览</h2><ul><li>Redis 获取与释放（Lua）：见上文；确保 <code>value</code> 是唯一持有者标识并在释放时核验。<li>etcd 事务：<code>If(key missing) Then Put(key, lease)</code>；用 <code>revision</code> 作为 fencing。<li>PostgreSQL Advisory Lock：<code>pg_try_advisory_lock</code> + 会话结束自动释放；非线性一致全局锁。</ul><h2 id=can-kao-zi-liao>参考资料</h2><ul><li>《数据密集型应用》：一致性、锁、Fencing Token 与分布式系统实践。<li>官方文档： <ul><li>Redis SET NX/PX 与 Lua 原子释放<li>ZooKeeper Recipes（Curator）<li>etcd <code>lease</code>/<code>lock</code>/<code>txn</code><li>PostgreSQL Advisory Lock / MySQL GET_LOCK</ul></ul></div></div></section>