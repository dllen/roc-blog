<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Kafka & Nic Buffer | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2025-08-19</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">Kafka & Nic Buffer</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><p>NIC buffer（网卡缓冲区）是网络接口卡（Network Interface Card）中用于临时存储数据的内存区域。<h2 id=nic-buffer-de-zuo-yong>NIC Buffer 的作用</h2><h3 id=1-shu-ju-huan-cun>1. <strong>数据缓存</strong></h3><ul><li>临时存储接收到的网络数据包<li>缓存等待发送的数据包<li>平衡网络传输速度和系统处理速度的差异</ul><h3 id=2-xing-neng-you-hua>2. <strong>性能优化</strong></h3><ul><li>减少CPU中断频率<li>提高数据传输效率<li>降低数据丢失的风险</ul><h2 id=buffer-lei-xing>Buffer 类型</h2><h3 id=jie-shou-huan-chong-qu-rx-buffer>接收缓冲区（RX Buffer）</h3><pre><code>网络 → NIC → RX Buffer → 系统内存 → 应用程序
</code></pre><h3 id=fa-song-huan-chong-qu-tx-buffer>发送缓冲区（TX Buffer）</h3><pre><code>应用程序 → 系统内存 → TX Buffer → NIC → 网络
</code></pre><h2 id=gong-zuo-yuan-li>工作原理</h2><h3 id=1-shu-ju-jie-shou-liu-cheng>1. <strong>数据接收流程</strong></h3><ul><li>网卡接收网络数据包<li>数据暂存在RX Buffer中<li>通过DMA传输到系统内存<li>通知CPU处理数据</ul><h3 id=2-shu-ju-fa-song-liu-cheng>2. <strong>数据发送流程</strong></h3><ul><li>CPU将数据写入TX Buffer<li>网卡从缓冲区读取数据<li>按照网络协议发送数据</ul><h2 id=chang-jian-wen-ti-he-you-hua>常见问题和优化</h2><h3 id=bufferyi-chu>Buffer溢出</h3><ul><li><strong>原因</strong>：数据到达速度超过处理速度<li><strong>后果</strong>：数据包丢失<li><strong>解决</strong>：增大缓冲区大小、优化网络驱动</ul><h3 id=xing-neng-diao-you>性能调优</h3><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 查看网卡缓冲区设置
ethtool -g eth0

# 调整缓冲区大小
ethtool -G eth0 rx 1024 tx 1024
</code></pre><p>NIC Buffer是网络通信中的重要组件，合理配置可以显著提升网络性能。<hr><h2 id=kafka-xie-ru-shu-ju-de-huan-cun-jiao-hu-liu-cheng>Kafka 写入数据的缓存交互流程</h2><h3 id=1-producer-duan-huan-cun>1. <strong>Producer 端缓存</strong></h3><pre class=language-java data-lang=java><code class=language-java data-lang=java>// Producer 配置示例
Properties props = new Properties();
props.put("buffer.memory", 33554432);        // 32MB 缓冲区
props.put("batch.size", 16384);              // 16KB 批次大小
props.put("linger.ms", 5);                   // 等待时间
props.put("compression.type", "snappy");     // 压缩类型
</code></pre><p><strong>Producer 缓存层级：</strong><ul><li><strong>Record Accumulator</strong>：消息聚合缓冲区<li><strong>Batch Buffer</strong>：按 partition 分组的批次缓存<li><strong>Network Send Buffer</strong>：网络发送缓冲区</ul><h3 id=2-wan-zheng-de-xie-ru-liu-cheng>2. <strong>完整的写入流程</strong></h3><pre><code>Producer App → Record Accumulator → Batch Buffer → Network Buffer 
     ↓
Socket Send Buffer → NIC TX Buffer → 网络传输
     ↓
NIC RX Buffer → Socket Receive Buffer → Kafka Broker
     ↓
Broker Memory → Page Cache → Disk
</code></pre><h2 id=ge-ceng-huan-cun-xiang-xi-shuo-ming>各层缓存详细说明</h2><h3 id=producer-duan-huan-cun>Producer 端缓存</h3><h4 id=record-accumulator>Record Accumulator</h4><pre class=language-java data-lang=java><code class=language-java data-lang=java>// 内部工作原理
public class RecordAccumulator {
    private final ConcurrentMap&LTTopicPartition, Deque&LTProducerBatch>> batches;
    private final BufferPool free; // 内存池管理

    // 消息添加到缓冲区
    public RecordAppendResult append(TopicPartition tp, byte[] key, byte[] value) {
        // 1. 获取或创建 partition 对应的 batch
        // 2. 尝试添加到现有 batch
        // 3. 如果 batch 满了，创建新的 batch
    }
}
</code></pre><h4 id=guan-jian-pei-zhi-can-shu>关键配置参数</h4><ul><li><strong>buffer.memory</strong>: 总缓冲区大小（默认32MB）<li><strong>batch.size</strong>: 单个批次大小（默认16KB）<li><strong>linger.ms</strong>: 批次等待时间（默认0ms）</ul><h3 id=wang-luo-ceng-huan-cun>网络层缓存</h3><h4 id=socket-huan-cun>Socket 缓存</h4><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 查看和调整 socket 缓冲区
cat /proc/sys/net/core/wmem_default  # 发送缓冲区默认大小
cat /proc/sys/net/core/rmem_default  # 接收缓冲区默认大小

# 调整缓冲区大小
echo 262144 > /proc/sys/net/core/wmem_default
echo 262144 > /proc/sys/net/core/rmem_default
</code></pre><h3 id=broker-duan-huan-cun>Broker 端缓存</h3><h4 id=page-cache-ye-huan-cun>Page Cache（页缓存）</h4><pre class=language-java data-lang=java><code class=language-java data-lang=java>// Kafka 利用操作系统页缓存
public class Log {
    // 写入消息到日志文件
    public void append(MemoryRecords records) {
        // 1. 数据首先写入 Page Cache
        // 2. 操作系统负责刷盘（fsync）
        segment.append(records);
    }
}
</code></pre><h2 id=xing-neng-you-hua-ce-lue>性能优化策略</h2><h3 id=1-producer-duan-you-hua>1. <strong>Producer 端优化</strong></h3><pre class=language-java data-lang=java><code class=language-java data-lang=java>// 高吞吐量配置
props.put("buffer.memory", 67108864);        // 64MB
props.put("batch.size", 65536);              // 64KB
props.put("linger.ms", 10);                  // 10ms 等待
props.put("compression.type", "lz4");        // 高效压缩

// 低延迟配置
props.put("buffer.memory", 33554432);        // 32MB
props.put("batch.size", 1024);               // 1KB
props.put("linger.ms", 0);                   // 立即发送
props.put("acks", "1");                      // 减少确认等待
</code></pre><h3 id=2-xi-tong-ji-you-hua>2. <strong>系统级优化</strong></h3><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 网络缓冲区优化
echo 'net.core.wmem_max = 134217728' >> /etc/sysctl.conf
echo 'net.core.rmem_max = 134217728' >> /etc/sysctl.conf

# 磁盘调度优化
echo deadline > /sys/block/sda/queue/scheduler

# 文件系统优化（减少刷盘频率）
mount -o noatime,commit=30 /dev/sda1 /kafka-logs
</code></pre><h3 id=3-broker-duan-you-hua>3. <strong>Broker 端优化</strong></h3><pre class=language-properties data-lang=properties><code class=language-properties data-lang=properties># server.properties 配置
socket.send.buffer.bytes=102400          # Socket 发送缓冲区
socket.receive.buffer.bytes=102400       # Socket 接收缓冲区
log.flush.interval.messages=10000        # 刷盘消息数量
log.flush.interval.ms=3000               # 刷盘时间间隔
</code></pre><h2 id=jian-kong-he-diao-you>监控和调优</h2><h3 id=guan-jian-zhi-biao-jian-kong>关键指标监控</h3><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># Producer 指标
kafka-console-consumer --bootstrap-server localhost:9092 \
  --topic __consumer_offsets --formatter kafka.tools.ConsumerOffsetsChecker

# 查看网络统计
netstat -i
ss -tuln

# 查看页缓存使用情况
free -h
cat /proc/meminfo | grep -i cache
</code></pre><h3 id=chang-jian-xing-neng-wen-ti>常见性能问题</h3><ol><li><p><strong>缓冲区溢出</strong></p> <ul><li>现象：producer 阻塞或抛出异常<li>解决：增大 <code>buffer.memory</code></ul><li><p><strong>批次过小</strong></p> <ul><li>现象：吞吐量低，网络开销大<li>解决：增大 <code>batch.size</code> 和 <code>linger.ms</code></ul><li><p><strong>页缓存不足</strong></p> <ul><li>现象：频繁磁盘IO<li>解决：增加系统内存，调整JVM堆大小</ul></ol><p>通过合理配置这些缓存层级，可以显著提升 Kafka 的写入性能和整体吞吐量。<hr><h2 id=kafka-du-qu-shu-ju-de-huan-cun-jiao-hu-liu-cheng>Kafka 读取数据的缓存交互流程</h2><h3 id=1-wan-zheng-de-du-qu-liu-cheng>1. <strong>完整的读取流程</strong></h3><pre><code>Consumer App ← Fetch Buffer ← Socket Receive Buffer ← NIC RX Buffer
     ↑
Network ← NIC TX Buffer ← Socket Send Buffer ← Kafka Broker
     ↑
Page Cache ← Disk (如果 Page Cache miss)
</code></pre><h3 id=2-consumer-duan-huan-cun-ceng-ji>2. <strong>Consumer 端缓存层级</strong></h3><pre class=language-java data-lang=java><code class=language-java data-lang=java>// Consumer 配置示例
Properties props = new Properties();
props.put("fetch.min.bytes", 1024);           // 最小拉取字节数
props.put("fetch.max.wait.ms", 500);          // 最大等待时间
props.put("max.partition.fetch.bytes", 1048576); // 单分区最大拉取
props.put("receive.buffer.bytes", 65536);     // Socket 接收缓冲区
</code></pre><h2 id=xiang-xi-de-huan-cun-jiao-hu-guo-cheng>详细的缓存交互过程</h2><h3 id=1-consumer-fa-qi-du-qu-qing-qiu>1. <strong>Consumer 发起读取请求</strong></h3><pre class=language-java data-lang=java><code class=language-java data-lang=java>public class KafkaConsumer&LTK, V> {
    private final Fetcher&LTK, V> fetcher;

    public ConsumerRecords&LTK, V> poll(Duration timeout) {
        // 1. 检查本地缓存是否有数据
        if (fetcher.hasCompletedFetches()) {
            return fetcher.fetchedRecords();
        }

        // 2. 发送 fetch 请求到 broker
        fetcher.sendFetches();

        // 3. 等待响应并缓存数据
        return fetcher.fetchedRecords();
    }
}
</code></pre><h3 id=2-broker-duan-chu-li-du-qu-qing-qiu>2. <strong>Broker 端处理读取请求</strong></h3><h4 id=page-cache-ming-zhong-qing-kuang-zui-you-lu-jing>Page Cache 命中情况（最优路径）</h4><pre class=language-scala data-lang=scala><code class=language-scala data-lang=scala>// Kafka Broker 处理 fetch 请求
class KafkaRequestHandler {
  def handleFetchRequest(request: FetchRequest) = {
    // 1. 从 Page Cache 读取数据（零拷贝）
    val records = log.read(startOffset, maxBytes)

    // 2. 直接通过 sendfile() 发送到 socket
    channel.transferTo(socketChannel, records)
  }
}
</code></pre><h4 id=page-cache-miss-qing-kuang>Page Cache Miss 情况</h4><pre><code>1. Broker 收到 fetch 请求
2. 检查 Page Cache 中是否有数据
3. 如果 miss，从磁盘读取到 Page Cache
4. 通过零拷贝技术发送给 Consumer
</code></pre><h3 id=3-ling-kao-bei-you-hua-zero-copy>3. <strong>零拷贝优化（Zero-Copy）</strong></h3><pre class=language-java data-lang=java><code class=language-java data-lang=java>// 传统方式（4次拷贝）
// Disk → Kernel Buffer → User Buffer → Socket Buffer → NIC

// Kafka 零拷贝方式（2次拷贝）
// Disk → Page Cache → NIC Buffer
FileChannel fileChannel = new RandomAccessFile(file, "r").getChannel();
fileChannel.transferTo(position, count, socketChannel);
</code></pre><h2 id=ge-ceng-huan-cun-xiang-xi-fen-xi>各层缓存详细分析</h2><h3 id=1-broker-duan-page-cache>1. <strong>Broker 端 Page Cache</strong></h3><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 查看页缓存使用情况
free -h
              total        used        free      shared  buff/cache   available
Mem:           32Gi       8.0Gi       2.0Gi       1.0Gi        22Gi        22Gi

# 查看文件在页缓存中的情况
vmtouch /kafka-logs/topic-0/00000000000000000000.log
</code></pre><h4 id=page-cache-gong-zuo-yuan-li>Page Cache 工作原理</h4><pre class=language-java data-lang=java><code class=language-java data-lang=java>// Linux 页缓存机制
public class PageCache {
    // 1. 读取请求首先检查页缓存
    // 2. 命中：直接返回缓存数据
    // 3. 未命中：从磁盘读取并缓存
    // 4. LRU 算法管理缓存淘汰
}
</code></pre><h3 id=2-consumer-duan-huan-cun>2. <strong>Consumer 端缓存</strong></h3><h4 id=fetch-buffer>Fetch Buffer</h4><pre class=language-java data-lang=java><code class=language-java data-lang=java>public class Fetcher&LTK, V> {
    private final LinkedHashMap&LTTopicPartition, List&LTConsumerRecord&LTK, V>>> records;

    // 预拉取和缓存机制
    private void fetch() {
        // 1. 批量拉取多个分区数据
        // 2. 缓存在本地 buffer 中
        // 3. 应用程序按需消费
        Map&LTTopicPartition, List&LTConsumerRecord&LTK, V>>> fetchedRecords = 
            parseCompletedFetch();
        records.putAll(fetchedRecords);
    }
}
</code></pre><h4 id=yu-du-qu-ce-lue>预读取策略</h4><pre class=language-java data-lang=java><code class=language-java data-lang=java>// Consumer 预读取配置
props.put("fetch.min.bytes", 50000);        // 累积50KB再返回
props.put("fetch.max.wait.ms", 100);        // 最多等待100ms
props.put("max.poll.records", 1000);        // 单次poll最大记录数
</code></pre><h2 id=xing-neng-you-hua-ce-lue-1>性能优化策略</h2><h3 id=1-page-cache-you-hua>1. <strong>Page Cache 优化</strong></h3><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 预热页缓存
vmtouch -t /kafka-logs/*/*.log

# 监控页缓存命中率
sar -B 1 10  # 查看页面换入换出情况

# 调整系统参数
echo 1 > /proc/sys/vm/swappiness          # 减少swap使用
echo 10 > /proc/sys/vm/dirty_ratio        # 控制脏页比例
</code></pre><h3 id=2-consumer-duan-you-hua>2. <strong>Consumer 端优化</strong></h3><pre class=language-java data-lang=java><code class=language-java data-lang=java>// 高吞吐量配置
props.put("fetch.min.bytes", 1048576);       // 1MB
props.put("fetch.max.wait.ms", 100);         // 100ms
props.put("max.partition.fetch.bytes", 10485760); // 10MB
props.put("max.poll.records", 10000);        // 10000条记录

// 低延迟配置
props.put("fetch.min.bytes", 1);             // 1字节
props.put("fetch.max.wait.ms", 10);          // 10ms
props.put("max.partition.fetch.bytes", 1048576); // 1MB
props.put("max.poll.records", 100);          // 100条记录
</code></pre><h3 id=3-wang-luo-ceng-you-hua>3. <strong>网络层优化</strong></h3><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># TCP 接收缓冲区优化
echo 'net.core.rmem_default = 262144' >> /etc/sysctl.conf
echo 'net.core.rmem_max = 16777216' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_rmem = 4096 87380 16777216' >> /etc/sysctl.conf

# 应用配置
sysctl -p
</code></pre><h2 id=jian-kong-he-diao-you-1>监控和调优</h2><h3 id=1-xing-neng-zhi-biao-jian-kong>1. <strong>性能指标监控</strong></h3><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># Broker 端指标
kafka-run-class kafka.tools.JmxTool \
  --jmx-url service:jmx:rmi:///jndi/rmi://localhost:9999/jmxrmi \
  --object-name kafka.network:type=RequestMetrics,name=TotalTimeMs,request=FetchConsumer

# 系统级监控
iostat -x 1        # 磁盘IO统计
iftop              # 网络流量监控
htop               # CPU和内存使用
</code></pre><h3 id=2-consumer-lag-jian-kong>2. <strong>Consumer Lag 监控</strong></h3><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 监控消费延迟
kafka-consumer-groups --bootstrap-server localhost:9092 \
  --group my-group --describe

# 输出示例
TOPIC     PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG
my-topic  0          1000           1500           500
</code></pre><h3 id=3-huan-cun-ming-zhong-lu-fen-xi>3. <strong>缓存命中率分析</strong></h3><pre class=language-java data-lang=java><code class=language-java data-lang=java>// JVM 监控
jstat -gc &LTpid> 1s    # GC 统计
jmap -histo &LTpid>     # 堆内存分析

// 应用级监控
// 通过 JMX 监控 fetch 请求延迟和吞吐量
</code></pre><h2 id=chang-jian-xing-neng-wen-ti-he-jie-jue-fang-an>常见性能问题和解决方案</h2><h3 id=1-page-cache-miss-pin-fan>1. <strong>Page Cache Miss 频繁</strong></h3><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 问题：磁盘IO高，读取延迟大
# 解决：
# - 增加系统内存
# - 优化数据保留策略
# - 使用SSD存储
</code></pre><h3 id=2-consumer-lag-guo-gao>2. <strong>Consumer Lag 过高</strong></h3><pre class=language-java data-lang=java><code class=language-java data-lang=java>// 问题：消费跟不上生产速度
// 解决：
props.put("fetch.min.bytes", 1048576);      // 增大批次大小
props.put("max.poll.records", 5000);        // 增加单次poll记录数
// 增加Consumer实例数量
</code></pre><h3 id=3-wang-luo-dai-kuan-ping-jing>3. <strong>网络带宽瓶颈</strong></h3><pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 问题：网络成为瓶颈
# 解决：
# - 启用压缩
props.put("compression.type", "lz4");
# - 调整网络缓冲区大小
# - 使用更高带宽网络
</code></pre><p>通过合理配置和优化这些缓存层级，可以显著提升 Kafka 的读取性能，降低延迟，提高整体系统吞吐量。</div></div></section>