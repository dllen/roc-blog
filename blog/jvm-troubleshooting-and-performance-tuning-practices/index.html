<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>JVM 问题定位与性能调优实战经验 | 码农的自留地</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto px-auto xl:px-0 w-full xl:w-1/2 flex place-content-between py-16 xl:py-8 font-sans text-6xl xl:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mx-auto w-full xl:w-1/2 mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl xl:text-base">2025-10-25</div><h1 class="w-full xl:w-2/3 mt-4 mb-8 font-serif text-8xl xl:text-4xl text-slate-900 dark:text-slate-300">JVM 问题定位与性能调优实战经验</h1><div class="mt-2 mb-6 flex flex-wrap gap-2"></div><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class="prose dark:prose-invert prose-pre:rounded-none prose-headings:bg-amber-100 prose-headings:text-slate-800 dark:prose-headings:bg-indigo-900 prose-headings:font-normal dark:prose-headings:text-slate-300 prose-headings:p-2 prose-headings:w-max prose-headings:font-serif prose-2xl xl:prose-base"><h1 id=yin-yan>引言</h1><p>JVM 是 Java 应用的运行时基石，性能与稳定性直接决定服务的可靠性与体验。生产中常见问题包括：<ul><li>Full GC 频繁导致请求卡顿或超时<li>内存泄漏引发 OOM/频繁 GC、吞吐骤降<li>线程阻塞/死锁导致吞吐下降、响应延迟拉高</ul><p>本文结合真实生产案例，总结定位方法、调优参数与验证路径，覆盖 JDK8/11 差异与 Spring 框架特例，给出可复制的命令与配置示例。<p>原理示意（简化）：<pre><code>请求流量 -> 线程池处理 -> 对象分配/回收 -> GC 与停顿 -> 状态观测与调优
               |            |           ^            |
               |            v           |            v
           分配速率     老年代晋升   暂停时间     指标与日志
</code></pre><h1 id=li-lun-ji-chu>理论基础</h1><ul><li><p>JVM 内存模型（简化）</p> <ul><li>年轻代（Eden + Survivor）：新对象分配与 Minor GC<li>老年代：长寿命对象、晋升与 Full GC<li>元空间（JDK8+）：类元数据；JDK7 及之前为永久代（PermGen）</ul><li><p>垃圾回收机制</p> <ul><li>JDK8 默认 Parallel GC（也常见 CMS），JDK11 默认 G1 GC<li>G1：分区化区域、预测停顿；支持 <code>MaxGCPauseMillis</code> 与并发标记<li>ZGC/Shenandoah（新 GC）：极低停顿，适合大堆，需更高版本支持与评估</ul><li><p>统一日志</p> <ul><li>JDK8：<code>-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log</code><li>JDK11：<code>-Xlog:gc*,safepoint=info:file=gc.log:time,uptime,level,tags</code></ul><li><p>背景知识</p> <ul><li>理解堆分区与 GC 日志是定位停顿与吞吐问题的基础；JDK8/11 的日志语法不同但目标一致：还原 GC 事件时间线与影响因素</ul><li><p>实现原理</p> <ul><li>年轻代 Minor GC 触发于 Eden 满载；幸存者区（S0/S1）年龄达到阈值晋升老年代；老年代达到阈值触发并发标记与回收（G1），或 Full GC</ul><li><p>实际应用场景</p> <ul><li>在线服务需控制 p95/p99 停顿；批处理关注吞吐与回收效率；大堆（>8G）倾向选 G1/ZGC，结合对象存活曲线评估</ul></ul><p>配图示意：<ul><li>JVM 内存模型：<img alt="JVM 内存模型" src=/jvm-memory-model-diagram.svg><li>GC 生命周期与路径：<img alt="GC 流程示意" src=/jvm-gc-flow-diagram.svg></ul><hr><h1 id=shi-zhan-an-li-yi-dian-shang-xi-tong-full-gc-pin-fan-dao-zhi-fu-wu-qia-dun>实战案例一：电商系统 Full GC 频繁导致服务卡顿</h1><ul><li><p>问题现象</p> <ul><li>峰值时段接口 p95 延迟由 150ms 升至 2.5s；GC 日志显示 Full GC 每 20–40s 触发<li>指标：CPU 70–85%，OldGen 使用率持续上升；Safepoint 触发次数增多</ul><li><p>诊断过程</p> <ul><li>快速采样：<pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash>jcmd &LTPID> VM.flags
jcmd &LTPID> GC.heap_info
jstat -gcutil &LTPID> 1000 20
</code></pre><li>线程栈：<pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash>jstack -l &LTPID> > jstack.txt
</code></pre> 观察到部分线程在 JSON 序列化与缓存键拼接上出现大量短生命周期对象分配<li>堆直方图：<pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash>jmap -histo &LTPID> | head -n 50
</code></pre> Top N 对象以 <code>char[]</code>、<code>StringBuilder</code>、<code>byte[]</code> 为主，Eden 分配速率高、晋升加剧</ul><li><p>解决方案</p> <ul><li>切换 GC：JDK11 使用 G1，或 JDK8 启用 G1<pre><code>-XX:+UseG1GC -XX:MaxGCPauseMillis=200 \
-XX:InitiatingHeapOccupancyPercent=35 \
-XX:+UseStringDeduplication
</code></pre><li>对象分配优化：缓存键合并、减少临时 <code>StringBuilder</code> 拼接；JSON 序列化改为复用缓冲<li>堆大小与新生代比例：<pre><code>-Xms4g -Xmx4g -XX:MaxGCPauseMillis=200
</code></pre> 视业务调整 <code>-XX:G1NewSizePercent=20</code>、<code>-XX:G1MaxNewSizePercent=40</code></ul><li><p>效果验证</p> <ul><li>优化后：Full GC 几乎无；Minor GC 间隔 3–8s，p95 延迟降至 180–250ms<li>指标对比（示例）<table><thead><tr><th>指标<th style=text-align:right>优化前<th style=text-align:right>优化后<tbody><tr><td>p95 延迟（ms）<td style=text-align:right>2500<td style=text-align:right>200<tr><td>Full GC 次数（/h）<td style=text-align:right>90<td style=text-align:right>2<tr><td>OldGen 利用率（峰值）<td style=text-align:right>92%<td style=text-align:right>65%</table><li>监控示例图：<img alt="GC 指标对比图" src=/case1-gc-metrics-comparison.svg></ul><li><p>背景知识</p> <ul><li>电商高峰期对象分配速率暴涨，年轻代频繁回收与晋升导致老年代压力增大；缓存键拼接与 JSON 序列化是典型短生命周期对象热点</ul><li><p>实现原理</p> <ul><li>G1 通过分区（Region）与并发标记控制停顿目标，<code>MaxGCPauseMillis</code> 影响分区选择与回收预算；<code>InitiatingHeapOccupancyPercent</code> 控制并发标记的触发阈值</ul><li><p>实际应用场景</p> <ul><li>吞吐与低延迟兼顾的在线业务；字符串与序列化对象过多的接口；峰值流量下对 Full GC 敏感的交易与风控服务</ul></ul><hr><h1 id=shi-zhan-an-li-er-da-shu-ju-ying-yong-nei-cun-xie-lou-ding-wei-yu-xiu-fu>实战案例二：大数据应用内存泄漏定位与修复</h1><ul><li><p>问题现象</p> <ul><li>任务运行数小时后堆使用逼近上限并 OOM；<code>OutOfMemoryError: Java heap space</code> 与 <code>GC overhead limit exceeded</code></ul><li><p>诊断过程</p> <ul><li>启用 OOM 堆转储并采集：<pre><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof
</code></pre><li>使用 MAT/VisualVM 打开 dump，分析 Dominator Tree 与保留集大小<li>发现自定义缓存 Map 未做过期与上限控制，且 Spring 单例中持有强引用导致无法回收</ul><li><p>解决方案</p> <ul><li>缓存改造：引入 Caffeine，启用 TTL/大小上限与弱引用 value；定期 metrics 观测命中率<li>Spring 特例：对单例 Bean 引用使用事件驱动清理、避免静态集合持有强引用；对 <code>ThreadLocal</code> 调用结束时显式 <code>remove()</code><li>参数：适度增大堆并保持统一 GC 日志，确认泄漏已闭环</ul><li><p>效果验证</p> <ul><li>OOM 消失；堆使用稳定在 55–70% 区间；GC 周期稳定，Minor GC 2–6s 一次<li>直方图 TopN 不再出现异常增长的自定义实体/集合类</ul><li><p>背景知识</p> <ul><li>大数据应用中长生命周期集合与缓存极易引发保留集膨胀；Spring 单例生命周期贯穿应用运行期，易形成强引用链</ul><li><p>实现原理</p> <ul><li>Dominator Tree 揭示对象保留关系；Caffeine TTL/大小上限与弱/软引用降低强引用保留；<code>ThreadLocal</code> 未清理导致 ClassLoader 泄漏</ul><li><p>实际应用场景</p> <ul><li>ETL/流式任务的状态缓存；Web 服务的本地缓存/静态集合；框架级单例组件的资源持有</ul></ul><p>配图示意：<img alt="Spring 单例缓存强引用示意" src=/spring-leak-architecture.svg><hr><h1 id=shi-zhan-an-li-san-gao-bing-fa-chang-jing-xian-cheng-zu-sai-yu-can-shu-you-hua>实战案例三：高并发场景线程阻塞与参数优化</h1><ul><li><p>问题现象</p> <ul><li>峰值 QPS 提升后吞吐不增反降；Web 层线程池饱和，队列等待；数据库连接池偶发耗尽</ul><li><p>诊断过程</p> <ul><li>线程池与阻塞采样：<pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash>jstack -l &LTPID> | grep -A3 -E "WAITING|BLOCKED" | head -n 50
</code></pre> 发现部分请求在同步远程调用时长时间等待<li>异步剖析（建议）：<pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash>./profiler.sh -e cpu -d 60 -f /tmp/cpu.svg &LTPID>
./profiler.sh -e wall -d 60 -f /tmp/wall.svg &LTPID>
</code></pre> 定位到序列化与网络 I/O 占比过高</ul><li><p>解决方案</p> <ul><li>线程池参数：合理设置核心/最大线程与队列长度，避免过大队列导致延迟扩散<pre><code># Spring Boot 示例（application.yml）
server.tomcat.threads.max: 300
server.tomcat.accept-count: 200
</code></pre><li>HikariCP：连接池容量与超时参数与数据库上限一致，避免饱和抖动<pre><code>spring.datasource.hikari.maximum-pool-size: 50
spring.datasource.hikari.connection-timeout: 30000
</code></pre><li>I/O 异步化：使用 WebClient/异步 HTTP 客户端改善阻塞；序列化复用缓冲与开启压缩按需</ul><li><p>效果验证</p> <ul><li>吞吐从 6k rps 提升至 11k rps；p95 延迟由 800ms 降至 260ms<li>队列等待基本消除，<code>BLOCKED/WAITING</code> 线程显著降低</ul><li><p>背景知识</p> <ul><li>高并发场景中线程池与下游连接池的容量规划、队列策略与超时配置直接影响延迟扩散与系统稳定性</ul><li><p>实现原理</p> <ul><li>线程状态 <code>RUNNABLE/WAITING/BLOCKED</code> 反映资源争用与同步阻塞；异步 I/O 降低阻塞等待；合理队列与限流避免过载</ul><li><p>实际应用场景</p> <ul><li>在线 API、网关、订单与支付服务；数据库/缓存/外部 HTTP 依赖明显的系统</ul></ul><p>配图示意：<img alt=线程阻塞与队列放大示意 src=/thread-blocking-flow.svg><hr><h1 id=tong-yong-diao-you-can-shu-yu-ming-ling-shi-li>通用调优参数与命令示例</h1><ul><li>统一 GC 日志与诊断 <ul><li>JDK8：<pre><code>-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/var/log/app/gc.log \
-XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime
</code></pre><li>JDK11：<pre><code>-Xlog:gc*,safepoint=info:file=/var/log/app/gc.log:time,uptime,level,tags
</code></pre></ul><li>典型堆与 GC 参数<pre><code>-Xms4g -Xmx4g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 \
-XX:InitiatingHeapOccupancyPercent=35 -XX:+UseStringDeduplication \
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof
</code></pre><li>快速命令清单<pre class=language-bash data-lang=bash><code class=language-bash data-lang=bash># 查看 JVM 启动参数，确认 GC 类型与关键调优项
jcmd &LTPID> VM.flags
# 查看堆结构与各区大小，评估晋升与老年代压力
jcmd &LTPID> GC.heap_info
# 以 1s 间隔采集 20 次 GC 利用率，观察 Minor/Full GC 频率
jstat -gcutil &LTPID> 1000 20
# 导出线程堆栈（含锁/等待），定位阻塞与热点代码路径
jstack -l &LTPID> > jstack.txt
# 堆直方图，统计 TopN 对象类型与实例数，识别泄漏或分配热点
jmap -histo &LTPID> | head -n 50
</code></pre></ul><p>原理示意（简化）：<pre><code>采样 -> 发现热点 -> 参数与代码调整 -> 指标回归
       ^-----------------------------------|
</code></pre><blockquote><p>注意：所有数据均已脱敏；在生产环境变更 JVM 参数前需进行灰度与回归测试，特别是 GC 类型切换与堆大小变更。</blockquote><hr><h1 id=jdk8-11-chai-yi-yu-spring-te-li>JDK8/11 差异与 Spring 特例</h1><ul><li>JDK8 vs JDK11 <ul><li>默认 GC：Parallel/CMS（常见） vs G1；统一日志从 <code>PrintGC*</code> 到 <code>Xlog</code><li>字符串去重：JDK8/11 G1 支持 <code>UseStringDeduplication</code>，对大量相同字符串有效<li>ZGC（JDK11+）、Shenandoah（部分发行版）：低停顿方案，需评估稳定性与生态</ul><li>Spring 特例 <ul><li>单例 Bean 持有静态集合导致泄漏；Web 容器热部署/类加载器泄漏风险<li>Tomcat 线程与队列、HikariCP 连接池参数需与后端系统容量一致<li>Actuator/指标采集过度会带来额外对象分配与锁竞争，需限流与采样</ul></ul><hr><h1 id=zong-jie-yu-zui-jia-shi-jian>总结与最佳实践</h1><ul><li>指标驱动：以 p95 延迟、吞吐、GC 周期/时长、OldGen 占比为核心指标<li>渐进式调整：从日志与采样入手，小步迭代，保留回滚路径（配置版本化）<li>结合业务：对象分配速率与状态大小决定 GC 策略与堆规划<li>框架特性：Spring 下注意单例与连接池、线程池、序列化策略的交互影响</ul><p>参考与延伸阅读：<ul><li>GC 调优（JDK11）：https://docs.oracle.com/javase/11/gctuning/<li>G1 GC 原理与参数：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html<li>Unified Logging（JDK9+）：https://docs.oracle.com/javase/9/tools/java.htm#JSWOR690<li>Async-Profiler：https://github.com/async-profiler/async-profiler<li>VisualVM：https://visualvm.github.io/</ul></div></div></section>